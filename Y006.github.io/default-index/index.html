<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="manifest" href="/manifest.json">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"y006.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":{"disqus":{"text":"Load Disqus","order":-1},"gitalk":{"order":-2}}},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

  <meta name="description" content="联系我：2420457716@qq.com">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="https://y006.github.io/default-index/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="联系我：2420457716@qq.com">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="邱金羽">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://y006.github.io/default-index/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"default-index/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">邱金羽的技术博客！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="邱金羽"
      src="/images/custom-logo.jpg">
  <p class="site-author-name" itemprop="name">邱金羽</p>
  <div class="site-description" itemprop="description">联系我：2420457716@qq.com</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/32844822/dynamic" title="Bilibili个人空间 → https:&#x2F;&#x2F;space.bilibili.com&#x2F;32844822&#x2F;dynamic" rel="noopener" target="_blank">Bilibili个人空间</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/qiu-jin-yu-60" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;qiu-jin-yu-60" rel="noopener" target="_blank">知乎</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://uinika.github.io/" title="https:&#x2F;&#x2F;uinika.github.io&#x2F;" rel="noopener" target="_blank">UinIO</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://fazzie-key.cool/" title="https:&#x2F;&#x2F;fazzie-key.cool&#x2F;" rel="noopener" target="_blank">摸黑干活</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://eater.net/" title="https:&#x2F;&#x2F;eater.net&#x2F;" rel="noopener" target="_blank">Ben Eater</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.52diy.com.cn/" title="https:&#x2F;&#x2F;blog.52diy.com.cn&#x2F;" rel="noopener" target="_blank">52diy</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://gaoyichao.com/Xiaotu/" title="https:&#x2F;&#x2F;gaoyichao.com&#x2F;Xiaotu&#x2F;" rel="noopener" target="_blank">小土的世界</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stm32f4-discovery.net/" title="https:&#x2F;&#x2F;stm32f4-discovery.net&#x2F;" rel="noopener" target="_blank">Tilen Majerle</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mculover666.blog.csdn.net/" title="https:&#x2F;&#x2F;mculover666.blog.csdn.net&#x2F;" rel="noopener" target="_blank">Mculover666</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yourname" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/09/02/09-01-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/02/09-01-15/" class="post-title-link" itemprop="url">verilog 开源工具链配置笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-02 09:01:15" itemprop="dateCreated datePublished" datetime="2022-09-02T09:01:15+08:00">2022-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-08 17:22:23" itemprop="dateModified" datetime="2022-09-08T17:22:23+08:00">2022-09-08</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/09/02/09-01-15/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/09/02/09-01-15/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="效果展示">效果展示</h3>
<p>本文配置的最终效果展示如下：</p>
<p>Win11+VScode+oss-cad</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902092406126.png" alt="image-20220902092406126"><figcaption aria-hidden="true">image-20220902092406126</figcaption>
</figure>
<h3 id="工具介绍及安装">工具介绍及安装</h3>
<p>首先介绍一下 VScode。VSCode（全称：Visual Studio Code）是一款由微软开发且跨平台的免费源代码编辑器。该软件支持语法高亮、代码自动补全等功能。VScode 的强大之处在于用户可以通过内置的扩展程序商店安装扩展以拓展软件功能。你可以在 <a target="_blank" rel="noopener" href="https://code.visualstudio.com/">VScode 官网</a> 下载并安装 VScode，安装方法非常简单，这里不再进行说明。</p>
<p>在 verilog 开发中，我们可以通过添加 "<a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=mshr-h.VerilogHDL">Verilog-HDL/SystemVerilog/Bluespec SystemVerilog support for VS Code</a>" 插件实现 verilog 代码高亮和代码自动补全等功能。你可以直接在 VScode 的扩展中搜索并一键安装这个插件：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902093933026.png" alt="image-20220902093933026"><figcaption aria-hidden="true">image-20220902093933026</figcaption>
</figure>
<p>通过类似的方式，搜索并安装下面两个插件：</p>
<p>左边的插件可以帮助你查看综合出的 .dot 格式的电路图文件，右边的插件可以帮你根据 .vcd 文件生成波形图：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902094417294.png" alt="image-20220902094417294"><figcaption aria-hidden="true">image-20220902094417294</figcaption>
</figure>
<p>上面展示的 verilog 代码的编译和综合过程主要使用到了两个工具：iVerilog 和 Yosys。这两个工具，包括也是非常常用的波形查看工具 GTKwave 都被集成在了一个开源工具组件 OSS CAD Suite 中。OSS CAD 套件中还有很多用于数字逻辑设计的开源软件的二进制软件发行版。你可以在这个 <a target="_blank" rel="noopener" href="https://github.com/YosysHQ/oss-cad-suite-build">GitHub 页面</a> 中进行查看。</p>
<p>如果想要安装和使用 OSS CAD Suite ，我们可以直接在 <a target="_blank" rel="noopener" href="https://github.com/YosysHQ/oss-cad-suite-build/releases/tag/2022-09-01">这个界面</a> 下载 .exe 文件：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902095721658.png" alt="image-20220902095721658"><figcaption aria-hidden="true">image-20220902095721658</figcaption>
</figure>
<p>下载完成后直接运行这个 .exe 文件，即可获得这样一个文件夹：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902095934878.png" alt="image-20220902095934878"><figcaption aria-hidden="true">image-20220902095934878</figcaption>
</figure>
<p>我将这个 OSS CAD Suite 放在了我自己在 D盘 创建的 Program_Files 文件夹。在这个目录下，我们要重点关注第一个 bin 文件夹和最后标红的两个 .bat 文件。第一个 bin 文件夹里面是 OSS CAD Suite 介绍中所说的，用于数字逻辑设计的开源软件的二进制软件发行版。你可以从这个文件夹中找到包括 iVerilog、GTKwave 和 Yosys。</p>
<p>那么如何使用这些组件呢？ OSS CAD Suite 提供了两种方法，一种是直接点击 start.bat 文件，然后使用命令的方式进行操作：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902100630814.png" alt="image-20220902100630814"><figcaption aria-hidden="true">image-20220902100630814</figcaption>
</figure>
<p>第二种方案是通过命令行工具，在 cmd 中调用 environment.bat 来使用该工具：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902101420630.png" alt="image-20220902101420630"><figcaption aria-hidden="true">image-20220902101420630</figcaption>
</figure>
<p>但是，之前我们的操作都是在 VScode 上进行的，所以我们希望也把 OSS CAD Suite 的使用放在 VScode 内进行，有没有办法呢？我的解决方案是使用第二种方法调用 OSS CAD Suite ，只要使用 VScode 内置的 cmd （终端）来实现调用 environment.bat 即可。操作如下：</p>
<p>首先如下图提示的，我们使用快捷键调出终端</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902101612341.png" alt="image-20220902101612341"><figcaption aria-hidden="true">image-20220902101612341</figcaption>
</figure>
<p>我们可以将终端移动到编辑器区域：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902101716445.png" alt="image-20220902101716445"><figcaption aria-hidden="true">image-20220902101716445</figcaption>
</figure>
<p>然后我们注意到这个终端不是 cmd，而是 powershell，两者的区别读者可以自己去查一下，这里我们还是使用 cmd 来演示：注意在 cmd 中可以使用 tab 键进行补全。</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902102107905.png" alt="image-20220902102107905"><figcaption aria-hidden="true">image-20220902102107905</figcaption>
</figure>
<p>到此为止我们已经进行了全部内容的安装。下面我们使用一个 4 选 1 多路选择器代码进行演示：</p>
<h3 id="使用方法">使用方法</h3>
<p>首先新建一个文件夹，然后选择使用 VScode 打开：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902102705459.png" alt="image-20220902102705459"><figcaption aria-hidden="true">image-20220902102705459</figcaption>
</figure>
<p>然后建立如下目录结构：红框内的第一个图标是新建文件，第二个是新建文件夹</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902103003482.png" alt="image-20220902103003482"><figcaption aria-hidden="true">image-20220902103003482</figcaption>
</figure>
<p>输入代码：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902103049078.png" alt="image-20220902103049078"><figcaption aria-hidden="true">image-20220902103049078</figcaption>
</figure>
<p>附上代码：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Verilog HDL 数字设计与综合（第二版）（本科教学版）例6.2</span></span><br><span class="line"><span class="comment">//用逻辑方程描述四选一多路选择器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mux4_to_1 (out, i0, i1, i2, i3, s1, s0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接取自输入输出图的端口声明语句</span></span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">input</span> i0, i1, i2, i3, s1, s0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生输出 out 的逻辑方程</span></span><br><span class="line">    <span class="keyword">assign</span> out = ( ~s1 &amp; ~s0 &amp; i0)|</span><br><span class="line">                 ( ~s1 &amp;  s0 &amp; i1)|</span><br><span class="line">                 (  s1 &amp; ~s0 &amp; i2)|</span><br><span class="line">                 (  s1 &amp;  s0 &amp; i3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写无端口激励模块</span></span><br><span class="line"><span class="comment">//为了使用yosys来进行综合，我们将电路描述模块和激励模块分离，然后对mux4_to_1.v进行单独的综合</span></span><br><span class="line"><span class="keyword">module</span> stimulus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明连接到输入端口的变量</span></span><br><span class="line">    <span class="keyword">reg</span> IN0,IN1,IN2,IN3;</span><br><span class="line">    <span class="keyword">reg</span> S1,S0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明输出连线</span></span><br><span class="line">    <span class="keyword">wire</span> OUTPUT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用（实例引用）多路选择器</span></span><br><span class="line">    mux4_to_1 my_mux(OUTPUT,IN0,IN1,IN2,IN3,S1,S0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生输入激励信号</span></span><br><span class="line">    <span class="comment">//Define the stimulus module (no ports)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//设置输入线信号</span></span><br><span class="line">        IN0 = <span class="number">1</span>;</span><br><span class="line">        IN1 = <span class="number">0</span>;</span><br><span class="line">        IN2 = <span class="number">1</span>;</span><br><span class="line">        IN3 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;IN0 = %b, IN1 = %b, IN2 = %b, IN3 = %b&quot;</span>,IN0,IN1,IN2,IN3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择IN0；</span></span><br><span class="line">        S1 = <span class="number">0</span>;</span><br><span class="line">        S0 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;S1 = %b, S0 = %b, OUTPUT = %b&quot;</span>,S1, S0, OUTPUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择IN0；</span></span><br><span class="line">        S1 = <span class="number">0</span>;</span><br><span class="line">        S0 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;S1 = %b, S0 = %b, OUTPUT = %b&quot;</span>,S1, S0, OUTPUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择IN0；</span></span><br><span class="line">        S1 = <span class="number">1</span>;</span><br><span class="line">        S0 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;S1 = %b, S0 = %b, OUTPUT = %b&quot;</span>,S1, S0, OUTPUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择IN0；</span></span><br><span class="line">        S1 = <span class="number">1</span>;</span><br><span class="line">        S0 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;S1 = %b, S0 = %b, OUTPUT = %b&quot;</span>,S1, S0, OUTPUT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产 VCD 文件需要的代码（非例题代码）</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">        <span class="built_in">$dumpfile</span>(<span class="string">&quot;wave.vcd&quot;</span>); <span class="comment">//生成波形文件vcd的名称 </span></span><br><span class="line">        <span class="built_in">$dumpvars</span>(<span class="number">0</span>, stimulus); <span class="comment">//tb模块名称</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后保存文件，打开终端，先进入 oss-cad-suite 文件夹打开 environment.bat 然后再回到 verilog 文件目录下对目标文件进行操作</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902103520387.png" alt="image-20220902103520387"><figcaption aria-hidden="true">image-20220902103520387</figcaption>
</figure>
<p>然后进行编译等一系列操作：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iverilog -o mux4_to_1<span class="variable">.vvp</span> -y ./ mux4_to_1_tb<span class="variable">.v</span> mux4_to_1<span class="variable">.v</span></span><br><span class="line">vvp mux4_to_1<span class="variable">.vvp</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902104216297.png" alt="image-20220902104216297"><figcaption aria-hidden="true">image-20220902104216297</figcaption>
</figure>
<p>然后在终端可以看到 <code>$display()</code> 的内容，然后我们查看 .vcd 文件：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902104553493.png" alt="image-20220902104553493"><figcaption aria-hidden="true">image-20220902104553493</figcaption>
</figure>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902104654196.png" alt="image-20220902104654196"><figcaption aria-hidden="true">image-20220902104654196</figcaption>
</figure>
<p>接下来我们进行综合：</p>
<p>首先进入 yosys，然后读入文件，处理文件，最后导出 .dot 格式</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902105334206.png" alt="image-20220902105334206"><figcaption aria-hidden="true">image-20220902105334206</figcaption>
</figure>
<p>过程如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read_verilog mux4_to_1.v</span><br><span class="line">hierarchy -check</span><br><span class="line">proc; opt; opt; fsm; memory; opt</span><br><span class="line">show -format dot -prefix ./mux4_to_1</span><br></pre></td></tr></table></figure>
<p>得到结果：</p>
<p>最终结果展示：其中 <code>.dot</code> 文件打开后可以使用快捷键 <code>Ctrl+Shift+v</code> 得到可视化电路图。</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902105858211.png" alt="image-20220902105858211"><figcaption aria-hidden="true">image-20220902105858211</figcaption>
</figure>
<p>注：默认不读入工艺库的话，Yosys 使用自带的工艺库。</p>
<h3 id="isseus-and-solution">Isseus and Solution</h3>
<p>这一小节记录一下我初用这个工具链遇到的问题：</p>
<ol type="1">
<li><p><strong>Isseus：</strong>进行编译和波形测试时，发现VScode上的WaveTrace插件不能正常进行查看，但是使用GTKwave开源查看，我的编译仿真指令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iverilog -o wave -y ./  alu_tb.v  alu.v </span><br><span class="line">vvp -n wave -lxt2</span><br></pre></td></tr></table></figure>
<p><strong>Solution：</strong>使用下面的指令来生成 .vcd 图像：即不要携带 <code>-lxt2</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vvp wave</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Isseus：</strong>Yosys 出现如下报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: System task `$display&#x27; called with invalid/unsupported format specifier.</span><br></pre></td></tr></table></figure>
<p><strong>Solution：</strong>如果出现这个报错，考虑将测试的module放在一个单独的文件中，使yosys操作的对象不包括测试使用的module</p></li>
<li><p><strong>Isseus：</strong>==待解决==在 Yosys 命令行中使用 help 指令可以看到 Yosys 中提供指令可以导出有限状态机的图：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220904194326503.png" alt="image-20220904194326503"><figcaption aria-hidden="true">image-20220904194326503</figcaption>
</figure>
<p>即指令 <code>fsm_export</code>，但是在实际操作中使用该指令后打印如下日志：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220904194520104.png" alt="image-20220904194520104"><figcaption aria-hidden="true">image-20220904194520104</figcaption>
</figure>
<p>但是没有 KISS2 文件在操作目录下生成。</p>
<p><strong>Solution：</strong>这个问题目前没有被解决，但是这里有两个网页可以提供重要参考</p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://github.com/YosysHQ/yosys/issues/2402">Command "fsm_export" does not generate a .kiss2 file to represent correspondings FSM · Issue #2402 · YosysHQ/yosys</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/32645965/fsm-export-using-yosys">verilog - FSM export using Yosys - Stack Overflow</a></li>
</ol></li>
</ol>
<h3 id="在-yosys-中使用工艺库">在 Yosys 中使用工艺库</h3>
<p>在上面的过程中，我们使用 Yosys 读入 <code>.v</code> 文件，将高层次的描述转化为寄存器传输级描述（RTL）进而得到门级描述，然后在转化中我们都进行了化简和优化。得到的门级描述使用 Yosys 自带的单元（cells）进行的描述。我们可以在 Yosys中使用指令 <code>help -cells</code> 来查看 Yosys 默认使用的单元列表：如下图。</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905081644337.png" alt="image-20220905081644337"><figcaption aria-hidden="true">image-20220905081644337</figcaption>
</figure>
<p>我们可以看到 Yosys 中包含有 <code>$_AND_</code> 或者 <code>$_ANDNOT_</code> 这种单元。首先我们先用默认的单元来综合我们的电路，然后导入新的单元来构建满足新工艺库的电路。</p>
<p>用来演示的 Verilog 文件来自 <code>..\yosys-master\yosys-master\examples\cmos</code>，你可以在<a target="_blank" rel="noopener" href="https://github.com/YosysHQ/yosys/tree/master/examples/cmos">这里</a>查看。</p>
<p>首先我在 <code>..\yosys-master\yosys-master\examples</code> 目录下创建了一个新的文件夹 <code>my_cmos</code>，然后将 <code>cmos</code> 中的 <code>counter.v</code> 文件移动到 <code>my_cmos</code> 中，然后复制<a target="_blank" rel="noopener" href="https://vlsiarch.ecen.okstate.edu/flows/MOSIS_SCMOS/latest/cadence/lib/tsmc025/signalstorm/osu025_stdcells.lib">这里</a>的代码到 <code>my_cmos</code> 文件夹中并命名为 <code>osu025_stdcells.lib</code>。最后使用 oss-cad 组件打开 <code>my_cmos</code> 这个文件夹进行后续操作。</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905093413337.png" alt="image-20220905093413337"><figcaption aria-hidden="true">image-20220905093413337</figcaption>
</figure>
<p>然后进入 Yosys，使用下述指令读入文件到 Yosys：这是我们导入自己的单元库的方法。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read_verilog counter.v</span><br><span class="line">read_liberty osu025_stdcells.lib</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905094143056.png" alt="image-20220905094143056"><figcaption aria-hidden="true">image-20220905094143056</figcaption>
</figure>
<p>现在我们使用快捷键 <code>Ctrl+D</code> 退出 Yosys。然后我们来生成电路图展示一下 yosys 对于电路图的处理。同时我们引入 yosys 指令批量处理的方法：</p>
<p>首先将下述指令复制到一个新建文件夹 <code>my_cells.ys</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">读入 counter.v</span></span><br><span class="line">read_verilog counter.v</span><br><span class="line"><span class="meta"># </span><span class="language-bash">读入后不做任何处理直接显示 counter.v 电路图，生成的文件起名为 a.dot</span></span><br><span class="line">show -prefix ./a</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">synth 指令由一些列综合和化简指令构成，这个命令组最后的效果是得到由 yosys 自带的 cells 构建的电路图</span></span><br><span class="line">synth</span><br><span class="line"><span class="meta"># </span><span class="language-bash">将化简后的结果显示成电路图b</span></span><br><span class="line">show -prefix ./b</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">导入 osu025_stdcells.lib，用库中的 FF(flip-flop) 去替换 yosys 自带的 FF</span></span><br><span class="line">dfflibmap -liberty osu025_stdcells.lib</span><br><span class="line"><span class="meta"># </span><span class="language-bash">将替换触发器后的电路图导出为c</span></span><br><span class="line">show -prefix ./c</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">替换自带的组合逻辑器件</span></span><br><span class="line">abc -liberty osu025_stdcells.lib</span><br><span class="line"><span class="meta"># </span><span class="language-bash">化简</span></span><br><span class="line">opt</span><br><span class="line"><span class="meta"># </span><span class="language-bash">将替换组合逻辑器件后的电路图导出为d</span></span><br><span class="line">show -prefix ./d</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">读入 osu025_stdcells.lib，yosys可以将其中的cells转化为modules</span></span><br><span class="line">read_liberty osu025_stdcells.lib</span><br><span class="line"><span class="meta"># </span><span class="language-bash">最终结果e,只展示 couter module，不展示 osu025_stdcells.lib 中的modules</span></span><br><span class="line">show -prefix ./e counter</span><br></pre></td></tr></table></figure>
<p>然后在 oss-cad 组件中使用 <code>yosys -s my_cells.ys</code> 来批量执行指令</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905105049582.png" alt="image-20220905105049582"><figcaption aria-hidden="true">image-20220905105049582</figcaption>
</figure>
<p>然后打开 <code>.dot</code> 文件观察结果</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905105508223.png" alt="image-20220905105508223"><figcaption aria-hidden="true">image-20220905105508223</figcaption>
</figure>
<p>这两张图重复了使用方法一节中展现的化简过程</p>
<p>然后我们观察后面几张图</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905110336491.png" alt="image-20220905110336491"><figcaption aria-hidden="true">image-20220905110336491</figcaption>
</figure>
<p>上图为了进行对比，可能图片不是非常清晰，大家可以自己动手做一下然后进行观察。</p>
<p>到此我们就实现了自己的cells库的导入，你可以进一步通过 <code>write_verilog</code> 指令导出综合后的电路图。</p>
<h3 id="进一步的参考">进一步的参考</h3>
<p>如果想要进一步了解 Yosys 的使用，推荐使用 <a target="_blank" rel="noopener" href="https://yosyshq.net/yosys/files/yosys_appnote_011_design_investigation.pdf">Yosys AppNote 011</a>、<a target="_blank" rel="noopener" href="https://github.com/YosysHQ/yosys-manual-build/releases/download/manual/manual.pdf">Yosys manual</a> 两篇文章进行学习</p>
<p>如果想要配置 STA 工具，可以参考此工具 <a target="_blank" rel="noopener" href="https://github.com/YosysHQ/yosys-manual-build/releases/download/manual/manual.pdf">OpenTimer</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/07/30/15-15-44/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/30/15-15-44/" class="post-title-link" itemprop="url">Spieed Maix Duino开发板使用小记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-07-30 15:15:44 / 修改时间：17:25:49" itemprop="dateCreated datePublished" datetime="2022-07-30T15:15:44+08:00">2022-07-30</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/07/30/15-15-44/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/07/30/15-15-44/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="sipeed-maixduino使用小记">SIPEED MaixDuino使用小记</h1>
<h2 id="开箱跑例程">开箱跑例程</h2>
<p>开箱后将摄像头、TF卡、显示屏都装到开发板上，上电后如下图所示。</p>
<figure>
<img src="/2022/07/30/15-15-44/88b4b368daca77a34d4d3d51c32b1ff.jpg" alt="88b4b368daca77a34d4d3d51c32b1ff"><figcaption aria-hidden="true">88b4b368daca77a34d4d3d51c32b1ff</figcaption>
</figure>
<p>在<a target="_blank" rel="noopener" href="https://dl.sipeed.com/shareURL/MAIX/tools/ftdi_vcp_driver">此处</a>安装驱动：选择第二个</p>
<p><img src="/2022/07/30/15-15-44/image-20220730150511809.png" alt="image-20220730150511809"></p>
<p>解压下载好的文件，然后安装INF文件；两个INF文件都要安装：</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730150747127.png" alt="image-20220730150747127"><figcaption aria-hidden="true">image-20220730150747127</figcaption>
</figure>
<p>下载<a target="_blank" rel="noopener" href="https://dl.sipeed.com/shareURL/MAIX/MaixPy/ide/v0.2.5">官方IDE</a>：下载.exe文件进行安装</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730151011092.png" alt="image-20220730151011092"><figcaption aria-hidden="true">image-20220730151011092</figcaption>
</figure>
<p>验证摄像头：第一步点击连接后需要选择串口，MaixDuino会在电脑上产生两个串口，其中一个可以使用，自行测试。</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730151246776.png" alt="image-20220730151246776"><figcaption aria-hidden="true">image-20220730151246776</figcaption>
</figure>
<p>进行终端测试：</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730152150910-16591657134626.png" alt="image-20220730152150910"><figcaption aria-hidden="true">image-20220730152150910</figcaption>
</figure>
<p>使用串口连接：直接点确定，一路确定，采用默认模式即可</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730152231846.png" alt="image-20220730152231846"><figcaption aria-hidden="true">image-20220730152231846</figcaption>
</figure>
<p>然后就进入了串口中断模式：</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730152322518.png" alt="image-20220730152322518"><figcaption aria-hidden="true">image-20220730152322518</figcaption>
</figure>
<p>在官方文档的<a target="_blank" rel="noopener" href="https://wiki.sipeed.com/soft/maixpy/zh/get_started/get_started_power_on.html">此处</a>浏览例程，使用串口终端模式进行测试：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/06/24/15-48-41/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/24/15-48-41/" class="post-title-link" itemprop="url">STM32G431-Nucleo-64开发板使用小记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-24 15:48:41" itemprop="dateCreated datePublished" datetime="2022-06-24T15:48:41+08:00">2022-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 22:12:59" itemprop="dateModified" datetime="2022-07-05T22:12:59+08:00">2022-07-05</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/06/24/15-48-41/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/06/24/15-48-41/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="stm32g431-nucleo-64开发板使用小记">STM32G431-Nucleo-64开发板使用小记</h1>
<h2 id="stm32g431-nucleo-64开发板">STM32G431-Nucleo-64开发板</h2>
<h3 id="基本介绍">基本介绍</h3>
<p>实物图片：<img src="/2022/06/24/15-48-41/en.nucleo-g431rb.jpg" alt="en.nucleo-g431rb"></p>
<p>引脚示意图：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220625140101348.png" alt="image-20220625140101348"><figcaption aria-hidden="true">image-20220625140101348</figcaption>
</figure>
<p>特别提醒：如果要设置频率为170MHz（最大频率），需要修改输入为24MHz</p>
<p><img src="/2022/06/24/15-48-41/image-20220702201055670.png" alt="image-20220702201055670" style="zoom:50%;"></p>
<h3 id="点亮led灯">点亮LED灯</h3>
<h4 id="软件选择">软件选择</h4>
<p>使用CubeMX与MAD-ARM</p>
<ul>
<li><p>STMCubeMX：</p>
<p>STMCubeMX是ST公司推出的一种自动创建单片机工程及初始化代码的工具。</p></li>
<li><p>MDK-ARM：</p>
<p>Keil公司开发的ARM开发工具MDK，是用来开发基于ARM核的系列微控制器的嵌入式应用程序。</p></li>
</ul>
<h4 id="实验流程">实验流程</h4>
<p>使用 CubeMX 生成初始化代码 -&gt; 使用 MDK-ARM 编写主函数并编译 -&gt; 使用开发板自带的ST-LINK将编译好的程序烧录到开发板 -&gt; 搭建实物电路 -&gt; 开发板上电，观察现象。</p>
<h4 id="具体操作">具体操作</h4>
<p>打开CubeMX，可以看到如下界面。点击红色方框内的ACCESS TO MCU SELECTRO选择芯片型号。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624155754981.png" alt="image-20220624155754981"><figcaption aria-hidden="true">image-20220624155754981</figcaption>
</figure>
<p>输入芯片型号查找对应芯片，选择“STM32G431RBT6”芯片。具体操作如图所示，操作执行后点击Start Progect进入配置页面。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624161212803.png" alt="image-20220624161212803"><figcaption aria-hidden="true">image-20220624161212803</figcaption>
</figure>
<p>芯片配置页面如下：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624161504627.png" alt="image-20220624161504627"><figcaption aria-hidden="true">image-20220624161504627</figcaption>
</figure>
<p>配置包括 “Pinout &amp; Configuration”、“Clock Configuration”、“Project Manager” 和 “Tools”。</p>
<p>首先配置 “Project Manager”，方式如下：其中 “Code Generator” 和 “Advanced Setings” 暂时用不到。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624162039334.png" alt="image-20220624162039334"><figcaption aria-hidden="true">image-20220624162039334</figcaption>
</figure>
<p>想要点亮LED灯，我们需要对GPIO引脚进行控制，因此返回 “Pinout &amp; Configuration” 配置选项卡，进行输入输出引脚配置。我们选择引脚 PC3 ，将其初始化为高电平，并将输出电平再高低之间进行切换，使用HEL函数延时，每隔1000ms进行一次变换。具体操作如图所示：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624162854160.png" alt="image-20220624162854160"><figcaption aria-hidden="true">image-20220624162854160</figcaption>
</figure>
<p>最后点击生成代码。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624163308481.png" alt="image-20220624163308481"><figcaption aria-hidden="true">image-20220624163308481</figcaption>
</figure>
<p>使用MDK-ARM打开工程，查看CubeMX生成的代码：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624164703328.png" alt="image-20220624164703328"><figcaption aria-hidden="true">image-20220624164703328</figcaption>
</figure>
<p>在主函数中插入我们要编写的LED闪烁代码：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624172922991.png" alt="image-20220624172922991"><figcaption aria-hidden="true">image-20220624172922991</figcaption>
</figure>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_SET);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_RESET);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624173238440.png" alt="image-20220624173238440"><figcaption aria-hidden="true">image-20220624173238440</figcaption>
</figure>
<p>连接电路图，结果展示：</p>
<p><img src="/2022/06/24/15-48-41/image-20220624174456175.png" alt="image-20220624174456175" style="zoom:33%;"></p>
<h3 id="开发板配置">开发板配置</h3>
<p>开发板中的用户按键是高电平有效，默认状态下接PC13。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220702140416463.png" alt="image-20220702140416463"><figcaption aria-hidden="true">image-20220702140416463</figcaption>
</figure>
<p>ST Board 的默认配置中使用外部中断配置按键。</p>
<p>如果使用GPIO口输入模式来实现按键行为，则需要配置为 Pull-down 模式</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624174830465.png" alt="image-20220624174830465"><figcaption aria-hidden="true">image-20220624174830465</figcaption>
</figure>
<p>基本工程配置：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624175021820.png" alt="image-20220624175021820"><figcaption aria-hidden="true">image-20220624175021820</figcaption>
</figure>
<p>直接生成工程：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624175042732.png" alt="image-20220624175042732"><figcaption aria-hidden="true">image-20220624175042732</figcaption>
</figure>
<p>可以看到，针对于这个开发板，默认芯片时钟配置如下：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624180243123.png" alt="image-20220624180243123"><figcaption aria-hidden="true">image-20220624180243123</figcaption>
</figure>
<h3 id="学习使用cubemx中的example">学习使用CubeMX中的Example</h3>
<p>首先打开CubeMX进入工程选项界面，选择 “Example Selector” 。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624192415831.png" alt="image-20220624192415831"><figcaption aria-hidden="true">image-20220624192415831</figcaption>
</figure>
<p>续：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624192555608.png" alt="image-20220624192555608"><figcaption aria-hidden="true">image-20220624192555608</figcaption>
</figure>
<p>在生成选项中，选择生成目录，然后直接使用MDK-ARM打开即可：</p>
<p><img src="/2022/06/24/15-48-41/image-20220624192653458.png" alt="image-20220624192653458" style="zoom:30%;"></p>
<p>打开文档中的readme.txt文件，阅读该例程的使用方法：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624193003158.png" alt="image-20220624193003158"><figcaption aria-hidden="true">image-20220624193003158</figcaption>
</figure>
<p>阅读文档可知，PA08-PA11分别输出四种不同占空比的PWM波形。</p>
<p>编译文件并烧录到开发板中，使用示波器测试PWM波形，得如下结果：</p>
<p>如果对Example中的代码进行了修改并重新编译，可能烧录会出现报错，报错如下：</p>
<p><img src="/2022/06/24/15-48-41/image-20220625170231754.png" alt="image-20220625170231754" style="zoom: 25%;"></p>
<p>该报错可阅读<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42108484/article/details/81272006">此文章</a>寻求解决方案。</p>
<h3 id="按键控制led灯">按键控制LED灯</h3>
<p>首先打开之前 Nucleo-G431RB 的 CubeMX 工程文档，打开其中的 “Nucleo-G431RB_TEST.ioc” 文件：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220625162251778.png" alt="image-20220625162251778"><figcaption aria-hidden="true">image-20220625162251778</figcaption>
</figure>
<p>将其中的 PC2 GPIO口配置为输入 IO 口，具体配置为输入模式、上拉输入。</p>
<p>注意：选择 GPIO 口的输入配置要依据实际电路的连接方式。在我的电路连接中，我将按键的一端与开发板的 GND 相连，另一端与 PC2 相连。则此时应该选择上拉输入——IO 口没有外部信号输入时，STM32 检测到是高电平，有信号时（按键按下时），跟随信号电平（接地，变为低电平）。</p>
<p>将 PC3 GPIO口配置为输出，默认输出为高电平（执行初始化函数 <code>MX_GPIO_Init()</code> 时会输出高电平）。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220625162220949.png" alt="image-20220625162220949"><figcaption aria-hidden="true">image-20220625162220949</figcaption>
</figure>
<p>生成代码，使用MDK-ARM打开生成好的工程文件，在工程文件中的 main.c 文件做如下修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private define ------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PD */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUTTON HAL_GPIO_ReadPin(Button_In_GPIO_Port, Button_In_Pin)</span></span><br><span class="line"><span class="comment">/* USER CODE END PD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//省略……</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略……</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    HAL_GPIO_WritePin(User_White_LED_GPIO_Port, User_White_LED_Pin, GPIO_PIN_RESET);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">      <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">        <span class="keyword">if</span>(BUTTON == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          HAL_Delay(<span class="number">10</span>);</span><br><span class="line">          <span class="keyword">if</span>(BUTTON == <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">while</span>(BUTTON == <span class="number">0</span>);</span><br><span class="line">            HAL_GPIO_TogglePin(User_White_LED_GPIO_Port, User_White_LED_Pin);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改完成后，即可连接电路，检验效果。上述代码执行效果为：</p>
<p>按下按键时可以检测到按键被按下，松手后执行任务（改变LED灯亮灭）。</p>
<p>效果如图：</p>
<h3 id="串口通信">串口通信</h3>
<p>STM32中串口通信有三种方式：</p>
<ul>
<li><p>轮询</p>
<ul>
<li>轮询式串口通信：在主函数的 <code>while(1)</code> 中不停地调用串口通信函数进行通信。</li>
<li>优点：实现逻辑简单</li>
<li>缺点：查询方式下CPU的负担较重，浪费了处理器的能力，不能够很好的处理其他的事件</li>
</ul></li>
<li><p>中断</p>
<ul>
<li><p>中断式串口通信：在接收到信息或需要发送数据时产生中断，在中断服务程序中完成数据的接收与发送。</p></li>
<li><p>优点：相比于轮询式，中断式对CPU利用率要高。</p></li>
<li><blockquote>
<p>缺点：</p>
<p>复杂的系统中，比如移动机器人，处理器需要处理串行口通信，多个传感器数据的采集以及处理，实时轨迹的生成，运动轨迹插补以及位置闭环控制等等任务，牵扯到多个中断的优先级分配问题。为了保证数据发送与接收的可靠性，需要把UART的中断优先级设计较高，但是系统可能还有其他的需要更高优先级的中断，必须保证其定时的准确，这样就有可能造成串行通讯的中断不能及时响应，从而造成数据丢失。</p>
</blockquote></li>
</ul></li>
<li><p>DMA</p>
<ul>
<li>DMA：Direct Memory Access （直接内存访问）。使用DMA进行串口通信时，CPU只需要数据传输开始和结束时做一点处理外，在传输过程中可以进行其他的工作。</li>
<li>如果传输的数据量较大，或者传输速度超过115200时，建议选择DMA方式实现串口通信。</li>
</ul></li>
</ul>
<p>串口通信函数：推荐使用C标准库中的 <code>printf()</code> 函数进行串口通信。想要在单片机使用 <code>printf()</code> 需要：</p>
<ol type="1">
<li>包含头文件 <code>#include &lt;stdio.h&gt;</code></li>
<li>在 Options for Target... 选项卡的 Target 选项栏中的 Code Generation 区域勾选 Use MicroLIB</li>
<li>进行串口重定向——即重新实现 <code>fputc()</code></li>
</ol>
<h4 id="查询模式-printf函数重定向">查询模式 &amp; printf()函数重定向</h4>
<p>配置串口：注意在Nucleo-G431RB开发板上只能使用 PA2 和 PA3 引脚来实现开发板接usb线与电脑进行串口通信。其中 PA2 和 PA3 引脚可以选择 LPUART1 和 USART2 两种。这里我们选择 LPUART1 进行测试。串口调试的配置与串口测试软件保持一致即可。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220627201123958.png" alt="image-20220627201123958"><figcaption aria-hidden="true">image-20220627201123958</figcaption>
</figure>
<p>生成代码，打开工程，进行工程设置：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627201706218.png" alt="image-20220627201706218" style="zoom: 40%;"></p>
<p>如果不设置使用 Use MicroLIB，也可以添加如下代码实现串口重定向：</p>
<p><img src="/2022/06/24/15-48-41/image-20220703135818223.png" alt="image-20220703135818223" style="zoom:50%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> import(__use_no_semihosting)</span></span><br><span class="line"><span class="comment">//标准库需要的支持函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE __stdout;</span><br><span class="line"><span class="comment">//定义_sys_exit()以避免使用半主机模式</span></span><br><span class="line"><span class="type">void</span> _sys_exit(<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)<span class="comment">//如果使用GCC编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)<span class="comment">//keil中适用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">	HAL_UART_Transmit(&amp;hlpuart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//hlpuart1需要根据你的配置修改</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure>
<p>添加代码：</p>
<ol type="1">
<li><p>添加头文件：user_log.h文件见目录： “HAL库小记 -&gt; 串口调试策率 -&gt; 日志打印文件”</p>
<p><img src="/2022/06/24/15-48-41/image-20220627202133564.png" alt="image-20220627202133564" style="zoom: 33%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_log.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br></pre></td></tr></table></figure></li>
<li><p>重写 <code>fputc()</code> 函数：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627201930878.png" alt="image-20220627201930878" style="zoom: 33%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">	HAL_UART_Transmit(&amp;hlpuart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//hlpuart1需要根据你的配置修改</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记录另一种写法，或许会更加规范（适用范围广）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)<span class="comment">//如果使用GCC编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)<span class="comment">//keil中适用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">	HAL_UART_Transmit(&amp;huart2, (<span class="type">uint8_t</span>*) &amp;ch, <span class="number">1</span>, <span class="number">0xffff</span>);</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//网上说现在还需要加上这个函数，但是我没使用过gcc编译所以没有验证过这部分代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//_write函數在syscalls.c中， 使用__weak定義， 所以可以直接在其他文件中定義_write函數</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">__attribute__((weak)) <span class="type">int</span> _write(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> DataIdx;</span><br><span class="line">	<span class="keyword">for</span> (DataIdx = <span class="number">0</span>; DataIdx &lt; len; DataIdx++)</span><br><span class="line">	&#123;</span><br><span class="line">		__io_putchar(*ptr++);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>添加测试代码：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627202102623.png" alt="image-20220627202102623" style="zoom: 33%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">user_main_info(<span class="string">&quot;init HAL&quot;</span>);</span><br><span class="line">user_main_info(<span class="string">&quot;Config System Clock&quot;</span>);</span><br><span class="line">user_main_info(<span class="string">&quot;GPIO init finished&quot;</span>);</span><br><span class="line">user_main_info(<span class="string">&quot;UART init finished&quot;</span>);</span><br><span class="line"> <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* Infinite loop */</span></span><br><span class="line"> <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">user_printf(<span class="string">&quot;___  ___        _                   &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;|  \\/  |       | |                  &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| .  . | _   _ | |      ___    __ _ &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| |\\/| || | | || |     / _ \\  / _` |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| |  | || |_| || |____| (_) || (_| |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;\\_|  |_/ \\__, |\\_____/ \\___/  \\__, |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;          __/ |                __/ |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;         |___/                |___/ &quot;</span>);</span><br><span class="line"></span><br><span class="line">user_main_info(<span class="string">&quot;Enter while(1)&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>测试结果：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627202356953.png" alt="image-20220627202356953" style="zoom:50%;"></p>
<h4 id="中断方式">中断方式</h4>
<p>使用CubeMX配置串口，打开相应串口中断</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220703175857659.png" alt="image-20220703175857659"><figcaption aria-hidden="true">image-20220703175857659</figcaption>
</figure>
<p>打开工程，修改 uart.c 实现串口重定向：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> import(__use_no_semihosting)</span></span><br><span class="line"><span class="comment">//标准库需要的支持函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE __stdout;</span><br><span class="line"><span class="comment">//定义_sys_exit()以避免使用半主机模式</span></span><br><span class="line"><span class="type">void</span> _sys_exit(<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)<span class="comment">//如果使用GCC编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)<span class="comment">//keil中适用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">	HAL_UART_Transmit(&amp;hlpuart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//hlpuart1需要根据你的配置修改</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure>
<p>打开 main.c，配置中断服务函数</p>
<h4 id="dma">DMA</h4>
<p><strong>DMA传输方式</strong></p>
<p><strong>方法1</strong>：DMA_Mode_Normal，正常模式，</p>
<p>当一次DMA数据传输完后，停止DMA传送 ，也就是只传输一次　</p>
<p><strong>方法2</strong>：DMA_Mode_Circular ，循环传输模式</p>
<p>当传输结束时，硬件自动会将传输数据量寄存器进行重装，进行下一轮的数据传输。也就是多次传输模式</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI1MDg4OTMwMw==&amp;mid=2247496701&amp;idx=3&amp;sn=f5876279a224d3f4fb3eca76c7027e00&amp;chksm=e9f9e6c5de8e6fd3609e133873cf85c922fd9243579cf11cf14a658b248484579659288a0518&amp;scene=21#wechat_redirect">DMA原理</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/92379957">Map回调函数</a></p>
<p>https://www.its203.com/article/qq_26575553/89374803#:~:text=%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8F1%E7%9A%84MCU%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%AFF2...F4%EF%BC%8C%E7%94%9A%E8%87%B3</p>
<h3 id="寸-tft-lcd显示">1.8寸 TFT LCD显示</h3>
<p>使用CubeMX配置引脚，其中 PA5 引脚连接VCC供电。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220627183433259.png" alt="image-20220627183433259"><figcaption aria-hidden="true">image-20220627183433259</figcaption>
</figure>
<p>生成代码，然后对代码进行修改：</p>
<ol type="1">
<li><p>解压LCD_Driver.zip到CubeMX生成的MDK-ARM文件加中：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627200134162.png" alt="image-20220627200134162" style="zoom:50%;"></p></li>
<li><p>打开工程，将解压的文件添加的你的工程中：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627200249439.png" alt="image-20220627200249439" style="zoom:50%;"></p></li>
<li><p>将头文件包含到main.c文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd_init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pic.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br></pre></td></tr></table></figure></li>
<li><p>打开lcd_init.h文件，修改其中的 “LCD端口定义” ，将端口定义与连线相匹配。</p></li>
<li><p>注释掉主函数中的 <code>MX_GPIO_Init();</code> 并将复制下述代码进行测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LCD_Init();<span class="comment">//LCD初始化</span></span><br><span class="line">LCD_Fill(<span class="number">0</span>,<span class="number">0</span>,LCD_W,LCD_H,WHITE);</span><br><span class="line">LCD_ShowString(<span class="number">24</span>,<span class="number">30</span>,<span class="string">&quot;Hello,World!&quot;</span>,RED,WHITE,<span class="number">16</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/06/24/15-48-41/image-20220627200731016.png" alt="image-20220627200731016"><figcaption aria-hidden="true">image-20220627200731016</figcaption>
</figure></li>
</ol>
<h3 id="定时器">定时器</h3>
<p>使用STM32的定时器首先要理解STM32的时钟树，STM32中的时钟源是可配置的。有三种时钟源供选择：</p>
<p><img src="/2022/06/24/15-48-41/image-20220628140231418.png" alt="image-20220628140231418" style="zoom: 25%;"></p>
<p>由一个三路选择器组成的系统时钟选择器，可以选择下面三种时钟源的一种作为系统时钟源：</p>
<ul>
<li>高速外部时钟HSE
<ul>
<li>优点：外部时钟产生的时钟频率较为精确</li>
</ul></li>
<li>高速内部时钟HSI
<ul>
<li>优点：功耗低，不需要额外的器件，起震快</li>
<li>缺点：但是精度不能保证</li>
</ul></li>
<li>锁相环时钟PLLCLK
<ul>
<li>锁相环可以用来倍频，开发板上外接8M晶振，但是STM32主频却能跑72M，这离不开锁相环（PLL）的作用。</li>
</ul></li>
</ul>
<p>定时器要实现计数必须有个时钟源，<strong>基本定时器时钟只能来自内部时钟，高级控制定时器和通用定时器还可以选择外部时钟源或者直接来自其他定时器等待模式</strong>。</p>
<blockquote>
<p>F407有三种时钟源可以用作系统时钟：内部高速时钟、外部高速时钟、PLL时钟。 一般我们希望芯片工作在最高频率168MHz，而无论是内部还是外部时钟都是达不到的，所以通常都是用PLL时钟作为系统时钟。 外部时钟通常都比内部时钟要稳定精确，所以一般还会用外部时钟作为PLL的输入。 F407还有一个低速时钟用来驱动RTC，以及满足低电压模式下的功能需求。</p>
<p>通常系统总线AHB的频率设置为168MHz，高速外设总线APB2频率设置为84MHz，低速外设总线APB1频率设置为42MHz。 这些总线频率可以通过配置RCC_CFGR和RCC_PLLCFGR实现。</p>
</blockquote>
<h3 id="gps模块">GPS模块</h3>
<p>GPS模块硬件可以将卫星传来的信号进行收集，然后我们可以通过串口通信的方式从GPS模块中读取卫星报文。读取后的报文我们可以将其缓存下来，然后进行译码。</p>
<p>了解了 NMEA 格式有之后，我们就可以编写相应的解码程序了，而程序员 Tim(<a href="mailto:xtimor@gmail.com">xtimor@gmail.com</a>)提供了一个非常完善的 NMEA 解码库，在以下网址可以下载到：http://nmea.sourceforge.net/ ，直接使用该解码库，可以避免重复发明轮子的工作。</p>
<h3 id="移植-multibutton">移植 <a target="_blank" rel="noopener" href="https://github.com/0x1abin/MultiButton">MultiButton</a></h3>
<h4 id="multibutton简介">MultiButton简介</h4>
<p>Github里面的嵌入式开源项目，一个小巧简单易用的事件驱动型按键驱动模块，可无限量扩展按键，能够实现下述按键事件：</p>
<table>
<thead>
<tr class="header">
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PRESS_DOWN</td>
<td>按键按下，每次按下都触发</td>
</tr>
<tr class="even">
<td>PRESS_UP</td>
<td>按键弹起，每次松开都触发</td>
</tr>
<tr class="odd">
<td>PRESS_REPEAT</td>
<td>重复按下触发，变量repeat计数连击次数</td>
</tr>
<tr class="even">
<td>SINGLE_CLICK</td>
<td>单击按键事件</td>
</tr>
<tr class="odd">
<td>DOUBLE_CLICK</td>
<td>双击按键事件</td>
</tr>
<tr class="even">
<td>LONG_PRESS_START</td>
<td>达到长按时间阈值时触发一次</td>
</tr>
<tr class="odd">
<td>LONG_PRESS_HOLD</td>
<td>长按期间一直触发</td>
</tr>
</tbody>
</table>
<h4 id="在stm32g431-nucleo-64开发板中使用">在STM32G431-Nucleo-64开发板中使用</h4>
<p>首先使用CubeMX建立一个工程，初始化串口、测试LED和测试按键的GPIO口：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702160405595.png" alt="image-20220702160405595" style="zoom:67%;"></p>
<p>生成代码，打开工程文件夹：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702160514425.png" alt="image-20220702160514425" style="zoom:50%;"></p>
<p>然后在<a target="_blank" rel="noopener" href="https://github.com/0x1abin/MultiButton">此处</a>下载项目文件到本地：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702160023733.png" alt="image-20220702160023733" style="zoom:50%;"></p>
<p>将红框内的源文件放入到工程文件夹的MDK-ARM文件夹中，这里我给源文件了一个单独的文件夹</p>
<p><img src="/2022/06/24/15-48-41/image-20220702160647623.png" alt="image-20220702160647623" style="zoom:50%;"></p>
<p>同时我也移植了我们之前使用的 “user_log.h” 文件。</p>
<p>打开工程，从工程外部添加文件：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702161216790.png" alt="image-20220702161216790" style="zoom: 50%;"></p>
<p><img src="/2022/06/24/15-48-41/image-20220702161310298.png" alt="image-20220702161310298" style="zoom:50%;"></p>
<p>源文件中的头文件，可以添加进来，也可以不添加，只要添加头文件的查找地址，然后在写代码时包含头文件即可：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220702161547708.png" alt="image-20220702161547708"><figcaption aria-hidden="true">image-20220702161547708</figcaption>
</figure>
<h4 id="编写测试代码">编写测试代码</h4>
<ol type="1">
<li><p>打开 uart.c 文件，添加串口重定向代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)<span class="comment">//如果使用GCC编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)<span class="comment">//keil中适用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">	HAL_UART_Transmit(&amp;hlpuart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//hlpuart1需要根据你的配置修改</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure></li>
<li><p>打开 main.c 文件</p>
<ol type="1">
<li><p>添加新的包含</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multi_button.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br></pre></td></tr></table></figure></li>
<li><p>添加新的变量声明——按键结构体声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private variables ---------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Button</span> <span class="title">button1</span>;</span></span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br></pre></td></tr></table></figure></li>
<li><p>回调函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private user code ---------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">read_button1_GPIO</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">button_callback</span><span class="params">(<span class="type">void</span> *button)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> btn_event_val; </span><br><span class="line">    btn_event_val = get_button_event((<span class="keyword">struct</span> Button *)button); </span><br><span class="line">    <span class="keyword">switch</span>(btn_event_val)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">case</span> PRESS_DOWN:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;---&gt; key1 press down! &lt;---\r\n&quot;</span>); </span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> PRESS_UP: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;***&gt; key1 press up! &lt;***\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> PRESS_REPEAT: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;---&gt; key1 press repeat! &lt;---\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> SINGLE_CLICK: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;---&gt; key1 single click! &lt;---\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> DOUBLE_CLICK: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;***&gt; key1 double click! &lt;***\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> LONG_PRESS_START: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;---&gt; key1 long press start! &lt;---\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> LONG_PRESS_HOLD: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;***&gt; key1 long press hold! &lt;***\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进入 <code>main()</code> 函数，<code>while(1)</code> 之前：初始化对象 -&gt; 注册函数 -&gt; 启动函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  MX_LPUART1_UART_Init();</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">	HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MultiButton Test...\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化按键对象</span></span><br><span class="line">	button_init(&amp;button1, read_button1_GPIO, <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册函数</span></span><br><span class="line">	button_attach(&amp;button1, PRESS_DOWN,       button_callback);</span><br><span class="line">	button_attach(&amp;button1, PRESS_UP,         button_callback);</span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, PRESS_REPEAT,     button_callback);</span></span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, SINGLE_CLICK,     button_callback);</span></span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, DOUBLE_CLICK,     button_callback);</span></span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, LONG_PRESS_START, button_callback);</span></span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, LONG_PRESS_HOLD,  button_callback);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//启动按键</span></span><br><span class="line">	button_start(&amp;button1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END 2 */</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置一个5ms间隔的定时器循环调用后台处理函数，可以在while(1)中使用滴答定时器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每隔5ms调用一次后台处理函数</span></span><br><span class="line">button_ticks();</span><br><span class="line">HAL_Delay(<span class="number">5</span>);</span><br><span class="line">  <span class="comment">/* USER CODE END WHILE */</span></span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>勾选使用 MicroLIB</p>
<p><img src="/2022/06/24/15-48-41/image-20220702162518916.png" alt="image-20220702162518916" style="zoom: 33%;"></p></li>
<li><p>编译，烧录，打开串口助手，测试：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702162754097.png" alt="image-20220702162754097" style="zoom: 33%;"></p></li>
</ol>
<h3 id="移植-guilite">移植 <a target="_blank" rel="noopener" href="https://gitee.com/idea4good/GuiLite">GuiLite</a></h3>
<h4 id="简介">简介</h4>
<p>GuiLite是一个轻量的，可以运行在MPU平台的开源图形库。</p>
<p>只要能点亮你的显示屏上一个像素点，就可以使用这个图形库绘制出复杂的图形。</p>
<p>GuiLite还支持多个平台：</p>
<ul>
<li><p>支持的操作系统：iOS/macOS/WatchOS，Android，Linux（ARM/x86-64），Windows（包含VR），RTOS... 甚至<strong>无操作系统的单片机</strong></p></li>
<li><p>支持的开发语言： C/C++, Swift, Java, Javascript, C#, Golang...</p></li>
<li><p>支持的第3方库：Qt, MFC, Winforms, CoCoa...</p></li>
</ul>
<p>⚙️️最低硬件要求:</p>
<table>
<thead>
<tr class="header">
<th>Processor</th>
<th>Disk/ROM space</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>24 MHZ</td>
<td>29 KB</td>
<td>9 KB</td>
</tr>
</tbody>
</table>
<h4 id="在stm32g431-nucleo-64开发板中使用-1">在STM32G431-Nucleo-64开发板中使用</h4>
<p>在TFT屏示例的基础上进行GUI测试：</p>
<p>此处注意，可能会需要扩大默认的堆空间长度，具体操作如下：</p>
<ol type="1">
<li><p>CubeMX中修改堆的大小：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702213417565.png" alt="image-20220702213417565" style="zoom: 25%;"></p></li>
<li><p>打开stm32的启动代码（汇编代码）即可看到修改成功：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702213543120.png" alt="image-20220702213543120" style="zoom: 25%;"></p></li>
</ol>
<p>移植过程：</p>
<ol type="1">
<li><p>点击<a target="_blank" rel="noopener" href="https://gitee.com/idea4good/GuiLite">此处</a>下载源代码，在<a target="_blank" rel="noopener" href="https://gitee.com/idea4good/GuiLiteSamples">此处</a>下载Example；我们需要Example进行测试。</p></li>
<li><p>将Example中的实例代码放到自己的工程中，以Hello3DWave为例：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702214620179.png" alt="image-20220702214620179" style="zoom: 50%;"></p>
<p>将这两个文件复制到自己的工程中，可以新建一个名为UIcode的文件夹存放。</p></li>
<li><p>在自己的keil工程中的Target中新建一个Group：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702214000568.png" alt="image-20220702214000568" style="zoom:33%;"></p></li>
<li><p>将例程代码添加到Group中：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702214312012.png" alt="image-20220702214312012" style="zoom:50%;"></p></li>
<li><p>添加完成后即可编写代码，注意：检查自己的工程中是否勾选了Use MicroLIB，如果勾选了就要取消勾选，因为我们需要编译器去解析.cpp文件，不能使用C库</p>
<p><img src="/2022/06/24/15-48-41/image-20220702214859697.png" alt="image-20220702214859697" style="zoom:50%;"></p>
<h4 id="编写测试代码-1">编写测试代码</h4>
<ol type="1">
<li><p>在 main.c 中重新实现延时和绘制像素点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="comment">//延时1ms函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">int</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">	HAL_Delay(ms);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RGB888转RGB565</span></span><br><span class="line"><span class="comment">//Transfer GuiLite 32 bits color to your LCD color</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_RGB_32_to_16(rgb) (((((unsigned int)(rgb)) &amp; 0xFF) &gt;&gt; 3) | ((((unsigned int)(rgb)) &amp; 0xFC00) &gt;&gt; 5) | ((((unsigned int)(rgb)) &amp; 0xF80000) &gt;&gt; 8))</span></span><br><span class="line"><span class="comment">//Encapsulate your LCD driver:</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gfx_draw_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> rgb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//LCD_Fast_DrawPoint(x, y, GL_RGB_32_to_16(rgb));</span></span><br><span class="line">  <span class="comment">//添加带颜色的画点函数</span></span><br><span class="line">  LCD_DrawPoint(x, y, GL_RGB_32_to_16(rgb));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//UI entry</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DISPLAY_DRIVER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">void</span> (*draw_pixel)(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> rgb);</span><br><span class="line">	<span class="type">void</span> (*fill_rect)(<span class="type">int</span> x0, <span class="type">int</span> y0, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">unsigned</span> <span class="type">int</span> rgb);</span><br><span class="line">&#125; my_driver;</span><br><span class="line"></span><br><span class="line"><span class="comment">//extern function</span></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure></li>
<li><p>上面代码中的倒数第二行 <code>//extern function</code> 中的函数声明要去 UIcode.cpp 的最后去找</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220704151857006.png" alt="image-20220704151857006"><figcaption aria-hidden="true">image-20220704151857006</figcaption>
</figure></li>
<li><p>将此函数声明复制到 <code>//extern function</code> 处，然后在 <code>while(1)</code> 前添加如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_driver.draw_pixel = gfx_draw_pixel;</span><br><span class="line">my_driver.fill_rect = <span class="literal">NULL</span>;<span class="comment">//gfx_fill_rect;</span></span><br><span class="line"><span class="comment">//function like: startHelloStar(NULL,128,160,2,&amp;my_driver);</span></span><br></pre></td></tr></table></figure></li>
<li><p>编译然后烧录，不需要管警告信息。</p></li>
</ol></li>
</ol>
<h2 id="hal库小记">HAL库小记</h2>
<blockquote>
<p><strong>硬件抽象层</strong>（HAL，Hardware Abstraction Layer）驱动程序提供了一组功能丰富，易于与应用上层交互的 API，它们涵盖了常见的外围设备，可以非常方便的向其它型号 STM32 微控制器移植。同时还实现了用户回调函数机制，允许并发调用 <code>USART1</code> 以及 <code>USART2</code> 等外设，并且支持<strong>轮询</strong>、<strong>中断</strong>、<strong>DMA</strong> 三种 API 编程模式。</p>
<p><a target="_blank" rel="noopener" href="https://uinika.github.io/Embedded/STM32F401/?highlight=hal#arm-cortex-m4-%E6%A6%82%E8%A6%81">对于HAL库的介绍</a></p>
</blockquote>
<h4 id="gpio口">GPIO口</h4>
<h5 id="初始化及重置函数">初始化及重置函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化引脚 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_Init</span><span class="params">(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init)</span>; </span><br><span class="line"><span class="comment">//重置引脚 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_DeInit</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint32_t</span> GPIO_Pin)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="gpio-口操作相关函数">GPIO 口操作相关函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取电平状态 </span></span><br><span class="line">GPIO_PinState <span class="title function_">HAL_GPIO_ReadPin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>; </span><br><span class="line"><span class="comment">//设置引脚状态 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_WritePin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin, GPIO_PinState PinState)</span>; </span><br><span class="line"><span class="comment">//转换引脚状态 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_TogglePin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>; </span><br><span class="line"><span class="comment">//锁定引脚状态 </span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_GPIO_LockPin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>; </span><br></pre></td></tr></table></figure>
<h5 id="gpio口枚举常量">GPIO口枚举常量</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GPIO_PIN_RESET = <span class="number">0U</span>,</span><br><span class="line">  GPIO_PIN_SET</span><br><span class="line">&#125; GPIO_PinState;</span><br></pre></td></tr></table></figure>
<h5 id="gpio口名称">GPIO口名称</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IO口默认定义 -----------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_0                 ((uint16_t)0x0001)  <span class="comment">/* Pin 0 selected    */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private defines -----------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> User_Label_Pin GPIO_PIN_3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> User_Label_GPIO_Port GPIOA</span></span><br></pre></td></tr></table></figure>
<p>GPIO的API</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">函数名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>HAL_GPIO_ReadPin()</code></td>
<td style="text-align: left;">读取指定输入端口的引脚状态；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>HAL_GPIO_WritePin()</code></td>
<td style="text-align: left;">设置或者清除指定的数据端口位；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>HAL_GPIO_TogglePin()</code></td>
<td style="text-align: left;">切换指定的 GPIO 引脚状态；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>HAL_GPIO_LockPin()</code></td>
<td style="text-align: left;">锁定 GPIO 引脚配置寄存器；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>HAL_GPIO_EXTI_IRQHandler()</code></td>
<td style="text-align: left;">该函数用于处理 EXTI 中断请求；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>HAL_GPIO_EXTI_Callback()</code></td>
<td style="text-align: left;">EXTI 线检测回调函数；</td>
</tr>
</tbody>
</table>
<h4 id="串口通信-1">串口通信</h4>
<h5 id="收发函数">收发函数</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line"><span class="comment">//发送中断</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit_IT</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *</span></span><br><span class="line"><span class="params">pData, <span class="type">uint16_t</span> Size)</span>;</span><br><span class="line"><span class="comment">//接收中断</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive_IT</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData</span></span><br><span class="line"><span class="params">, <span class="type">uint16_t</span> Size)</span>;</span><br><span class="line"><span class="comment">//使用DMA发送</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit_DMA</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *</span></span><br><span class="line"><span class="params">pData, <span class="type">uint16_t</span> Size)</span>;</span><br><span class="line"><span class="comment">//使用DMA接收</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive_DMA</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *</span></span><br><span class="line"><span class="params">pData, <span class="type">uint16_t</span> Size)</span>;</span><br><span class="line"><span class="comment">//DMA暂停</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_DMAPause</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br><span class="line"><span class="comment">//DMA恢复</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_DMAResume</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br><span class="line"><span class="comment">//DMA停止</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_DMAStop</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="printf-重定向"><code>printf()</code> 重定向</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在 USER CODE BEGIN 0 区域内添加：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span>&#123;</span><br><span class="line">  <span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//huart1需要根据你的配置修改</span></span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="串口调试策略">串口调试策略</h4>
<h5 id="日志打印文件">日志打印文件</h5>
<p>keil编译器要求文件的结尾必须要有一个空行，如果没有将给出一个警告</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  **************************************************************************************</span></span><br><span class="line"><span class="comment">  *  @file           : user_log.h</span></span><br><span class="line"><span class="comment">  *  @brief          : Print your Log information</span></span><br><span class="line"><span class="comment">  **************************************************************************************</span></span><br><span class="line"><span class="comment">  *  @useage</span></span><br><span class="line"><span class="comment">  * Include this header file in the program file that you want to print logs.</span></span><br><span class="line"><span class="comment">	* Using the function: </span></span><br><span class="line"><span class="comment">	* `user_printf()`</span></span><br><span class="line"><span class="comment">	* `user_main_info()`</span></span><br><span class="line"><span class="comment">	* `user_main_debug()`</span></span><br><span class="line"><span class="comment">	* `user_main_error()`  to print the log.</span></span><br><span class="line"><span class="comment">  * Define &quot;PRINT_USER_LOG&quot; if you want to print logs and annotations it if you don&#x27;t.</span></span><br><span class="line"><span class="comment">  **************************************************************************************</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USER_LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USER_LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_USER_LOG	<span class="comment">//define for print log</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PRINT_USER_LOG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_printf(format, ...) printf( format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_info(format, ...) printf(<span class="string">&quot; [info] main.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_debug(format, ...) printf(<span class="string">&quot; [debug] main.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_error(format, ...) printf(<span class="string">&quot; [error] main.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>,##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_info(format, ...) printf(<span class="string">&quot; [info] file.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_debug(format, ...) printf(<span class="string">&quot; [debug] file.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_error(format, ...) printf(<span class="string">&quot; [error] file.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>,##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_printf(format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_info(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_debug(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_error(format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_info(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_debug(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_error(format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* PRINT_USER_LOG */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* __USER_LOG_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>添加文件时若出现报错，则需要手动增加头文件搜索路径：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220627212005510.png" alt="image-20220627212005510"><figcaption aria-hidden="true">image-20220627212005510</figcaption>
</figure>
<h5 id="日志打印个性化文字">日志打印个性化文字</h5>
<p><a target="_blank" rel="noopener" href="http://patorjk.com/software/taag/#p=display&amp;f=Graffiti&amp;t=Type%20Something%20">Text to ASCII Art Generator (TAAG)</a></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">___  ___        _                   </span><br><span class="line">|  \/  |       | |                  </span><br><span class="line">| .  . | _   _ | |      ___    __ _ </span><br><span class="line">| |\/| || | | || |     / _ \  / _` |</span><br><span class="line">| |  | || |_| || |____| (_) || (_| |</span><br><span class="line">\_|  |_/ \__, |\_____/ \___/  \__, |</span><br><span class="line">          __/ |                __/ |</span><br><span class="line">         |___/                |___/ </span><br></pre></td></tr></table></figure>
<p>代码：要在报错的符号前面加上一个反斜杠，因此代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user_printf(<span class="string">&quot;___  ___        _                   &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;|  \\/  |       | |                  &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| .  . | _   _ | |      ___    __ _ &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| |\\/| || | | || |     / _ \\  / _` |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| |  | || |_| || |____| (_) || (_| |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;\\_|  |_/ \\__, |\\_____/ \\___/  \\__, |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;          __/ |                __/ |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;         |___/                |___/ &quot;</span>);</span><br></pre></td></tr></table></figure>
<hr>
<p>分割线内内容摘自<a target="_blank" rel="noopener" href="https://uinika.github.io/Embedded/STM32F401/?highlight=hal#arm-cortex-m4-%E6%A6%82%E8%A6%81">Uinlo</a>的个人博客：</p>
<h3 id="hal-通用命名规则">HAL 通用命名规则</h3>
<p>对于共有的系统外设，无需使用指针或者实例对象，这个规则适用于 <strong>GPIO</strong>、<strong>SYSTICK</strong>、<strong>NVIC</strong>、<strong>RCC</strong>、<strong>FLASH</strong> 外设，例如函数 <code>HAL_GPIO_Init()</code> 只需要 GPIO 的地址及其配置参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *Init) &#123;</span><br><span class="line">  /* GPIO 初始化体 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个外设驱动程序当中都定义有处理中断和特定时钟配置的<strong>宏</strong>，这些宏会被导出到外设驱动的<strong>头文件</strong>，以便于<strong>扩展文件</strong>使用，这些用于处理中断和特定时钟配置的宏如下所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">宏定义</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_ENABLE_IT(__HANDLE__, __INTERRUPT__)</code></td>
<td style="text-align: left;"><strong>使能</strong>一个特定的外设中断；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_DISABLE_IT(__HANDLE__, __INTERRUPT__)</code></td>
<td style="text-align: left;"><strong>失能</strong>一个特定的外设中断；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_GET_IT (__HANDLE__, __ INTERRUPT __)</code></td>
<td style="text-align: left;"><strong>获取</strong>一个指定外设的中断状态；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_CLEAR_IT (__HANDLE__, __ INTERRUPT __)</code></td>
<td style="text-align: left;"><strong>清除</strong>一个指定外设的中断状态；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_GET_FLAG (__HANDLE__, __FLAG__)</code></td>
<td style="text-align: left;"><strong>获取</strong>一个指定外设的标志位状态；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_CLEAR_FLAG (__HANDLE__, __FLAG__)</code></td>
<td style="text-align: left;"><strong>清除</strong>一个指定外设的标志位状态；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_ENABLE(__HANDLE__)</code></td>
<td style="text-align: left;"><strong>使能</strong>一个外设；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_DISABLE(__HANDLE__)</code></td>
<td style="text-align: left;"><strong>失能</strong>一个外设；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_XXXX (__HANDLE__, __PARAM__)</code></td>
<td style="text-align: left;">指定 PPP 外设驱动的<strong>宏</strong>；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_GET_ IT_SOURCE (__HANDLE__, __INTERRUPT__)</code></td>
<td style="text-align: left;">检查指定的<strong>中断源</strong>；</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：<strong>NVIC</strong> 和 <strong>SYSTICK</strong> 是 ARM Cortex-M4 提供的两个核心功能，与之相关的 API 都位于 <code>stm32f4xx_hal_cortex.c</code> 源文件。</p>
</blockquote>
<p>当从寄存器读取<strong>状态标志位</strong>时，其结果由移位值组成，具体取决于读取值的数量与大小。这种情况下，返回的状态宽度为 <strong>32</strong> 位，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STATUS = XX | (YY &lt;&lt; 16)</span><br><span class="line">/* 或者 */</span><br><span class="line">STATUS = XX | (YY &lt;&lt; 8) | (YY &lt;&lt; 16) | (YY &lt;&lt; 24)</span><br></pre></td></tr></table></figure>
<p>外设 PPP 的指针在调用 <code>HAL_PPP_Init()</code> 之前有效，初始化函数会在修改指针字段之前进行检查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_PPP_Init(PPP_HandleTypeDef)</span><br><span class="line">if (hppp == NULL) &#123;</span><br><span class="line">  return HAL_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用<strong>条件式宏定义</strong>或者<strong>伪代码宏定义</strong>：</p>
<ul>
<li><p>条件式宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ABS(x) (((x) &gt; 0) ? (x) : -(x))</span><br></pre></td></tr></table></figure></li>
<li><p>伪代码宏定义（多指令宏）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD_, __DMA_HANDLE_) \</span><br><span class="line">  do &#123;                                                             \</span><br><span class="line">    (__HANDLE__)-&gt;__PPP_DMA_FIELD_ = &amp;(__DMA_HANDLE_);             \</span><br><span class="line">    (__DMA_HANDLE_).Parent = (__HANDLE__);                         \</span><br><span class="line">  &#125; while (0)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="中断处理程序与回调函数">中断处理程序与回调函数</h4>
<p>除了各种 API 函数之外，HAL 固件库外设驱动程序当中还包含有：</p>
<ul>
<li>用户回调函数；</li>
<li>由 <code>stm32f4xx_it.c</code> 调用的 <code>HAL_PPP_IRQHandler()</code> 外设中断处理程序；</li>
</ul>
<p>回调函数被定义为带有 <code>weak</code> 属性的空函数，使用时必须在用户代码当中进行定义，HAL 固件库当中存在三种类型的用户回调函数：</p>
<ul>
<li>外围系统级初始化与反向初始化回调函数 <code>HAL_PPP_MspInit()</code> 和 <code>HAL_PPP_MspDeInit</code>；</li>
<li>外理完成回调函数 <code>HAL_PPP_ProcessCpltCallback</code>；</li>
<li>错误的回调函数 <code>HAL_PPP_ErrorCallback</code>；</li>
</ul>
<table>
<colgroup>
<col style="width: 40%">
<col style="width: 59%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">回调函数</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>HAL_PPP_MspInit()</code> <code>HAL_PPP_MspDeInit()</code></td>
<td style="text-align: left;">例如 <code>HAL_USART_MspInit()</code>，由 API 函数 <code>HAL_PPP_Init()</code> 进行调用，用于进行外设的系统级初始化（GPIO、时钟、DMA、中断）；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>HAL_PPP_ProcessCpltCallback</code></td>
<td style="text-align: left;">例如 <code>HAL_USART_TxCpltCallback</code>，当处理执行完成时，由外设或者 DMA 中断处理程序进行调用；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>HAL_PPP_ErrorCallback</code></td>
<td style="text-align: left;">例如 <code>HAL_USART_ErrorCallback</code>，当发生错误时，由外设或者 DMA 中断处理程序进行调用；</td>
</tr>
</tbody>
</table>
<h4 id="hal-全局初始化">HAL 全局初始化</h4>
<p><code>stm32f4xx_hal.c</code> 提供了一组 API 来初始化 HAL 核心实现：</p>
<ul>
<li><code>HAL_Init()</code>：该函数必须在应用程序启动时调用，用于初始化数据和指令，缓存预获取队列，设置 SysTick 定时器（基于 HSI 时钟）每间隔 <code>1ms</code> 产生一个最低优先级中断，将优先级分组设置为 <code>4</code> 位，调用 <code>HAL_MspInit()</code> 用户回调函数来执行系统级初始化（时钟、GPIO、DMA、中断）；</li>
<li><code>HAL_DeInit()</code>：重置所有外设，调用用户回调函数 <code>HAL_MspDeInit()</code> 执行系统级反向初始化；</li>
<li><code>HAL_GetTick()</code>：获取当前 <strong>SysTick</strong> 定时器的计数值（在 SysTick 中断内递增），用于外设驱动程序处理<strong>超时</strong>；</li>
<li><code>HAL_Delay()</code>：通过 <strong>SysTick</strong> 定时器实现一个以毫秒为单位的延迟；</li>
</ul>
<h4 id="io-操作">IO 操作</h4>
<p>带有内部数据处理（发送、接收、读/写）的 HAL 函数，通常具备<code>轮询（Polling）</code>、<code>中断（Interrupt）</code>、<code>DMA</code> 三种处理方式：</p>
<hr>
<h2 id="底层探究">底层探究</h2>
<h3 id="新建工程">新建工程</h3>
<p>使用windows系统的PowerShell生成Blank template文件的目录树：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\qjy\Desktop\Blank template&gt; <span class="built_in">tree</span> /F</span><br><span class="line">卷 Windows-SSD 的文件夹 <span class="built_in">PATH</span> 列表</span><br><span class="line">卷序列号为 F01E-<span class="number">6275</span></span><br><span class="line"><span class="function">C:.</span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvoptx</span></span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvprojx</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">├─<span class="title">DebugConfig</span></span></span><br><span class="line"><span class="function">│      <span class="title">Target_1_STM32G431RBTx.dbgconf</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">├─<span class="title">Listings</span></span></span><br><span class="line"><span class="function">└─<span class="title">Objects</span></span></span><br></pre></td></tr></table></figure>
<p>添加 “startup_stm32g431xx.s” <del>和 “system_stm32g4xx.c” 两个文件</del>到 Blank template 文件夹目录下：</p>
<p>新建两个文件，编写系统初始化函数和主函数，如图。然后编译。</p>
<p><img src="/2022/06/24/15-48-41/image-20220628171400275.png" alt="image-20220628171400275" style="zoom:50%;"></p>
<p>编译成功，包含一个警告，内容为：<code>void SystemInit(void)</code> 函数没有函数原型，此处可以忽略该警告。</p>
<p>编译后的工程目录树如下：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\qjy\Desktop\Blank template&gt; <span class="built_in">tree</span> /F</span><br><span class="line">卷 Windows-SSD 的文件夹 <span class="built_in">PATH</span> 列表</span><br><span class="line">卷序列号为 F01E-<span class="number">6275</span></span><br><span class="line"><span class="function">C:.</span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvguix.qjy</span></span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvoptx</span></span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvprojx</span></span></span><br><span class="line"><span class="function">│  <span class="title">main.c</span></span></span><br><span class="line"><span class="function">│  <span class="title">startup_stm32g431xx.s</span></span></span><br><span class="line"><span class="function">│  <span class="title">system_stm32g4xx.c</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">├─<span class="title">DebugConfig</span></span></span><br><span class="line"><span class="function">│      <span class="title">Target_1_STM32G431RBTx.dbgconf</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">├─<span class="title">Listings</span></span></span><br><span class="line"><span class="function">│      <span class="title">Blank_Template.map</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">└─<span class="title">Objects</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template.axf</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template.build_log.htm</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template.htm</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template.lnp</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template_Target</span> 1.<span class="title">dep</span></span></span><br><span class="line"><span class="function">        <span class="title">main.d</span></span></span><br><span class="line"><span class="function">        <span class="title">main.o</span></span></span><br><span class="line"><span class="function">        <span class="title">startup_stm32g431xx.o</span></span></span><br><span class="line"><span class="function">        <span class="title">system_stm32g4xx.d</span></span></span><br><span class="line"><span class="function">        <span class="title">system_stm32g4xx.o</span></span></span><br></pre></td></tr></table></figure>
<p>其中keil中的project目录树为：</p>
<p><img src="/2022/06/24/15-48-41/image-20220628171454899.png" alt="image-20220628171454899" style="zoom: 50%;"></p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220628181017627.png" alt="image-20220628181017627"><figcaption aria-hidden="true">image-20220628181017627</figcaption>
</figure>
<figure>
<img src="/2022/06/24/15-48-41/image-20220628181229406.png" alt="image-20220628181229406"><figcaption aria-hidden="true">image-20220628181229406</figcaption>
</figure>
<p>我们知道系统的时钟是通过系统复位和时钟控制(RCC)寄存器配置的。 在第6.3节中列举了25个RCC寄存器的位定义和偏移地址。参考CubeMX中生成的stm32g431xx.h文件，定义如下的结构体用于访问RCC的每个寄存器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief Reset and Clock Control</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CR;          <span class="comment">/*!&lt; RCC clock control register,                                              Address offset: 0x00 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ICSCR;       <span class="comment">/*!&lt; RCC internal clock sources calibration register,                         Address offset: 0x04 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CFGR;        <span class="comment">/*!&lt; RCC clock configuration register,                                        Address offset: 0x08 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> PLLCFGR;     <span class="comment">/*!&lt; RCC system PLL configuration register,                                   Address offset: 0x0C */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED0;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x10 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED1;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x14 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CIER;        <span class="comment">/*!&lt; RCC clock interrupt enable register,                                     Address offset: 0x18 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CIFR;        <span class="comment">/*!&lt; RCC clock interrupt flag register,                                       Address offset: 0x1C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CICR;        <span class="comment">/*!&lt; RCC clock interrupt clear register,                                      Address offset: 0x20 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED2;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x24 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB1RSTR;    <span class="comment">/*!&lt; RCC AHB1 peripheral reset register,                                      Address offset: 0x28 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB2RSTR;    <span class="comment">/*!&lt; RCC AHB2 peripheral reset register,                                      Address offset: 0x2C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB3RSTR;    <span class="comment">/*!&lt; RCC AHB3 peripheral reset register,                                      Address offset: 0x30 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED3;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x34 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1RSTR1;   <span class="comment">/*!&lt; RCC APB1 peripheral reset register 1,                                    Address offset: 0x38 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1RSTR2;   <span class="comment">/*!&lt; RCC APB1 peripheral reset register 2,                                    Address offset: 0x3C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB2RSTR;    <span class="comment">/*!&lt; RCC APB2 peripheral reset register,                                      Address offset: 0x40 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED4;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x44 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB1ENR;     <span class="comment">/*!&lt; RCC AHB1 peripheral clocks enable register,                              Address offset: 0x48 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB2ENR;     <span class="comment">/*!&lt; RCC AHB2 peripheral clocks enable register,                              Address offset: 0x4C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB3ENR;     <span class="comment">/*!&lt; RCC AHB3 peripheral clocks enable register,                              Address offset: 0x50 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED5;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x54 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1ENR1;    <span class="comment">/*!&lt; RCC APB1 peripheral clocks enable register 1,                            Address offset: 0x58 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1ENR2;    <span class="comment">/*!&lt; RCC APB1 peripheral clocks enable register 2,                            Address offset: 0x5C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB2ENR;     <span class="comment">/*!&lt; RCC APB2 peripheral clocks enable register,                              Address offset: 0x60 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED6;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x64 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB1SMENR;   <span class="comment">/*!&lt; RCC AHB1 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x68 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB2SMENR;   <span class="comment">/*!&lt; RCC AHB2 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x6C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB3SMENR;   <span class="comment">/*!&lt; RCC AHB3 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x70 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED7;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x74 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1SMENR1;  <span class="comment">/*!&lt; RCC APB1 peripheral clocks enable in sleep mode and stop modes register 1, Address offset: 0x78 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1SMENR2;  <span class="comment">/*!&lt; RCC APB1 peripheral clocks enable in sleep mode and stop modes register 2, Address offset: 0x7C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB2SMENR;   <span class="comment">/*!&lt; RCC APB2 peripheral clocks enable in sleep mode and stop modes register, Address offset: 0x80 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED8;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x84 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CCIPR;       <span class="comment">/*!&lt; RCC peripherals independent clock configuration register,                Address offset: 0x88 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED9;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x8C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> BDCR;        <span class="comment">/*!&lt; RCC backup domain control register,                                      Address offset: 0x90 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CSR;         <span class="comment">/*!&lt; RCC clock control &amp; status register,                                     Address offset: 0x94 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CRRCR;       <span class="comment">/*!&lt; RCC clock recovery RC register,                                          Address offset: 0x98 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CCIPR2;      <span class="comment">/*!&lt; RCC peripherals independent clock configuration register 2,              Address offset: 0x9C */</span></span><br><span class="line">&#125; RCC_TypeDef;</span><br></pre></td></tr></table></figure>
<p>RCC基地址宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH_BASE           (0x40000000UL) <span class="comment">/*!&lt; Peripheral base address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_BASE              (AHB1PERIPH_BASE + 0x1000UL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC ((rcc_regs_t *)RCC_BASE)</span></span><br></pre></td></tr></table></figure>
<p>那么我们就可以通过如下的形式来访问RCC的寄存器了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RCC-&gt;CR</span><br><span class="line">RCC-&gt;CFGR</span><br></pre></td></tr></table></figure>
<h2 id="cubemx小记">CubeMX小记</h2>
<figure>
<img src="/2022/06/24/15-48-41/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM0NDQxMg==,size_16,color_FFFFFF,t_70-16566001142753.png" alt="SYS配置介绍"><figcaption aria-hidden="true">SYS配置介绍</figcaption>
</figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/439705800">引用</a>：调试接口配置。讲道理SWD应该是首选，如图5所示。如果不设置的话，编译下载后，你就会发现下载不了程序了，有复位键还好，没<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=复位键&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22439705800%22%7D">复位键</a>就有得愁了。</p>
</blockquote>
<p>选择Serial Wire是与下图中的SW相匹配</p>
<p><img src="/2022/06/24/15-48-41/image-20220630224454477.png" alt="image-20220630224454477" style="zoom: 50%;"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41344412/article/details/114153416">引用</a>：如果在STM32CubeMX中选择SW协议，MDK 也必须 选择SW协议。JTAG协议配置也同理。否则会造成下载和调试失败。在实际项目中SW协议使用使用的比较多，SW与JTAG相比，速度更快，占用的引脚更少，推荐大家配置成SW协议。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/06/06/21-00-26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/06/21-00-26/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-06 21:00:26" itemprop="dateCreated datePublished" datetime="2022-06-06T21:00:26+08:00">2022-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-01 18:10:44" itemprop="dateModified" datetime="2022-07-01T18:10:44+08:00">2022-07-01</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/06/06/21-00-26/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/06/06/21-00-26/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure>
<img src="/2022/06/06/21-00-26/image-20220606210048954-16545204512881.png" alt="image-20220606210048954"><figcaption aria-hidden="true">image-20220606210048954</figcaption>
</figure>
<figure>
<img src="/2022/06/06/21-00-26/image-20220701175231248.png" alt="image-20220701175231248"><figcaption aria-hidden="true">image-20220701175231248</figcaption>
</figure>
<figure>
<img src="/2022/06/06/21-00-26/image-20220701181041908.png" alt="image-20220701181041908"><figcaption aria-hidden="true">image-20220701181041908</figcaption>
</figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/04/30/16-02-06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/30/16-02-06/" class="post-title-link" itemprop="url">微机原理实验报告</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-30 16:02:06" itemprop="dateCreated datePublished" datetime="2022-04-30T16:02:06+08:00">2022-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-31 21:44:55" itemprop="dateModified" datetime="2022-07-31T21:44:55+08:00">2022-07-31</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/04/30/16-02-06/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/04/30/16-02-06/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="微机原理实验报告">微机原理实验报告</h1>
<h2 id="课程实验1">课程实验1</h2>
<h3 id="stm32仿真开发环境的构建与简单汇编程序的编写">——STM32仿真开发环境的构建与简单汇编程序的编写</h3>
<p>推荐阅读：https://blog.csdn.net/qq_46359697/article/details/115255840</p>
<h3 id="实验报告内容">实验报告内容</h3>
<ol type="1">
<li>实验目标与任务
<ol type="1">
<li>掌握MDK-ARM开发平台的使用，包括程序编写/调试/编译等。</li>
<li>掌握ARM的基本汇编指令，能够理解并编写简单的汇编程序实现某些功能。</li>
</ol></li>
<li>实验内容
<ol type="1">
<li>STM32F407启动代码实现与分析。</li>
<li>编写简单汇编程序：
<ol type="1">
<li>找到3个数字中最大的数字并将结果存储在R0中</li>
<li>将N，N-1，…… 2，1共N个数字相加，将结果存储在R1，当N = 0时，输出的结果为0.</li>
<li>调用子例程实现R3低4位中十六进制转换位对应的ASCII码，并将十六进制数和对应的结果存储在内存中，存储在从20000000开始的单元中</li>
</ol></li>
</ol></li>
<li>实验步骤</li>
</ol>
<h3 id="实验报告">实验报告</h3>
<h4 id="mdk-arm开发平台的使用">MDK-ARM开发平台的使用</h4>
<h5 id="安装软件">安装软件</h5>
<p>使用到的软件：</p>
<ul>
<li>MDK-ARM（微控制器开发工具）</li>
</ul>
<p>uVision是由keil公司开发的集成开发环境（IDE），可以进行代码编辑，文件管理，程序的编译调试等。</p>
<p>目前uVision的版本有uVision2、uVision3、uVision4、uVision5。</p>
<p>我们常说的keil4指的是uVision4，keil5指的是uVision5。</p>
<p>每一个uVision版本下都有4个独立的软件：C51、C251、C166、ARM。</p>
<p>uVision ARM就是MDK，或者可以称为MDK-ARM。这一款软件主要支持ARM7，ARM9，Cortex等ARM内核。</p>
<p>MDK-ARM中中包含PACK工具</p>
<p><img src="/2022/04/30/16-02-06/image-20220501135651588-16513846164571.png" alt="image-20220501135651588" style="zoom: 50%;"></p>
<p>PACK工具可以打开.pack文件，双击下载后文件夹中的 “Keil.STM32F4xx_DFP.2.14.0.pack” 文件，选择默认安装路径，即可完成导入。</p>
<h5 id="新建工程">新建工程</h5>
<p>打开 MDK-ARM，选择 Project -&gt; New uVision Project</p>
<p><img src="/2022/04/30/16-02-06/image-20220501140158387-16513849197395.png" alt="image-20220501140158387" style="zoom:50%;"></p>
<p>选择工程存储路径，并给工程起一个名字。</p>
<p><img src="/2022/04/30/16-02-06/image-20220501140436221-16513850782177.png" alt="image-20220501140436221" style="zoom:50%;"></p>
<p>在弹出的选项卡的搜索框中搜索 “STM32F407”，点击加号，选择具体型号 “STM32F407ZET”</p>
<p><img src="/2022/04/30/16-02-06/image-20220501140958609.png" alt="image-20220501140958609" style="zoom:50%;"></p>
<p>STM32 微控制器命名规则如下：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141117834-16513854807739.png" alt="image-20220501141115297" style="zoom: 33%;"></p>
<p>为了导入启动程序，在新弹出的选项卡中做如下操作：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141406536-165138564869011.png" alt="image-20220501141406536" style="zoom:50%;"></p>
<p>即可得到启动程序</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141447804-165138568967813.png" alt="image-20220501141447804" style="zoom:50%;"></p>
<h5 id="编译程序">编译程序</h5>
<p>直接编译程序，会报错，如下：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141621369-165138578336915.png" alt="image-20220501141621369" style="zoom:50%;"></p>
<p>错误为，没有找到 <code>main()</code> 函数</p>
<p>因此，需要创建一个.c文件来补充 <code>main()</code> 函数：</p>
<p>首先创建一个新文件</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141803519-165138588563917.png" alt="image-20220501141803519" style="zoom:33%;"></p>
<p>保存文件为.c文件</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142026434.png" alt="image-20220501142026434" style="zoom:33%;"></p>
<p>将.c文件加入到工程文件：在 Source Group 1 文件夹上右键，选择 Add Existing Fiels to Group 'Source Group 1' ...</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142117084-165138607853919.png" alt="image-20220501142117084" style="zoom:33%;"></p>
<p>选项卡中选择文件并添加，然后点击 close 关闭</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142207067.png" alt="image-20220501142207067" style="zoom:33%;"></p>
<p>编译成功：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142435430-165138627702721.png" alt="image-20220501142435430" style="zoom:67%;"></p>
<h5 id="程序debug">程序Debug</h5>
<p>在没有器件的情况下无法直接对程序进行Debug，因此需要使用模拟器来仿真，需要进行一定的配置</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142555008-165138635699523.png" alt="image-20220501142555008" style="zoom:50%;"></p>
<p>配置方式在课本P91页：</p>
<figure>
<img src="/2022/04/30/16-02-06/image-20220501142851518-165138653354225.png" alt="image-20220501142851518"><figcaption aria-hidden="true">image-20220501142851518</figcaption>
</figure>
<p>具体操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DARMSTM.DLL</span><br><span class="line">-pSTM32F407ZETx</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/30/16-02-06/image-20220501143156502.png" alt="image-20220501143156502" style="zoom:50%;"></p>
<p>再次点击Debug即可进入Debug模式：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501143314055-165138679821227.png" alt="image-20220501143314055" style="zoom:50%;"></p>
<h4 id="stm32f407启动代码分析">STM32F407启动代码分析</h4>
<h5 id="整体分析">整体分析：</h5>
<p>对于STM32F407启动代码整体的一个描述在 startup_stm32fxxx_xx.s 文件的顶部注释中有着解释，内容如下：</p>
<blockquote>
<p>;* Description: STM32F407xx devices vector table for MDK-ARM toolchain. ;* This module performs: ;* - Set the initial SP ;* - Set the initial PC == Reset_Handler ;* - Set the vector table entries with the exceptions ISR address ;* - Branches to __main in the C library (which eventually calls main()). ;* After Reset the CortexM4 processor is in Thread mode, priority is Privileged, and the Stack is set to Main.</p>
</blockquote>
<p>含义为：</p>
<ul>
<li>设置堆栈指针 <code>SP = _initial_sp</code></li>
<li>设置程序寄存器 <code>PC = Reset_Handler</code></li>
<li>使用例外ISR设置向量表项</li>
<li>配置系统时钟</li>
<li>配置外部 SRAM 用亍程序变量等数据存储(可选)</li>
<li>调用C库中的 <code>__main()</code> 函数，最终调用 <code>main()</code> 函数</li>
</ul>
<h5 id="源代码解释">源代码解释：</h5>
<ol type="1">
<li><p>开辟栈 <em>(STACK)</em> 空间，用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部SRAM的大小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。 <span class="math display">\[
\sf{通知编译器链接\rightarrow分配一片栈空间\rightarrow记录栈顶地址}
\]</span></p>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 89%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">指令</th>
<th style="text-align: left;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>EQU</code></td>
<td style="text-align: left;"><code>EQU</code>是一个伪指令，起作用是定义一个符号，这类似于C语言中的 <code>#define</code> ；<code>EQU</code>可以使用“*”来替代。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>AREA</code></td>
<td style="text-align: left;">用于定义一个新的段（代码段或数据段），并说明段的相关属性。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SPACE</code></td>
<td style="text-align: left;">用于分配一定数量的内存空间并初始化为0；<code>SPACE</code>跟在<code>AREA</code>后面，用于给新定义的段分配合适大小的内存；SPACE后要跟随数字，指明初始化内存空间的大小；可以使用“%”来替代。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ALIGN</code></td>
<td style="text-align: left;">编译器指令，对指令或数据存放地址进行对齐（一般跟一个立即数，缺省为4字节）</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stack_Size      EQU     0x00000400</span><br><span class="line">;定义一个符号，其中0x400为1KB；此处含义为设置栈空间大小为1KB</span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">;新定义一个段名为STACK的段，不进行初始化，属性为可读，2^3=8字节对齐</span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">;栈本体，这里指令是分配栈大小  </span><br><span class="line">__initial_sp</span><br><span class="line">;标号，表示该地址（这里是末尾，即栈顶地址）</span><br></pre></td></tr></table></figure></li>
<li><p>开辟堆（HEAP）空间，主要用于动态内存分配，也就是说用 <code>malloc()</code>, <code>calloc()</code>等函数分配的变量空间在堆上： <span class="math display">\[
\sf{通知编译器链接\rightarrow记录堆头地址\rightarrow分配一片堆空间\rightarrow记录堆尾地址}
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Heap_Size       EQU     0x00000200</span><br><span class="line"></span><br><span class="line">                AREA    HEAP, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem        SPACE   Heap_Size</span><br><span class="line">__heap_limit</span><br></pre></td></tr></table></figure></li>
<li><p>独立的过渡代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRESERVE8 ;指定当前文件的栈按 8B 对齐</span><br><span class="line">THUMB ;表示后面的指令兼容 Thumb 指令集（ARM以前的16位指令集）</span><br></pre></td></tr></table></figure>
<p>这里有一篇<a target="_blank" rel="noopener" href="http://www.cnblogs.com/reload/archive/2013/06/27/3159053.html">文章</a>，详细解释了为什么要设置 <code>PRESERVE8</code>。</p></li>
<li><p>向量表：内核在异常时会访问这个表地址，并根据异常类型查表，按表跳转到异常处理函数执行。</p>
<table>
<colgroup>
<col style="width: 11%">
<col style="width: 88%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">指令</th>
<th style="text-align: left;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>EXPORT</code></td>
<td style="text-align: left;">声明全局，可被外部文件使用，同义词 <code>GLOBAL</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>DCD</code></td>
<td style="text-align: left;">以字为单位分配内存，要求4字节对齐且初始化该内存<br><code>DCD</code> 的功能是申请（1个或多个）字地址，并赋初值。每行 <code>DCD</code> 都会生成一个4字节的二进制代码（中断服务代码入口地址）</td>
</tr>
</tbody>
</table>
<p>向量表的位置在代码段的最前面。具体物理地址由连接器的配置参数（IROM1 的地址决定, keil target 中可修改）。如果程序在 Flash 运行， 则中断向量表默认的起始地址是 <code>0x08000000</code>。</p>
<p><code>0x08000000</code> 是flash的首地址, 可以看到从 flash 的首地址开始，依次存储sp指针，Reset_Handler 中断地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">;新定义一个段名为RESRT的段，DATA说明本段用于定义数据段，属性为只读</span><br><span class="line"></span><br><span class="line">;下述语句将3个标号申明为可外部引用，主要提供给连接器用于链接库文件或其他文件。</span><br><span class="line"></span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">;定义一个标号 __Vectors 代表向量表的起始地址</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">;定义一个标号 __Vectors_End 代表向量表的结束地址</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line">;定义一个标号 __Vectors_Size 代表向量表的地址长度</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line"></span><br><span class="line">;!此处省略大量相似语法的代码。76-172行的代码被省略，省略代码为向量表的具体内容</span><br><span class="line">   </span><br><span class="line">                DCD     FPU_IRQHandler                    ; FPU</span><br><span class="line">                </span><br><span class="line">                                         </span><br><span class="line">__Vectors_End</span><br><span class="line"></span><br><span class="line">__Vectors_Size  EQU  __Vectors_End - __Vectors</span><br><span class="line">;向量表的地址长度 __Vectors_Size 可以由 __Vectors_End - __Vectors 得到</span><br></pre></td></tr></table></figure></li>
<li><p>各种中断处理程序 <code>xxx_Handler</code></p>
<table>
<colgroup>
<col style="width: 11%">
<col style="width: 88%">
</colgroup>
<thead>
<tr class="header">
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>PROC</code></td>
<td>定义子程序，与<code>ENDP</code>成对使用，表示子程序结束 同义词 <code>FUNCTION</code></td>
</tr>
<tr class="even">
<td><code>WEAK</code></td>
<td>编译器特性。弱定义，优先使用外部文件定义的标号。<br><code>WEAK</code> 声明其它的同名标号优先于该标号被引用，就是说如果外面声明了同样的标号，会优先调用在外部定义的</td>
</tr>
<tr class="odd">
<td><code>EXPORT</code></td>
<td>声明全局，可被外部文件使用，同义词 <code>GLOBAL</code></td>
</tr>
<tr class="even">
<td><code>IMPORT</code></td>
<td>声明标号来自外部文件，类似于C <code>extern</code></td>
</tr>
<tr class="odd">
<td><code>B</code></td>
<td>跳转到一个标号</td>
</tr>
</tbody>
</table>
<p>先指示编译器汇编一个新的代码段，名为 <code>|.text|</code>，只读</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AREA    |.text|, CODE, READONLY</span><br></pre></td></tr></table></figure>
<p>除复位中断外的其它的函数默认跳转到中断后，在原地死循环。</p>
<p>复位程序，也就是默认上电复位后执行的程序</p>
<blockquote>
<p>B：后面跟一个标签，标签直接对应一个地址，B的作用是跳转的标签指示的地址 BX：后面跟一个寄存器，寄存器里面保存地址，BX的作用是跳转到寄存器里面存放的地址 BL：后面跟一个标签，BL跳转到标签指示的地址，并且保存下一条指令地址到R14（即链接寄存器P33） BLX：后面跟一个寄存器，寄存器里面保存地址，并且保存下一条指令地址到R14（即链接寄存器P33）</p>
<p><code>B &#123;条件&#125; 目标地址</code> 条件可选，立即跳转执行。（不返回程序），<code>B .</code> 是死循环while(1);的用法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;Reset handler</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">;利用PROC、ENDP这一对伪指令把程序分为若干个过程，使程序结构更加清晰</span><br><span class="line">                 EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">;WEAK这个声明很重要，它可以让我们在 C 文件中的任意地方，放置中断服务程序，只要保证 C 函数的名字和向量表中的名字一致即可</span><br><span class="line">        IMPORT  SystemInit</span><br><span class="line">        IMPORT  __main</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br></pre></td></tr></table></figure>
<p>其他异常处理程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">; Dummy Exception Handlers (infinite loops which can be modified)</span><br><span class="line">;_____________________________________________________________</span><br><span class="line">NMI_Handler     PROC</span><br><span class="line">                EXPORT  NMI_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">                </span><br><span class="line">;!此处省略大量相似语法的代码。200-232行的代码被省略，省略代码为向量表的具体内容</span><br><span class="line"></span><br><span class="line">SysTick_Handler PROC</span><br><span class="line">                EXPORT  SysTick_Handler            [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">;B &#123;条件&#125; 目标地址 条件可选，立即跳转执行。（不返回程序），B . 是死循环while(1);的用法</span><br><span class="line">                ENDP</span><br><span class="line">                </span><br><span class="line">Default_Handler PROC</span><br><span class="line">;_____________________________________________________________</span><br><span class="line">                EXPORT  WWDG_IRQHandler                   [WEAK]                                        </span><br><span class="line">                EXPORT  PVD_IRQHandler                    [WEAK]                      </span><br><span class="line">;!此处省略大量相似语法的代码。242-319行的代码被省略，省略代码为向量表的具体内容</span><br><span class="line">                EXPORT  FPU_IRQHandler                    [WEAK]</span><br><span class="line">;_____________________________________________________________</span><br><span class="line">WWDG_IRQHandler                                                       </span><br><span class="line">PVD_IRQHandler                                      </span><br><span class="line"></span><br><span class="line">;!此处省略大量相似语法的代码。324-401行的代码被省略，省略代码为向量表的具体内容</span><br><span class="line"></span><br><span class="line">FPU_IRQHandler  </span><br><span class="line">;_____________________________________________________________</span><br><span class="line">                B       .</span><br><span class="line"></span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">                ALIGN</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>用户堆栈和堆初始化</p>
<ul>
<li>if
<ul>
<li>如果使用了微库（MicroLib），就直接导出堆栈地址符号</li>
</ul></li>
<li>else
<ul>
<li>导入外部程序<code>__use_two_region_memory</code>并马上执行调用</li>
<li>并导出子程序符号<code>__user_initial_stackheap</code>给外部程序调用</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">;**********************************************************************</span><br><span class="line">; User Stack and Heap initialization</span><br><span class="line">;**********************************************************************</span><br><span class="line">; 如果定义了 MICROLIB （微库，keil target 中设置），那么程序执行else后的语句</span><br><span class="line">                 IF      :DEF:__MICROLIB</span><br><span class="line">                </span><br><span class="line">                 EXPORT  __initial_sp</span><br><span class="line">                 EXPORT  __heap_base</span><br><span class="line">                 EXPORT  __heap_limit</span><br><span class="line">                </span><br><span class="line">                 ELSE</span><br><span class="line">                </span><br><span class="line">                 IMPORT  __use_two_region_memory</span><br><span class="line">                 EXPORT  __user_initial_stackheap</span><br><span class="line">                 </span><br><span class="line">__user_initial_stackheap</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =  Heap_Mem</span><br><span class="line">                 LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">                 LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">                 LDR     R3, = Stack_Mem</span><br><span class="line">                 BX      LR</span><br><span class="line"></span><br><span class="line">                 ALIGN</span><br><span class="line"></span><br><span class="line">                 ENDIF</span><br><span class="line"></span><br><span class="line">                 END</span><br><span class="line">;***************END OF FIEL***************</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="启动流程总结">启动流程总结</h5>
<ol type="1">
<li>分配堆栈</li>
<li>向量表</li>
<li>中断/异常处理函数
<ol type="1">
<li>复位程序（上电复位默认执行的函数）
<ol type="1">
<li>SystemInit()</li>
<li>__main()</li>
</ol></li>
<li>其他异常处理程序</li>
</ol></li>
<li>导出堆栈信息等给外部使用</li>
</ol>
<h5 id="stm32-总体启动顺序">STM32 总体启动顺序</h5>
<p><code>.s启动文件</code> -&gt; <code>中断处理函数外部定义</code> -&gt; <code>SystemInit()</code> -&gt; <code>SetSysClock</code> -&gt; <code>__main</code> -&gt; <code>main()</code></p>
<h5 id="全部代码展示">全部代码展示</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br></pre></td><td class="code"><pre><span class="line">;******************** (C) COPYRIGHT 2017 STMicroelectronics ********************</span><br><span class="line">;* File Name          : startup_stm32f407xx.s</span><br><span class="line">;* Author             : MCD Application Team</span><br><span class="line">;* Description        : STM32F407xx devices vector table for MDK-ARM toolchain. </span><br><span class="line">;*                      This module performs:</span><br><span class="line">;*                      - Set the initial SP</span><br><span class="line">;*                      - Set the initial PC == Reset_Handler</span><br><span class="line">;*                      - Set the vector table entries with the exceptions ISR address</span><br><span class="line">;*                      - Branches to __main in the C library (which eventually</span><br><span class="line">;*                        calls main()).</span><br><span class="line">;*                      After Reset the CortexM4 processor is in Thread mode,</span><br><span class="line">;*                      priority is Privileged, and the Stack is set to Main.</span><br><span class="line">;* &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt;   </span><br><span class="line">;*******************************************************************************</span><br><span class="line">; </span><br><span class="line">;* Redistribution and use in source and binary forms, with or without modification,</span><br><span class="line">;* are permitted provided that the following conditions are met:</span><br><span class="line">;*   1. Redistributions of source code must retain the above copyright notice,</span><br><span class="line">;*      this list of conditions and the following disclaimer.</span><br><span class="line">;*   2. Redistributions in binary form must reproduce the above copyright notice,</span><br><span class="line">;*      this list of conditions and the following disclaimer in the documentation</span><br><span class="line">;*      and/or other materials provided with the distribution.</span><br><span class="line">;*   3. Neither the name of STMicroelectronics nor the names of its contributors</span><br><span class="line">;*      may be used to endorse or promote products derived from this software</span><br><span class="line">;*      without specific prior written permission.</span><br><span class="line">;*</span><br><span class="line">;* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span><br><span class="line">;* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span><br><span class="line">;* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span><br><span class="line">;* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</span><br><span class="line">;* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span><br><span class="line">;* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span><br><span class="line">;* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span><br><span class="line">;* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span><br><span class="line">;* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span><br><span class="line">;* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><br><span class="line">; </span><br><span class="line">;*******************************************************************************</span><br><span class="line"></span><br><span class="line">; Amount of memory (in bytes) allocated for Stack</span><br><span class="line">; Tailor this value to your application needs</span><br><span class="line">; &lt;h&gt; Stack Configuration</span><br><span class="line">;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class="line">; &lt;/h&gt;·</span><br><span class="line"></span><br><span class="line">Stack_Size      EQU     0x00000400</span><br><span class="line"></span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; &lt;h&gt; Heap Configuration</span><br><span class="line">;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class="line">; &lt;/h&gt;</span><br><span class="line"></span><br><span class="line">Heap_Size       EQU     0x00000200</span><br><span class="line"></span><br><span class="line">                AREA    HEAP, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem        SPACE   Heap_Size</span><br><span class="line">__heap_limit</span><br><span class="line"></span><br><span class="line">                PRESERVE8</span><br><span class="line">                THUMB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br><span class="line"></span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler                   ; Window WatchDog                                        </span><br><span class="line">                DCD     PVD_IRQHandler                    ; PVD through EXTI Line detection                        </span><br><span class="line">                DCD     TAMP_STAMP_IRQHandler             ; Tamper and TimeStamps through the EXTI line            </span><br><span class="line">                DCD     RTC_WKUP_IRQHandler               ; RTC Wakeup through the EXTI line                       </span><br><span class="line">                DCD     FLASH_IRQHandler                  ; FLASH                                           </span><br><span class="line">                DCD     RCC_IRQHandler                    ; RCC                                             </span><br><span class="line">                DCD     EXTI0_IRQHandler                  ; EXTI Line0                                             </span><br><span class="line">                DCD     EXTI1_IRQHandler                  ; EXTI Line1                                             </span><br><span class="line">                DCD     EXTI2_IRQHandler                  ; EXTI Line2                                             </span><br><span class="line">                DCD     EXTI3_IRQHandler                  ; EXTI Line3                                             </span><br><span class="line">                DCD     EXTI4_IRQHandler                  ; EXTI Line4                                             </span><br><span class="line">                DCD     DMA1_Stream0_IRQHandler           ; DMA1 Stream 0                                   </span><br><span class="line">                DCD     DMA1_Stream1_IRQHandler           ; DMA1 Stream 1                                   </span><br><span class="line">                DCD     DMA1_Stream2_IRQHandler           ; DMA1 Stream 2                                   </span><br><span class="line">                DCD     DMA1_Stream3_IRQHandler           ; DMA1 Stream 3                                   </span><br><span class="line">                DCD     DMA1_Stream4_IRQHandler           ; DMA1 Stream 4                                   </span><br><span class="line">                DCD     DMA1_Stream5_IRQHandler           ; DMA1 Stream 5                                   </span><br><span class="line">                DCD     DMA1_Stream6_IRQHandler           ; DMA1 Stream 6                                   </span><br><span class="line">                DCD     ADC_IRQHandler                    ; ADC1, ADC2 and ADC3s                            </span><br><span class="line">                DCD     CAN1_TX_IRQHandler                ; CAN1 TX                                                </span><br><span class="line">                DCD     CAN1_RX0_IRQHandler               ; CAN1 RX0                                               </span><br><span class="line">                DCD     CAN1_RX1_IRQHandler               ; CAN1 RX1                                               </span><br><span class="line">                DCD     CAN1_SCE_IRQHandler               ; CAN1 SCE                                               </span><br><span class="line">                DCD     EXTI9_5_IRQHandler                ; External Line[9:5]s                                    </span><br><span class="line">                DCD     TIM1_BRK_TIM9_IRQHandler          ; TIM1 Break and TIM9                   </span><br><span class="line">                DCD     TIM1_UP_TIM10_IRQHandler          ; TIM1 Update and TIM10                 </span><br><span class="line">                DCD     TIM1_TRG_COM_TIM11_IRQHandler     ; TIM1 Trigger and Commutation and TIM11</span><br><span class="line">                DCD     TIM1_CC_IRQHandler                ; TIM1 Capture Compare                                   </span><br><span class="line">                DCD     TIM2_IRQHandler                   ; TIM2                                            </span><br><span class="line">                DCD     TIM3_IRQHandler                   ; TIM3                                            </span><br><span class="line">                DCD     TIM4_IRQHandler                   ; TIM4                                            </span><br><span class="line">                DCD     I2C1_EV_IRQHandler                ; I2C1 Event                                             </span><br><span class="line">                DCD     I2C1_ER_IRQHandler                ; I2C1 Error                                             </span><br><span class="line">                DCD     I2C2_EV_IRQHandler                ; I2C2 Event                                             </span><br><span class="line">                DCD     I2C2_ER_IRQHandler                ; I2C2 Error                                               </span><br><span class="line">                DCD     SPI1_IRQHandler                   ; SPI1                                            </span><br><span class="line">                DCD     SPI2_IRQHandler                   ; SPI2                                            </span><br><span class="line">                DCD     USART1_IRQHandler                 ; USART1                                          </span><br><span class="line">                DCD     USART2_IRQHandler                 ; USART2                                          </span><br><span class="line">                DCD     USART3_IRQHandler                 ; USART3                                          </span><br><span class="line">                DCD     EXTI15_10_IRQHandler              ; External Line[15:10]s                                  </span><br><span class="line">                DCD     RTC_Alarm_IRQHandler              ; RTC Alarm (A and B) through EXTI Line                  </span><br><span class="line">                DCD     OTG_FS_WKUP_IRQHandler            ; USB OTG FS Wakeup through EXTI line                        </span><br><span class="line">                DCD     TIM8_BRK_TIM12_IRQHandler         ; TIM8 Break and TIM12                  </span><br><span class="line">                DCD     TIM8_UP_TIM13_IRQHandler          ; TIM8 Update and TIM13                 </span><br><span class="line">                DCD     TIM8_TRG_COM_TIM14_IRQHandler     ; TIM8 Trigger and Commutation and TIM14</span><br><span class="line">                DCD     TIM8_CC_IRQHandler                ; TIM8 Capture Compare                                   </span><br><span class="line">                DCD     DMA1_Stream7_IRQHandler           ; DMA1 Stream7                                           </span><br><span class="line">                DCD     FMC_IRQHandler                    ; FMC                                             </span><br><span class="line">                DCD     SDIO_IRQHandler                   ; SDIO                                            </span><br><span class="line">                DCD     TIM5_IRQHandler                   ; TIM5                                            </span><br><span class="line">                DCD     SPI3_IRQHandler                   ; SPI3                                            </span><br><span class="line">                DCD     UART4_IRQHandler                  ; UART4                                           </span><br><span class="line">                DCD     UART5_IRQHandler                  ; UART5                                           </span><br><span class="line">                DCD     TIM6_DAC_IRQHandler               ; TIM6 and DAC1&amp;2 underrun errors                   </span><br><span class="line">                DCD     TIM7_IRQHandler                   ; TIM7                   </span><br><span class="line">                DCD     DMA2_Stream0_IRQHandler           ; DMA2 Stream 0                                   </span><br><span class="line">                DCD     DMA2_Stream1_IRQHandler           ; DMA2 Stream 1                                   </span><br><span class="line">                DCD     DMA2_Stream2_IRQHandler           ; DMA2 Stream 2                                   </span><br><span class="line">                DCD     DMA2_Stream3_IRQHandler           ; DMA2 Stream 3                                   </span><br><span class="line">                DCD     DMA2_Stream4_IRQHandler           ; DMA2 Stream 4                                   </span><br><span class="line">                DCD     ETH_IRQHandler                    ; Ethernet                                        </span><br><span class="line">                DCD     ETH_WKUP_IRQHandler               ; Ethernet Wakeup through EXTI line                      </span><br><span class="line">                DCD     CAN2_TX_IRQHandler                ; CAN2 TX                                                </span><br><span class="line">                DCD     CAN2_RX0_IRQHandler               ; CAN2 RX0                                               </span><br><span class="line">                DCD     CAN2_RX1_IRQHandler               ; CAN2 RX1                                               </span><br><span class="line">                DCD     CAN2_SCE_IRQHandler               ; CAN2 SCE                                               </span><br><span class="line">                DCD     OTG_FS_IRQHandler                 ; USB OTG FS                                      </span><br><span class="line">                DCD     DMA2_Stream5_IRQHandler           ; DMA2 Stream 5                                   </span><br><span class="line">                DCD     DMA2_Stream6_IRQHandler           ; DMA2 Stream 6                                   </span><br><span class="line">                DCD     DMA2_Stream7_IRQHandler           ; DMA2 Stream 7                                   </span><br><span class="line">                DCD     USART6_IRQHandler                 ; USART6                                           </span><br><span class="line">                DCD     I2C3_EV_IRQHandler                ; I2C3 event                                             </span><br><span class="line">                DCD     I2C3_ER_IRQHandler                ; I2C3 error                                             </span><br><span class="line">                DCD     OTG_HS_EP1_OUT_IRQHandler         ; USB OTG HS End Point 1 Out                      </span><br><span class="line">                DCD     OTG_HS_EP1_IN_IRQHandler          ; USB OTG HS End Point 1 In                       </span><br><span class="line">                DCD     OTG_HS_WKUP_IRQHandler            ; USB OTG HS Wakeup through EXTI                         </span><br><span class="line">                DCD     OTG_HS_IRQHandler                 ; USB OTG HS                                      </span><br><span class="line">                DCD     DCMI_IRQHandler                   ; DCMI  </span><br><span class="line">                DCD     0                                 ; Reserved				                              </span><br><span class="line">                DCD     HASH_RNG_IRQHandler               ; Hash and Rng</span><br><span class="line">                DCD     FPU_IRQHandler                    ; FPU</span><br><span class="line">                </span><br><span class="line">                                         </span><br><span class="line">__Vectors_End</span><br><span class="line"></span><br><span class="line">__Vectors_Size  EQU  __Vectors_End - __Vectors</span><br><span class="line"></span><br><span class="line">                AREA    |.text|, CODE, READONLY</span><br><span class="line"></span><br><span class="line">; Reset handler</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">        IMPORT  SystemInit</span><br><span class="line">        IMPORT  __main</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br><span class="line"></span><br><span class="line">; Dummy Exception Handlers (infinite loops which can be modified)</span><br><span class="line"></span><br><span class="line">NMI_Handler     PROC</span><br><span class="line">                EXPORT  NMI_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">HardFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  HardFault_Handler          [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">MemManage_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  MemManage_Handler          [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">BusFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  BusFault_Handler           [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">UsageFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  UsageFault_Handler         [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">SVC_Handler     PROC</span><br><span class="line">                EXPORT  SVC_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">DebugMon_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  DebugMon_Handler           [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">PendSV_Handler  PROC</span><br><span class="line">                EXPORT  PendSV_Handler             [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">SysTick_Handler PROC</span><br><span class="line">                EXPORT  SysTick_Handler            [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">Default_Handler PROC</span><br><span class="line"></span><br><span class="line">                EXPORT  WWDG_IRQHandler                   [WEAK]                                        </span><br><span class="line">                EXPORT  PVD_IRQHandler                    [WEAK]                      </span><br><span class="line">                EXPORT  TAMP_STAMP_IRQHandler             [WEAK]         </span><br><span class="line">                EXPORT  RTC_WKUP_IRQHandler               [WEAK]                     </span><br><span class="line">                EXPORT  FLASH_IRQHandler                  [WEAK]                                         </span><br><span class="line">                EXPORT  RCC_IRQHandler                    [WEAK]                                            </span><br><span class="line">                EXPORT  EXTI0_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  EXTI1_IRQHandler                  [WEAK]                                             </span><br><span class="line">                EXPORT  EXTI2_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  EXTI3_IRQHandler                  [WEAK]                                           </span><br><span class="line">                EXPORT  EXTI4_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  DMA1_Stream0_IRQHandler           [WEAK]                                </span><br><span class="line">                EXPORT  DMA1_Stream1_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream2_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream3_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream4_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream5_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream6_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  ADC_IRQHandler                    [WEAK]                         </span><br><span class="line">                EXPORT  CAN1_TX_IRQHandler                [WEAK]                                                </span><br><span class="line">                EXPORT  CAN1_RX0_IRQHandler               [WEAK]                                               </span><br><span class="line">                EXPORT  CAN1_RX1_IRQHandler               [WEAK]                                                </span><br><span class="line">                EXPORT  CAN1_SCE_IRQHandler               [WEAK]                                                </span><br><span class="line">                EXPORT  EXTI9_5_IRQHandler                [WEAK]                                    </span><br><span class="line">                EXPORT  TIM1_BRK_TIM9_IRQHandler          [WEAK]                  </span><br><span class="line">                EXPORT  TIM1_UP_TIM10_IRQHandler          [WEAK]                </span><br><span class="line">                EXPORT  TIM1_TRG_COM_TIM11_IRQHandler     [WEAK] </span><br><span class="line">                EXPORT  TIM1_CC_IRQHandler                [WEAK]                                   </span><br><span class="line">                EXPORT  TIM2_IRQHandler                   [WEAK]                                            </span><br><span class="line">                EXPORT  TIM3_IRQHandler                   [WEAK]                                            </span><br><span class="line">                EXPORT  TIM4_IRQHandler                   [WEAK]                                            </span><br><span class="line">                EXPORT  I2C1_EV_IRQHandler                [WEAK]                                             </span><br><span class="line">                EXPORT  I2C1_ER_IRQHandler                [WEAK]                                             </span><br><span class="line">                EXPORT  I2C2_EV_IRQHandler                [WEAK]                                            </span><br><span class="line">                EXPORT  I2C2_ER_IRQHandler                [WEAK]                                               </span><br><span class="line">                EXPORT  SPI1_IRQHandler                   [WEAK]                                           </span><br><span class="line">                EXPORT  SPI2_IRQHandler                   [WEAK]                                            </span><br><span class="line">                EXPORT  USART1_IRQHandler                 [WEAK]                                          </span><br><span class="line">                EXPORT  USART2_IRQHandler                 [WEAK]                                          </span><br><span class="line">                EXPORT  USART3_IRQHandler                 [WEAK]                                         </span><br><span class="line">                EXPORT  EXTI15_10_IRQHandler              [WEAK]                                  </span><br><span class="line">                EXPORT  RTC_Alarm_IRQHandler              [WEAK]                  </span><br><span class="line">                EXPORT  OTG_FS_WKUP_IRQHandler            [WEAK]                        </span><br><span class="line">                EXPORT  TIM8_BRK_TIM12_IRQHandler         [WEAK]                 </span><br><span class="line">                EXPORT  TIM8_UP_TIM13_IRQHandler          [WEAK]                 </span><br><span class="line">                EXPORT  TIM8_TRG_COM_TIM14_IRQHandler     [WEAK] </span><br><span class="line">                EXPORT  TIM8_CC_IRQHandler                [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream7_IRQHandler           [WEAK]                                          </span><br><span class="line">                EXPORT  FMC_IRQHandler                    [WEAK]                                             </span><br><span class="line">                EXPORT  SDIO_IRQHandler                   [WEAK]                                             </span><br><span class="line">                EXPORT  TIM5_IRQHandler                   [WEAK]                                             </span><br><span class="line">                EXPORT  SPI3_IRQHandler                   [WEAK]                                             </span><br><span class="line">                EXPORT  UART4_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  UART5_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  TIM6_DAC_IRQHandler               [WEAK]                   </span><br><span class="line">                EXPORT  TIM7_IRQHandler                   [WEAK]                    </span><br><span class="line">                EXPORT  DMA2_Stream0_IRQHandler           [WEAK]                                  </span><br><span class="line">                EXPORT  DMA2_Stream1_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA2_Stream2_IRQHandler           [WEAK]                                    </span><br><span class="line">                EXPORT  DMA2_Stream3_IRQHandler           [WEAK]                                    </span><br><span class="line">                EXPORT  DMA2_Stream4_IRQHandler           [WEAK]                                 </span><br><span class="line">                EXPORT  ETH_IRQHandler                    [WEAK]                                         </span><br><span class="line">                EXPORT  ETH_WKUP_IRQHandler               [WEAK]                     </span><br><span class="line">                EXPORT  CAN2_TX_IRQHandler                [WEAK]                                               </span><br><span class="line">                EXPORT  CAN2_RX0_IRQHandler               [WEAK]                                               </span><br><span class="line">                EXPORT  CAN2_RX1_IRQHandler               [WEAK]                                               </span><br><span class="line">                EXPORT  CAN2_SCE_IRQHandler               [WEAK]                                               </span><br><span class="line">                EXPORT  OTG_FS_IRQHandler                 [WEAK]                                       </span><br><span class="line">                EXPORT  DMA2_Stream5_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA2_Stream6_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA2_Stream7_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  USART6_IRQHandler                 [WEAK]                                           </span><br><span class="line">                EXPORT  I2C3_EV_IRQHandler                [WEAK]                                              </span><br><span class="line">                EXPORT  I2C3_ER_IRQHandler                [WEAK]                                              </span><br><span class="line">                EXPORT  OTG_HS_EP1_OUT_IRQHandler         [WEAK]                      </span><br><span class="line">                EXPORT  OTG_HS_EP1_IN_IRQHandler          [WEAK]                      </span><br><span class="line">                EXPORT  OTG_HS_WKUP_IRQHandler            [WEAK]                        </span><br><span class="line">                EXPORT  OTG_HS_IRQHandler                 [WEAK]                                      </span><br><span class="line">                EXPORT  DCMI_IRQHandler                   [WEAK]                                                                                 </span><br><span class="line">                EXPORT  HASH_RNG_IRQHandler               [WEAK]</span><br><span class="line">                EXPORT  FPU_IRQHandler                    [WEAK]</span><br><span class="line">                </span><br><span class="line">WWDG_IRQHandler                                                       </span><br><span class="line">PVD_IRQHandler                                      </span><br><span class="line">TAMP_STAMP_IRQHandler                  </span><br><span class="line">RTC_WKUP_IRQHandler                                </span><br><span class="line">FLASH_IRQHandler                                                       </span><br><span class="line">RCC_IRQHandler                                                            </span><br><span class="line">EXTI0_IRQHandler                                                          </span><br><span class="line">EXTI1_IRQHandler                                                           </span><br><span class="line">EXTI2_IRQHandler                                                          </span><br><span class="line">EXTI3_IRQHandler                                                         </span><br><span class="line">EXTI4_IRQHandler                                                          </span><br><span class="line">DMA1_Stream0_IRQHandler                                       </span><br><span class="line">DMA1_Stream1_IRQHandler                                          </span><br><span class="line">DMA1_Stream2_IRQHandler                                          </span><br><span class="line">DMA1_Stream3_IRQHandler                                          </span><br><span class="line">DMA1_Stream4_IRQHandler                                          </span><br><span class="line">DMA1_Stream5_IRQHandler                                          </span><br><span class="line">DMA1_Stream6_IRQHandler                                          </span><br><span class="line">ADC_IRQHandler                                         </span><br><span class="line">CAN1_TX_IRQHandler                                                            </span><br><span class="line">CAN1_RX0_IRQHandler                                                          </span><br><span class="line">CAN1_RX1_IRQHandler                                                           </span><br><span class="line">CAN1_SCE_IRQHandler                                                           </span><br><span class="line">EXTI9_5_IRQHandler                                                </span><br><span class="line">TIM1_BRK_TIM9_IRQHandler                        </span><br><span class="line">TIM1_UP_TIM10_IRQHandler                      </span><br><span class="line">TIM1_TRG_COM_TIM11_IRQHandler  </span><br><span class="line">TIM1_CC_IRQHandler                                               </span><br><span class="line">TIM2_IRQHandler                                                           </span><br><span class="line">TIM3_IRQHandler                                                           </span><br><span class="line">TIM4_IRQHandler                                                           </span><br><span class="line">I2C1_EV_IRQHandler                                                         </span><br><span class="line">I2C1_ER_IRQHandler                                                         </span><br><span class="line">I2C2_EV_IRQHandler                                                        </span><br><span class="line">I2C2_ER_IRQHandler                                                           </span><br><span class="line">SPI1_IRQHandler                                                          </span><br><span class="line">SPI2_IRQHandler                                                           </span><br><span class="line">USART1_IRQHandler                                                       </span><br><span class="line">USART2_IRQHandler                                                       </span><br><span class="line">USART3_IRQHandler                                                      </span><br><span class="line">EXTI15_10_IRQHandler                                            </span><br><span class="line">RTC_Alarm_IRQHandler                            </span><br><span class="line">OTG_FS_WKUP_IRQHandler                                </span><br><span class="line">TIM8_BRK_TIM12_IRQHandler                      </span><br><span class="line">TIM8_UP_TIM13_IRQHandler                       </span><br><span class="line">TIM8_TRG_COM_TIM14_IRQHandler  </span><br><span class="line">TIM8_CC_IRQHandler                                               </span><br><span class="line">DMA1_Stream7_IRQHandler                                                 </span><br><span class="line">FMC_IRQHandler                                                            </span><br><span class="line">SDIO_IRQHandler                                                            </span><br><span class="line">TIM5_IRQHandler                                                            </span><br><span class="line">SPI3_IRQHandler                                                            </span><br><span class="line">UART4_IRQHandler                                                          </span><br><span class="line">UART5_IRQHandler                                                          </span><br><span class="line">TIM6_DAC_IRQHandler                            </span><br><span class="line">TIM7_IRQHandler                              </span><br><span class="line">DMA2_Stream0_IRQHandler                                         </span><br><span class="line">DMA2_Stream1_IRQHandler                                          </span><br><span class="line">DMA2_Stream2_IRQHandler                                           </span><br><span class="line">DMA2_Stream3_IRQHandler                                           </span><br><span class="line">DMA2_Stream4_IRQHandler                                        </span><br><span class="line">ETH_IRQHandler                                                         </span><br><span class="line">ETH_WKUP_IRQHandler                                </span><br><span class="line">CAN2_TX_IRQHandler                                                           </span><br><span class="line">CAN2_RX0_IRQHandler                                                          </span><br><span class="line">CAN2_RX1_IRQHandler                                                          </span><br><span class="line">CAN2_SCE_IRQHandler                                                          </span><br><span class="line">OTG_FS_IRQHandler                                                    </span><br><span class="line">DMA2_Stream5_IRQHandler                                          </span><br><span class="line">DMA2_Stream6_IRQHandler                                          </span><br><span class="line">DMA2_Stream7_IRQHandler                                          </span><br><span class="line">USART6_IRQHandler                                                        </span><br><span class="line">I2C3_EV_IRQHandler                                                          </span><br><span class="line">I2C3_ER_IRQHandler                                                          </span><br><span class="line">OTG_HS_EP1_OUT_IRQHandler                           </span><br><span class="line">OTG_HS_EP1_IN_IRQHandler                            </span><br><span class="line">OTG_HS_WKUP_IRQHandler                                </span><br><span class="line">OTG_HS_IRQHandler                                                   </span><br><span class="line">DCMI_IRQHandler                                                                                                             </span><br><span class="line">HASH_RNG_IRQHandler</span><br><span class="line">FPU_IRQHandler  </span><br><span class="line">           </span><br><span class="line">                B       .</span><br><span class="line"></span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">                ALIGN</span><br><span class="line"></span><br><span class="line">;*******************************************************************************</span><br><span class="line">; User Stack and Heap initialization</span><br><span class="line">;*******************************************************************************</span><br><span class="line">                 IF      :DEF:__MICROLIB</span><br><span class="line">                </span><br><span class="line">                 EXPORT  __initial_sp</span><br><span class="line">                 EXPORT  __heap_base</span><br><span class="line">                 EXPORT  __heap_limit</span><br><span class="line">                </span><br><span class="line">                 ELSE</span><br><span class="line">                </span><br><span class="line">                 IMPORT  __use_two_region_memory</span><br><span class="line">                 EXPORT  __user_initial_stackheap</span><br><span class="line">                 </span><br><span class="line">__user_initial_stackheap</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =  Heap_Mem</span><br><span class="line">                 LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">                 LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">                 LDR     R3, = Stack_Mem</span><br><span class="line">                 BX      LR</span><br><span class="line"></span><br><span class="line">                 ALIGN</span><br><span class="line"></span><br><span class="line">                 ENDIF</span><br><span class="line"></span><br><span class="line">                 END</span><br><span class="line"></span><br><span class="line">;************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE*****</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="简单汇编程序实现">简单汇编程序实现</h3>
<h4 id="三数中寻找最大数">三数中寻找最大数</h4>
<h5 id="题目要求">题目要求：</h5>
<p>找到3个数字中最大的数字并将结果存储在R0中。</p>
<h5 id="代码展示">代码展示：</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">N1				EQU		456</span><br><span class="line">N2				EQU		1278</span><br><span class="line">N3				EQU		85</span><br><span class="line">Stack_Size		EQU		0x00000400</span><br><span class="line">				AREA	Mystack,	NOINIT,	READWRITE,	ALIGN=3</span><br><span class="line">Stack_Mem		SPACE	Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">				AREA	Reset,	DATA,	READONLY</span><br><span class="line">__Vectors		DCD		__initial_sp</span><br><span class="line">				DCD		Reset_Handler</span><br><span class="line">					</span><br><span class="line">				THUMB</span><br><span class="line">				PRESERVE8</span><br><span class="line">				AREA	Init,	CODE,	READONLY</span><br><span class="line">				ENTRY</span><br><span class="line">				</span><br><span class="line">Reset_Handler</span><br><span class="line">		LDR		R0,=N1</span><br><span class="line">		LDR		R1,=N2</span><br><span class="line">		LDR		R2,=N3</span><br><span class="line">		CMP		R0,R1</span><br><span class="line">		BHI		next</span><br><span class="line">		MOV		R0,R1</span><br><span class="line">next</span><br><span class="line">		CMP		R0,R2</span><br><span class="line">		BHI		deadloop</span><br><span class="line">		MOV		R0,R2</span><br><span class="line">deadloop</span><br><span class="line">		B	deadloop</span><br><span class="line">		NOP</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Rebuild started: Project: Project_1</span><br><span class="line">*** Using Compiler &#x27;V6.16&#x27;, folder: &#x27;D:\MDK\ARM\ARMCLANG\Bin&#x27;</span><br><span class="line">Rebuild target &#x27;Target 1&#x27;</span><br><span class="line">assembling startup_stm32f407xx.s...</span><br><span class="line">compiling system_stm32f4xx.c...</span><br><span class="line">linking...</span><br><span class="line">.\Objects\Project_1.axf: Error: L6320W: Ignoring --entry command. Cannot find argument &#x27;Reset_Handler&#x27;.</span><br><span class="line">.\Objects\Project_1.axf: Warning: L6320W: Ignoring --first command. Cannot find argument &#x27;__Vectors&#x27;.</span><br><span class="line">Not enough information to list image symbols.</span><br><span class="line">Not enough information to list load addresses in the image map.</span><br><span class="line">Finished: 2 information, 1 warning and 1 error messages.</span><br><span class="line">&quot;.\Objects\Project_1.axf&quot; - 1 Error(s), 1 Warning(s).</span><br><span class="line">Target not created.</span><br><span class="line">Build Time Elapsed:  00:00:00</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/30/16-02-06/image-20220506231919016-165185037825611.png" alt="image-20220506231919016" style="zoom:50%;"></p>
<p>课本代码会报错，因此修正代码课本代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">N1				EQU		456</span><br><span class="line">N2				EQU		1278</span><br><span class="line">N3				EQU		85</span><br><span class="line">Stack_Size		EQU		0x00000400</span><br><span class="line">				AREA	Mystack,	NOINIT,	READWRITE,	ALIGN=3</span><br><span class="line">Stack_Mem		SPACE	Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">				AREA	Reset,	DATA,	READONLY</span><br><span class="line">				EXPORT  __Vectors</span><br><span class="line">					</span><br><span class="line">__Vectors		DCD		__initial_sp</span><br><span class="line">				DCD		Reset_Handler</span><br><span class="line">					</span><br><span class="line">				THUMB</span><br><span class="line">				PRESERVE8</span><br><span class="line">				AREA	Init,	CODE,	READONLY</span><br><span class="line">				ENTRY</span><br><span class="line">				</span><br><span class="line">Reset_Handler</span><br><span class="line">		EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">		LDR		R0,=N1</span><br><span class="line">		LDR		R1,=N2</span><br><span class="line">		LDR		R2,=N3</span><br><span class="line">		CMP		R0,R1</span><br><span class="line">		BHI		next</span><br><span class="line">		MOV		R0,R1</span><br><span class="line">next</span><br><span class="line">		CMP		R0,R2</span><br><span class="line">		BHI		deadloop</span><br><span class="line">		MOV		R0,R2</span><br><span class="line">deadloop</span><br><span class="line">		B	deadloop</span><br><span class="line">		NOP</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/30/16-02-06/image-20220506231830620-16518503124549.png" alt="image-20220506231830620" style="zoom:50%;"></p>
<h5 id="结果展示">结果展示：</h5>
<p><img src="/2022/04/30/16-02-06/image-20220506232317154-165185059873513.png" alt="image-20220506232317154" style="zoom:50%;"></p>
<h4 id="n个数相加">N个数相加</h4>
<h5 id="题目要求-1">题目要求：</h5>
<p>将N，N-1，…… 2，1共N个数字相加，将结果存储在R1，当N = 0时，输出的结果为0。</p>
<h5 id="代码展示-1">代码展示：</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">N				EQU		10</span><br><span class="line">Stack_Size		EQU		0x00000400</span><br><span class="line">				AREA	Mystack,	NOINIT,	READWRITE,	ALIGN=3</span><br><span class="line">Stack_Mem		SPACE	Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">				AREA	Reset,	DATA,	READONLY</span><br><span class="line">				EXPORT  __Vectors</span><br><span class="line">				</span><br><span class="line">__Vectors		DCD		__initial_sp</span><br><span class="line">				DCD		Reset_Handler</span><br><span class="line">					</span><br><span class="line">				THUMB</span><br><span class="line">				PRESERVE8</span><br><span class="line">				AREA	Init,	CODE,	READONLY</span><br><span class="line">				ENTRY</span><br><span class="line">				</span><br><span class="line">Reset_Handler</span><br><span class="line">		</span><br><span class="line">		EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">		</span><br><span class="line">		LDR		R0,	=N</span><br><span class="line">		MOV		R1,	#0</span><br><span class="line">loop</span><br><span class="line">		ADD		r1, r0</span><br><span class="line">		SUBS	r0,	#1</span><br><span class="line">		BNE		loop</span><br><span class="line">deadloop</span><br><span class="line">		B	deadloop</span><br><span class="line">		NOP</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>
<h5 id="结果展示-1">结果展示：</h5>
<p><img src="/2022/04/30/16-02-06/image-20220506213516914-16518441195105.png" alt="image-20220506213516914" style="zoom:50%;"></p>
<h4 id="十六进制转asic码">十六进制转ASIC码</h4>
<h5 id="题目要求-2">题目要求：</h5>
<p>调用子例程实现R3低4位中十六进制转换位对应的ASCII码，并将十六进制数和对应的结果存储在内存中，存储在从20000000开始的单元中</p>
<h5 id="代码实现">代码实现：</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Stack_Size		EQU		0x00000400</span><br><span class="line">				AREA	Mystack,	NOINIT,	READWRITE,	ALIGN=3</span><br><span class="line">Stack_Mem		SPACE	Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">				AREA	Reset,	DATA,	READONLY</span><br><span class="line">				EXPORT  __Vectors</span><br><span class="line">__Vectors		DCD		__initial_sp</span><br><span class="line">				DCD		Reset_Handler</span><br><span class="line">					</span><br><span class="line">				THUMB</span><br><span class="line">				PRESERVE8</span><br><span class="line">				AREA	Init,	CODE,	READONLY</span><br><span class="line">				ENTRY</span><br><span class="line">				</span><br><span class="line">Reset_Handler</span><br><span class="line">		EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">		MOV 	R3,0x0A</span><br><span class="line">		CMP		R3,#9</span><br><span class="line">		BLE		Next</span><br><span class="line">		ADD		R3,R3,#7</span><br><span class="line">Next</span><br><span class="line">		ADD		R3,R3,#7</span><br><span class="line">deadloop</span><br><span class="line">		B	deadloop</span><br><span class="line">		NOP</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>
<h5 id="结果展示-2">结果展示：</h5>
<p><img src="/2022/04/30/16-02-06/image-20220506212809459.png" alt="image-20220506212809459" style="zoom:50%;"></p>
<p><img src="/2022/04/30/16-02-06/image-20220506213109858-16518438733371-16518438752213.png" alt="image-20220506213109858" style="zoom:50%;"></p>
<h2 id="课程实验2">课程实验2</h2>
<h3 id="使用stm32f401ve控制led">——使用STM32F401VE控制LED</h3>
<h3 id="实验报告内容-1">实验报告内容</h3>
<ol type="1">
<li><p>实验目标与任务</p>
<ol type="1">
<li>掌握STM32F40x的GPIO输入输出的使用。</li>
<li>主寄存器方法，库函数方法设置GPIO。</li>
<li>了解如何使用STM32CubeMX构建初始代码。</li>
</ol></li>
<li><p>实验内容</p>
<ol type="1">
<li><p>开关控制LED灯。当按下按钮时，对应的LED灯亮500ms，然后熄灭。</p>
<p><img src="/2022/04/30/16-02-06/image-20220507073550593-16518801528251.png" alt="image-20220507073550593" style="zoom:100%;"></p></li>
<li><p>要求:需要详细的步骤，包括proteus仿真电路和程序。</p></li>
</ol></li>
<li><p>实验步骤</p></li>
</ol>
<h3 id="实验报告-1">实验报告</h3>
<h4 id="软件使用">软件使用</h4>
<ul>
<li><p>STMCubeMX：</p>
<p>STMCubeMX是ST公司推出的一种自动创建单片机工程及初始化代码的工具</p></li>
<li><p>Proteus 8 Professional：</p>
<p>Proteus是一款EDA工具软件，它不仅具有其它EDA工具软件的仿真功能，还能较好的仿真单片机及外围器件。</p></li>
<li><p>MDK-ARM：</p>
<p>Keil公司开发的ARM开发工具MDK，是用来开发基于ARM核的系列微控制器的嵌入式应用程序</p></li>
</ul>
<h4 id="实验流程">实验流程</h4>
<p>使用 Proteus 搭建仿真电路 -&gt; 使用 CubeMX 生成初始化代码 -&gt; 使用 MDK-ARM 编写主函数，生成 .hex 文件 -&gt; 将 .hex 文件添加到仿真电路中</p>
<h4 id="工程建立">工程建立</h4>
<ol type="1">
<li><p>使用Proteus建立仿真文件：</p>
<ol type="1">
<li><p>打开Proteus，选择新建一个原理图文件</p>
<p><img src="/2022/04/30/16-02-06/image-20220509173625891.png" alt="image-20220509173625891" style="zoom:67%;"></p></li>
<li><p>使用快捷键“Ctrl+S”将文件保存到电脑中</p></li>
<li><p>添加元器件：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509174203888-16520893270293.png" alt="image-20220509174203888" style="zoom:67%;"></p></li>
<li><p>在工程中添加如下元器件：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509174431386-16520894731985.png" alt="image-20220509174431386" style="zoom:50%;"></p>
<p>添加电源端和地：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509174549453-16520895514167.png" alt="image-20220509174549453" style="zoom:50%;"></p>
<p>添加好后如下图所示：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509174748405-16520896698899.png" alt="image-20220509174748405" style="zoom:67%;"></p></li>
<li><p>按实验要求接线，如下图：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509174839001-165208972044111.png" alt="image-20220509174839001" style="zoom:67%;"></p></li>
<li><p>创建仿真文件完成</p></li>
</ol></li>
<li><p>使用STMCubeMX建立初始化代码：</p>
<ol type="1">
<li><p>建立工程：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509175001429.png" alt="image-20220509175001429" style="zoom:33%;"></p></li>
<li><p>初次使用等待联网下载器件库，下载完成后做如下操作：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509175144590-165208990612213.png" alt="image-20220509175144590" style="zoom:67%;"></p></li>
<li><p>进入如下界面，点击管理工程</p>
<p><img src="/2022/04/30/16-02-06/image-20220509175343646.png" alt="image-20220509175343646" style="zoom:67%;"></p></li>
<li><p>配置工程基本信息：</p>
<figure>
<img src="/2022/04/30/16-02-06/image-20220509175857840-165209034195317.png" alt="image-20220509175857840"><figcaption aria-hidden="true">image-20220509175857840</figcaption>
</figure></li>
<li><p>打开生成的文件夹，看到如下目录，进入MDK-ARM文件夹，打开其中的keil工程</p>
<p><img src="/2022/04/30/16-02-06/image-20220509180023158-165209042452819.png" alt="image-20220509180023158" style="zoom:50%;"></p>
<p><img src="/2022/04/30/16-02-06/image-20220509180057731-165209045950421.png" alt="image-20220509180057731" style="zoom:50%;"></p></li>
<li><p>打开工程中的main.c文件编写代码：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509180339476-165209062098523.png" alt="image-20220509180339476" style="zoom:50%;"></p></li>
</ol></li>
<li><p>使用MDK开发环境编写代码操控LED灯闪烁：</p>
<ol type="1">
<li><p>首先确认工程配置为输出.hex文件：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509180518790.png" alt="image-20220509180518790" style="zoom:33%;"></p></li>
<li><p>在main.c中添加如下代码：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509181336172-165209121805525.png" alt="image-20220509181336172" style="zoom:67%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_LED</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC-&gt;AHB1ENR |= <span class="number">1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">	</span><br><span class="line">	GPIOC-&gt;MODER |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">	GPIOC-&gt;OTYPER = <span class="number">0x0</span>;</span><br><span class="line">	GPIOC-&gt;OSPEEDR = <span class="number">0x0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line">	init_LED();</span><br><span class="line"><span class="comment">/* USER CODE END Init */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">		GPIOC-&gt;BSRR = (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">		HAL_Delay(<span class="number">500</span>);</span><br><span class="line">		GPIOC-&gt;BSRR = (<span class="number">1</span>&lt;&lt;<span class="number">16</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">17</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">18</span>);</span><br><span class="line">		HAL_Delay(<span class="number">500</span>);</span><br><span class="line"><span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编译程序：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509181515288-165209131696027.png" alt="image-20220509181515288" style="zoom:33%;"></p></li>
</ol></li>
<li><p>将 .hex 文件添加到仿真电路中</p>
<ol type="1">
<li><p>双击STM32F401VE，弹出编辑卡，点击程序文件：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509181755170-165209147690229.png" alt="image-20220509181755170" style="zoom:50%;"></p></li>
<li><p>在如下路径中找到.hex文件</p>
<p><img src="/2022/04/30/16-02-06/image-20220509182030753-165209163517931.png" alt="image-20220509182030753" style="zoom:50%;"></p></li>
<li><p>选中文件，即可将文件拷入到仿真器件中，然后运行仿真：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509182153882.png" alt="image-20220509182153882" style="zoom:33%;"></p></li>
<li><p>即可看到小灯闪烁。</p></li>
</ol></li>
</ol>
<h4 id="使用st库函数来编写代码">使用ST库函数来编写代码</h4>
<ol type="1">
<li><p>使用CubeMX生成代码：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509182403928.png" alt="image-20220509182403928" style="zoom:50%;"></p></li>
<li><p>返回keil，允许重加载代码：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509182454542.png" alt="image-20220509182454542" style="zoom:50%;"></p></li>
<li><p>新代码中增加了一个初始化函数</p>
<p><img src="/2022/04/30/16-02-06/image-20220509182524721.png" alt="image-20220509182524721" style="zoom:50%;"></p></li>
<li><p>使用库函数来实现与刚才相同的功能：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509182719004.png" alt="image-20220509182719004" style="zoom:50%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_SET);</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>重新编译并将代码拷入仿真软件，可以得到相同的效果。</p></li>
</ol>
<h4 id="实现题目要求">实现题目要求：</h4>
<ol type="1">
<li><p>结果展示：</p>
<p><img src="/2022/04/30/16-02-06/GIF 2022-5-9 18-35-34.gif" alt="GIF 2022-5-9 18-35-34" style="zoom:50%;"></p></li>
<li><p>代码展示（简化后的代码，包含注释）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">MX_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义按键变量并初始化为1</span></span><br><span class="line">	<span class="type">char</span> button_0 = GPIO_PIN_SET;</span><br><span class="line">	<span class="type">char</span> button_1 = GPIO_PIN_SET;</span><br><span class="line">	<span class="type">char</span> button_2 = GPIO_PIN_SET;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化HAL、系统时钟和需要的GPIO口</span></span><br><span class="line">    HAL_Init();</span><br><span class="line">    SystemClock_Config();</span><br><span class="line">    MX_GPIO_Init();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//循环读取GPIO口的值</span></span><br><span class="line">        button_0 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_13);</span><br><span class="line">		button_1 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_14);</span><br><span class="line">		button_2 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_15);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果GPIO口的值被拉到0</span></span><br><span class="line">        <span class="keyword">if</span>(button_0 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">//延迟10ms消抖</span></span><br><span class="line">			HAL_Delay(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//如果GPIO口仍为0</span></span><br><span class="line">			<span class="keyword">if</span>(button_0 == GPIO_PIN_RESET)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">//GPIOC_0口输出高电平，点亮LED灯</span></span><br><span class="line">				HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0, GPIO_PIN_SET);</span><br><span class="line">                <span class="comment">//延时500ms</span></span><br><span class="line">				HAL_Delay(<span class="number">500</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(button_1 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_Delay(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">if</span>(button_1 == GPIO_PIN_RESET)</span><br><span class="line">			&#123;</span><br><span class="line">				HAL_GPIO_WritePin(GPIOC, GPIO_PIN_1, GPIO_PIN_SET);</span><br><span class="line">				HAL_Delay(<span class="number">500</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(button_2 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_Delay(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">if</span>(button_2 == GPIO_PIN_RESET)</span><br><span class="line">			&#123;</span><br><span class="line">				HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_SET);</span><br><span class="line">				HAL_Delay(<span class="number">500</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将所有GPIO口输出置为低电平</span></span><br><span class="line">		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CbueMX生成的系统时钟配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  RCC_OscInitTypeDef RCC_OscInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  RCC_ClkInitTypeDef RCC_ClkInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Configure the main internal regulator output voltage</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  __HAL_RCC_PWR_CLK_ENABLE();</span><br><span class="line">  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initializes the RCC Oscillators according to the specified parameters</span></span><br><span class="line"><span class="comment">  * in the RCC_OscInitTypeDef structure.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;</span><br><span class="line">  RCC_OscInitStruct.HSIState = RCC_HSI_ON;</span><br><span class="line">  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;</span><br><span class="line">  <span class="keyword">if</span> (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initializes the CPU, AHB and APB buses clocks</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK</span><br><span class="line">                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;</span><br><span class="line">  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;</span><br><span class="line">  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;</span><br><span class="line">  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line">  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CubeMX生成的GPIO初始化代码</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">MX_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* GPIO Ports Clock Enable */</span></span><br><span class="line">  __HAL_RCC_GPIOC_CLK_ENABLE();</span><br><span class="line">  __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Configure GPIO pin Output Level */</span></span><br><span class="line">  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Configure GPIO pins : PC0 PC1 PC2 */</span></span><br><span class="line">  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2;</span><br><span class="line">  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">  GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">  HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Configure GPIO pins : PA13 PA14 PA15 */</span></span><br><span class="line">  GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;</span><br><span class="line">  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">  GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">  HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对main.h中的函数声明进行实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Error_Handler</span><span class="params">(<span class="type">void</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>因为按键触发后即点亮灯长达500ms，因此可以不进行按键消抖，已经经过验证，故主函数中可做如下修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> button_0 = GPIO_PIN_RESET;</span><br><span class="line">	<span class="type">char</span> button_1 = GPIO_PIN_RESET;</span><br><span class="line">	<span class="type">char</span> button_2 = GPIO_PIN_RESET;</span><br><span class="line">    </span><br><span class="line">    HAL_Init();</span><br><span class="line">    SystemClock_Config();</span><br><span class="line">    MX_GPIO_Init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     	button_0 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_13);</span><br><span class="line">		button_1 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_14);</span><br><span class="line">		button_2 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_15);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(button_0 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0, GPIO_PIN_SET);</span><br><span class="line">            HAL_Delay(<span class="number">500</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(button_1 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_1, GPIO_PIN_SET);</span><br><span class="line">            HAL_Delay(<span class="number">500</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(button_2 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_SET);</span><br><span class="line">            HAL_Delay(<span class="number">500</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>附完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Header */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file           : main.c</span></span><br><span class="line"><span class="comment">  * @brief          : Main program body</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @attention</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Copyright (c) 2022 STMicroelectronics.</span></span><br><span class="line"><span class="comment">  * All rights reserved.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * This software is licensed under terms that can be found in the LICENSE file</span></span><br><span class="line"><span class="comment">  * in the root directory of this software component.</span></span><br><span class="line"><span class="comment">  * If no LICENSE file comes with this software, it is provided AS-IS.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">/* USER CODE END Header */</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private typedef -----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PTD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END PTD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private define ------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PD */</span></span><br><span class="line"><span class="comment">/* USER CODE END PD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private macro -------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PM */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END PM */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables ---------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes -----------------------------------------------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">MX_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/* USER CODE BEGIN PFP */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END PFP */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private user code ---------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  The application entry point.</span></span><br><span class="line"><span class="comment">  * @retval int</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line">	<span class="type">char</span> button_0 = GPIO_PIN_SET;</span><br><span class="line">	<span class="type">char</span> button_1 = GPIO_PIN_SET;</span><br><span class="line">	<span class="type">char</span> button_2 = GPIO_PIN_SET;</span><br><span class="line">  <span class="comment">/* USER CODE END 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* MCU Configuration--------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></span><br><span class="line">  HAL_Init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END Init */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the system clock */</span></span><br><span class="line">  SystemClock_Config();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN SysInit */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END SysInit */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">		</span><br><span class="line">		button_0 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_13);</span><br><span class="line">		button_1 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_14);</span><br><span class="line">		button_2 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_15);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(button_0 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_Delay(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">if</span>(button_0 == GPIO_PIN_RESET)</span><br><span class="line">			&#123;</span><br><span class="line">				HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0, GPIO_PIN_SET);</span><br><span class="line">				HAL_Delay(<span class="number">500</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(button_1 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_Delay(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">if</span>(button_1 == GPIO_PIN_RESET)</span><br><span class="line">			&#123;</span><br><span class="line">				HAL_GPIO_WritePin(GPIOC, GPIO_PIN_1, GPIO_PIN_SET);</span><br><span class="line">				HAL_Delay(<span class="number">500</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(button_2 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_Delay(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">if</span>(button_2 == GPIO_PIN_RESET)</span><br><span class="line">			&#123;</span><br><span class="line">				HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_SET);</span><br><span class="line">				HAL_Delay(<span class="number">500</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">		</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief System Clock Configuration</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  RCC_OscInitTypeDef RCC_OscInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  RCC_ClkInitTypeDef RCC_ClkInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Configure the main internal regulator output voltage</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  __HAL_RCC_PWR_CLK_ENABLE();</span><br><span class="line">  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initializes the RCC Oscillators according to the specified parameters</span></span><br><span class="line"><span class="comment">  * in the RCC_OscInitTypeDef structure.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;</span><br><span class="line">  RCC_OscInitStruct.HSIState = RCC_HSI_ON;</span><br><span class="line">  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;</span><br><span class="line">  <span class="keyword">if</span> (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initializes the CPU, AHB and APB buses clocks</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK</span><br><span class="line">                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;</span><br><span class="line">  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;</span><br><span class="line">  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;</span><br><span class="line">  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line">  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief GPIO Initialization Function</span></span><br><span class="line"><span class="comment">  * @param None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">MX_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* GPIO Ports Clock Enable */</span></span><br><span class="line">  __HAL_RCC_GPIOC_CLK_ENABLE();</span><br><span class="line">  __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Configure GPIO pin Output Level */</span></span><br><span class="line">  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Configure GPIO pins : PC0 PC1 PC2 */</span></span><br><span class="line">  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2;</span><br><span class="line">  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">  GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">  HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Configure GPIO pins : PA13 PA14 PA15 */</span></span><br><span class="line">  GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;</span><br><span class="line">  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">  GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">  HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 4 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 4 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  This function is executed in case of error occurrence.</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Error_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Error_Handler_Debug */</span></span><br><span class="line">  <span class="comment">/* User can add his own implementation to report the HAL error return state */</span></span><br><span class="line">  __disable_irq();</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Error_Handler_Debug */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  USE_FULL_ASSERT</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Reports the name of the source file and the source line number</span></span><br><span class="line"><span class="comment">  *         where the assert_param error has occurred.</span></span><br><span class="line"><span class="comment">  * @param  file: pointer to the source file name</span></span><br><span class="line"><span class="comment">  * @param  line: assert_param error line source number</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">assert_failed</span><span class="params">(<span class="type">uint8_t</span> *file, <span class="type">uint32_t</span> line)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 6 */</span></span><br><span class="line">  <span class="comment">/* User can add his own implementation to report the file name and line number,</span></span><br><span class="line"><span class="comment">     ex: printf(&quot;Wrong parameters value: file %s on line %d\r\n&quot;, file, line) */</span></span><br><span class="line">  <span class="comment">/* USER CODE END 6 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USE_FULL_ASSERT */</span></span></span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/04/10/11-17-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/10/11-17-01/" class="post-title-link" itemprop="url">概率论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-04-10 11:17:01 / 修改时间：17:55:30" itemprop="dateCreated datePublished" datetime="2022-04-10T11:17:01+08:00">2022-04-10</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/04/10/11-17-01/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/04/10/11-17-01/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概率与统计">概率与统计</h1>
<h3 id="随机实验">随机实验</h3>
<p>满足条件：</p>
<ol type="1">
<li>可以被重复；</li>
<li>具有多种可能结果并均明确可知；</li>
<li>试验结果不可预先获知。</li>
</ol>
<p>随机实验可能出现的每一种结果称为<strong>样本点</strong>，每一个样本点都彼此不相容，因而它是构成试验结果的最基础原子，故而样本点也被称为<strong>基本事件</strong>。</p>
<p>所有样本点（也即所有的可能结果）的集合就被称为<strong>样本空间</strong></p>
<p>一次试验可能出现的结果称为<strong>随机事件</strong>，随机事件是一个集合，内部元素均为随机实验的样本点</p>
<p>为什么要引入样本空间：</p>
<p>引入样本空间是为了给予“随机”这一相对较为暧昧的机制一个严格的数学范围。在这以后，一切事件的概率才得以在其相对应的样本空间之下具备良好的定义。</p>
<p>这就像样本空间（Sample space）产生出了事件域，而我们讨论相应的事件概率，就只在其定义的样本空间下具有意义，而同一事件在不同样本空间下，其发生的概率可能截然不同</p>
<p>样本空间的引入实际上是在为概率的定义提供了一个严格的范围。</p>
<p>一个样本空间可以是有限的，可数无穷的和不可数无穷的</p>
<p>假如S是可数的，包括有限和可数无穷的，那么S为一个离散的样本空间</p>
<p>假如S是不可数的，即不可数无穷的，那么S为一个连续的样本空间</p>
<p>对于随机试验的结果，即随机事件，其描述可以由多个观测量组成，因此样本空间可以是有不同维度的，维度数即描述一个随机时间的测量量的数目</p>
<p>概率的定义：（概率的本质）</p>
<p>直觉：概率就是事件发生的可能性。</p>
<p>古典概型：</p>
<p>进行<span class="math inline">\(n\)</span>次随机实验，得到的某一结果的次数记作<span class="math inline">\(N_k(n)\)</span>，则得到该结果的相对次数为<span class="math inline">\(f_k(n)=\frac{N_k(n)}{n}\)</span></p>
<p>当<span class="math inline">\(n\)</span>的数值足够大时，<span class="math inline">\(f_k(n)\)</span>则收敛于一个稳定的数值，即<span class="math inline">\(lim_{n-&gt;\infty}f_k(n)=p_k\)</span>，<span class="math inline">\(p_k\)</span>称作概率</p>
<p>古典概型的前提：</p>
<ol type="1">
<li>在古典概型的样本空间中，样本点也即基本事件的个数是有限的（骰子只能掷出6个数字）</li>
<li>每个样本点也即每个基本事件发生的可能性是相等的（投出6和投出1或任意其它一种结果的可能性完全一致）</li>
</ol>
<p>古典概型是<strong>先验</strong>的，因为我们<strong>先验</strong>的认为，这个骰子掷出任意一个数字的可能性都是相同的。并且同样<strong>先验</strong>的确定，掷出任意一个数字的频率都会稳定于古典概型计算出的这个先验概率附近。</p>
<p>先验来自于我们的直觉，来自于实践中的观察</p>
<p><strong>后验</strong>认为，对于事件发生的先验假设，我们不应当存在任何的偏好——即基本事件等可能这种事，并不是理所当然的</p>
<p>后验中我们可以随意假设一个估计性质的开始概率，重要的是，我们可以通过后续的重复试验，来不断的更新纠正这一概率，而当通过试验获取的信息趋近于无穷时，我们最终就可以获得一个收敛于某个具体数值的<strong>后验</strong>概率。</p>
<p>让我们能够摆脱“可能性”的束缚，从而绕开先验与后验的争论，来在数学上精确的定义概率呢？</p>
<p>在有了样本空间将事件构造成的集合以后，再通过测度的方式，将它们映射至0到1取值范围内的实数域 <span class="math inline">\([0,1]\)</span>上。</p>
<p>若以这样的方式来定义概率，我们不就可以将它从事件发生可能性这样的束缚上解脱出来，从而获得一个纯粹的数学定义。为了实现这种测度的构造，就可以人为的对样本空间到实数域的映射规则进行规定，即：</p>
<ol type="1">
<li>概率必然是非负的，即 <span class="math inline">\(P(A)\ge 0\)</span></li>
<li>样本空间所代表的全集，概率规定为1，即 <span class="math inline">\(P(\Omega)=1\)</span></li>
<li>对于任意可列的互不相容事件（即两两交集均为 <span class="math inline">\(\varnothing\)</span> 的子集），它们并集的概率等于它们概率的和，即 <span class="math inline">\(P(A\cup B)=P(A)+P(B)\)</span></li>
</ol>
<p>满足这三个条件的映射，即有概率 <span class="math inline">\(P\)</span> ，这也被称为概率的公理化定义。</p>
<p>也由于这种定义的实质就是将样本空间对实数进行映射，故而这种映射也被称为<strong>概率测度</strong>。</p>
<p>条件概率公式所反映的，实际上是决策树的<strong>剪枝</strong>过程。而条件概率的本质，则是<strong>由于前提事件的发生所导致的待计算事件其样本点与样本空间的同时缩小（如同上文中文氏图所示的右侧聚焦过程）</strong>。</p>
<p><strong>全概率公式</strong>：</p>
<p>假设：样本空间 <span class="math inline">\(S\)</span> 有一个完备的事件组 <span class="math inline">\(A_1,A_2,A_3\)</span>：也就是样本空间被这三个事件瓜分完了</p>
<p>满足两个条件：三个事件：</p>
<ol type="1">
<li><span class="math inline">\(A_1 \cup A_2 \cup A_3=\Omega\)</span></li>
<li><span class="math inline">\(A_1 \cap A_2 \cap A_3=\varnothing\)</span></li>
</ol>
<p>则又有一事件 <span class="math inline">\(B\)</span> 时，<span class="math inline">\(P(B)=P(B \cap \Omega)=P[B\cup (A_1 \cup A_2 \cup A_3)]=P(BA_1 \cup BA_2 \cup BA_3)\)</span></p>
<p>因为 <span class="math inline">\(A_1 \cap A_2 \cap A_3=\varnothing\)</span>，所以 <span class="math inline">\(BA_1 \cup BA_2 \cup BA_3=\varnothing\)</span></p>
<p>所以：<span class="math inline">\(P(BA_1 \cup BA_2 \cup BA_3)=P(BA_1)+P(BA_2)+P(BA_3)\)</span></p>
<p>由条件概率公式可得：</p>
<p><span class="math inline">\(P(B)=P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)\)</span></p>
<p>即全概率公式事实上是一种<strong>对事件的先验分解</strong>。</p>
<p>全概率公式的使用条件，就是连续做多次实验，可以画出决策树，然后每一种分支可能性会发生变化，即前一次的选择会对下一次的选择产生影响；这是若求解第二轮即以后某个结果发生的可能性，则使用全概率公式</p>
<p>贝叶斯公式：</p>
<p>贝叶斯公式是后验的，即，我们已经做了实验，然后通过实验结果我们不断去修正导致这一结果发生的某些概率值</p>
<p>贝叶斯公式可以由全概率公式变形得来： <span class="math display">\[
\begin{aligned}
P(A_1|B)&amp;=\frac{P(A_1B)}{P(B)}\\
&amp;=\frac{P(A_1B)}{P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)}\\
&amp;=\frac{P(A_1)P(B|A_1)}{P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)}
\end{aligned}
\]</span></p>
<p>随机变量：随机变量的本质实际上就是<strong>随机事件的数字化</strong>。</p>
<p>现实世界中各色各样具象的随机事件，可以被映射成数学世界中抽象的数字，而这种映射规则就叫做随机变量。</p>
<p>离散随机变量的（概率分布律）概率质量函数（<span class="math inline">\(pmf\)</span>）：</p>
<p>离散性随机变量记作 <span class="math inline">\(X\)</span>，<span class="math inline">\(X\)</span> 的可能值是一个可数集合中的元素：<span class="math inline">\(S_X={x_1,x_2,x_3...}\)</span></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(X\)</span></th>
<th><span class="math inline">\(x=1\)</span></th>
<th><span class="math inline">\(x=0\)</span></th>
<th><span class="math inline">\(x=2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(pmf\)</span></td>
<td><span class="math inline">\(P(x=1)=0.125\)</span></td>
<td><span class="math inline">\(p(x=0)=0.25\)</span></td>
<td><span class="math inline">\(P(x=2)=0.625\)</span></td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(pmf\)</span> 的性质：</p>
<ul>
<li><p><span class="math display">\[
对于所有\;x\; 都有 \;P_X(x)\ge 0
\]</span></p></li>
<li><p><span class="math display">\[
\sum_{x\in S}P_X(x)=1
\]</span></p></li>
<li><p><span class="math display">\[
P(X\;in\;B)=\sum_{x\in B}P_X(x)\;其中B\subset S_X 
\]</span></p></li>
</ul>
<p>随机变量可以是离散的，连续的和混合的</p>
<p>累积分布函数（<span class="math inline">\(cdf\)</span>：cumulative distribution function），常被使用在随机变量的正式定义中，可以处理三种类型的随机变量</p>
<p>一个离散性随机变量的 <span class="math inline">\(pmf\)</span> 是由 <span class="math inline">\(\{X=b\}\)</span> 来定义的，累计分布函数（<span class="math inline">\(cdf\)</span>：cumulative distribution function）则是由 <span class="math inline">\(\{X\le b\}\)</span> 来定义的。</p>
<p>累计分布函数的优点在于它不局限于离散型随机变量，而是可以在所有类型的随机变量中使用</p>
<ol type="1">
<li><span class="math inline">\(F_X(x)\)</span>必然是一个单调不减函数——因概率不可为负，随着对应样本点的增多，概率的累加必然是单调不减的；</li>
<li><span class="math inline">\(F_X(x)\)</span> 必然是一个右连续函数；</li>
<li><span class="math inline">\(\lim_{n \to -\infty}F_X(x)=0\)</span>，<span class="math inline">\(\lim_{n \to \infty}F_X(x)=1\)</span> ——即对应样本点集合为空时，概率必然为0，而对应样本点集合为整个样本空间时，概率必然为1。</li>
</ol>
<p>可以看到，无论分布函数以何种形式构造，又呈现出何种性质，其最最核心的效用，就是为了能够良好的表示出样本空间的这一性质： <span class="math display">\[
P_1+P_2+P_3+...+P_n=\sum_iP_i=1
\]</span> 即实现样本空间 <span class="math inline">\(S\)</span> 对应的概率<strong>归向于1</strong>，从而完成样本空间向值域 <span class="math inline">\([0,1]\)</span> 的映射。因此，分布函数的本质实际上是<strong>随机变量的归一化</strong>。</p>
<p>而当随机变量由离散型扩展至连续型时，在把握到分布函数的本质是样本点概率的累加函数以后，便可以推测连续型随机变量的分布函数 <span class="math inline">\(F_X(x)\)</span> 必然会表现为一种积分形式。</p>
<p>但是与离散型概率分布中，每个随机变量对应着一个确定的概率值所不同，若以类似的方式来通过分布函数计算连续型随机变量中任意一点的概率，即用这一点的分布函数值减去这一点处左极限的分布函数值： <span class="math display">\[
P\{x=x_0\}=F_X(x_0)-\lim_{n \to x_0^-}F_X(x_0)
\]</span> 由于 <span class="math inline">\(F_X(x)\)</span> 是连续的概率累加，因此它在性质上也必然是一个非负不减的连续函数，故根据连续的性质，有： <span class="math display">\[
F_X(x_0)=\lim_{n \to x_0^+}F_X(x_0)= \lim_{n \to x_0^-}F_X(x_0)
\]</span> 故有： <span class="math display">\[
P\{x=x_0\}=0
\]</span> 由此可以看到，无论我们怎么计算，在连续型随机变量的分布函数上想要直接计算某一点处的概率，它将始终都会是0。</p>
<p>从这一结论，你应该就能明白，在概率论的开篇中，我们提到通过引入测度，将事件的概率测度与它在现实中发生的可能性这两个概念分开具有怎样重要的意义。</p>
<p>可以看到，在连续型随机变量中，某一点出的概率为0，并不意味着它在事件发生的角度来看是不可能的，而只是意味着这一点处的概率测度为0。</p>
<p>而之所以会出现概率测度为0的原因，是因为在这里一开始所着眼的计算目标就错了。打个比方来说就相当于，你并不会去计算一个点的长度，不会去计算一条线的面积，不会去计算一个面的体积。换句话说，在连续型随机变量中，计算某一点处的概率就相当于在求一条线的面积。</p>
<p>在认识到这一点之后，为了刻画连续型随机变量中某点处局部的概率性质就需要另外的工具，而这个工具在微积分的阶段就已经准备好早已被我们熟稔于胸——当然就是导数，即有： <span class="math display">\[
F^{&#39;}_X(x_0)=\lim_{x\to x_0}\frac{F_X(x)-F_X(x_0)}{x-x_0}
\]</span> 换句话说，对于连续型随机变量，我们用以刻画在一点处局部性质的量不是概率，而应该是<strong>概率测度的变化率。</strong></p>
<p>借用我们在散度与测度一章中的两个相类似的例子来说，就是：</p>
<ul>
<li>在位移运动中，刻画某一瞬时性质的不是位移而是速度；</li>
<li>在有质物体中，刻画某一质点性质的不是质量而是密度。</li>
</ul>
<p>也因此，以质量与密度的关系来考量概率与概率变化率，才会将连续型随机变量的分布函数，一个变上限积分：<span class="math inline">\(F(x)=\int^x_{-\infty}f(t)dt\)</span> 的导函数： <span class="math inline">\(F&#39;(x)=f(x)\)</span> 命名为<strong>概率密度</strong>。</p>
<p>更要值得一提的是，如果用离散型随机变量的概率分布即：</p>
<p>一个随机变量对应一个确定的概率测度 <span class="math inline">\(x_i\sim P_i\)</span></p>
<p>来进行类比的话，连续型随机变量的概率分布实际上应当为：</p>
<p>一个随机变量对应其<strong>附近领域</strong>的概率测度 <span class="math inline">\(x_i\sim f(x_i)dx_i\)</span></p>
<p>而非直接对应概率密度函数 <span class="math inline">\(f(x)\)</span>，从这个类比，可以更直观的认为，若视离散型随机变量的分布函数为一个楼层分明的阶梯，那么连续型随机变量的分布函数就是一个将楼层无限增加细分从而使层次分明的阶梯最终转换为一个<strong>平滑化</strong>的斜坡。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/03/30/11-27-50/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/30/11-27-50/" class="post-title-link" itemprop="url">OpenCv笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-30 11:27:50" itemprop="dateCreated datePublished" datetime="2022-03-30T11:27:50+08:00">2022-03-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-24 14:46:27" itemprop="dateModified" datetime="2022-04-24T14:46:27+08:00">2022-04-24</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/03/30/11-27-50/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/03/30/11-27-50/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="opencv-in-python">OpenCV In Python</h1>
<p>为什么学习 OpenCV？</p>
<p>电子设计中使用OpenCV进行图像处理的仿真</p>
<p>使用工具：</p>
<p>python</p>
<p>安装OpenCV：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>
<h2 id="例程展示">例程展示</h2>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d6/d00/tutorial_py_root.html">官网链接</a></p>
<h3 id="getting-started-with-images">Getting Started with Images</h3>
<p>图片入门——读取和显示图片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#作为第一步，导入OpenCV python库。正确的方法是给它附加赋一个名称cv，下面将使用它来引用这个库。</span></span><br><span class="line"><span class="comment">#（不知道为什么要加别称，但是实践是不加别称也可以使用）</span></span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#调用cv::imread()来读入图片（在官网的示例中使用了绝对路径，在我实践中我的电脑上需要使用绝对路径，具体原因不清楚。）</span></span><br><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>))</span><br><span class="line"><span class="comment">#如果图像打开失败，退出并显示“不能读取图片。”</span></span><br><span class="line"><span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    sys.exit(<span class="string">&quot;不能读取图片。&quot;</span>)</span><br><span class="line"><span class="comment">#使用cv::imshow()显示图片，cv::waitkey()用于维持图片显示：cv::waitKey函数唯一的参数是等待用户输入的时间(以毫秒为单位)。零意味着永远等待。返回值是被按下的键。</span></span><br><span class="line">cv.imshow(<span class="string">&quot;显示窗口&quot;</span>, img)</span><br><span class="line">k = cv.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#如果按下的键是“s”键，图像将被写入一个文件。为此，cv::imwrite()函数被调用，该函数具有文件路径和cv::Mat对象作为参数。</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&quot;s&quot;</span>):</span><br><span class="line">    cv.imwrite(<span class="string">&quot;另存为图片名&quot;</span>, img)</span><br><span class="line">    k = cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>读取图像函数：cv::imread</p>
<p>第一个参数指定的文件路径来加载图像。第二个参数是可选的，它指定图像的格式:</p>
<ul>
<li><p>IMREAD_COLOR 以BGR 8位格式加载图像。这是这里使用的<strong>默认</strong>。</p></li>
<li><p>IMREAD_UNCHANGED 按原样加载图像(包括alpha通道)。</p></li>
<li><p>IMREAD_GRAYSCALE 以灰度值加载图像。</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#具体写法</span></span><br><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>),cv.IMREAD_GRAYSCALE)</span><br></pre></td></tr></table></figure>
<p>备注：</p>
<ul>
<li><p>对于彩色图像，解码后的图像将以B G R顺序存储通道。</p></li>
<li><p>当使用IMREAD_GRAYSCALE时，如果可用，将使用编解码器的内部灰度转换。结果可能与cvtColor()的输出不同</p></li>
</ul></li>
</ol>
<h2 id="capture-video-from-camera">Capture Video from Camera</h2>
<p>视频入门——调用电脑摄像头并获取视频</p>
<p>有时我们需要用摄像头捕获实时流，OpenCV提供了一个非常简单的接口来做到这一点。本次任务使用电脑内置的摄像头捕获视频并且显示。</p>
<p>要捕获视频，您需要创建一个<strong>VideoCapture</strong>对象。它的参数可以是设备索引或视频文件的名称。设备索引只是指定哪个摄像机的数字。通常会连接一个摄像头。所以我只是传递0（或 -1）。你可以通过传递1来选择第二个摄像机，以此类推。之后，您可以逐帧捕捉。但在最后，不要忘记释放<strong>Capture</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cannot open camera&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Capture frame-by-frame</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Our operations on the frame come here</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Display the resulting frame</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># When everything done, release the capture</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="string">r&#x27;C:\Users\qjy\Desktop\a.mp4&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="basic-operations-on-images">Basic Operations on Images</h3>
<h1 id="opencv-python教程">OpenCV-Python教程</h1>
<h2 id="opencv中的图像处理">OpenCV中的图像处理</h2>
<h3 id="色彩空间转换">色彩空间转换</h3>
<h4 id="目标">目标</h4>
<ul>
<li><p>在本教程中，您将学习如何将图像从一个颜色空间转换到另一个颜色空间，如 <span class="math inline">\(BGR↔Gray\)</span>，<span class="math inline">\(BGR↔HSV\)</span> 等。</p></li>
<li><p>除此之外，我们将创建一个应用程序来提取视频中的彩色对象</p></li>
<li><p>你将学习以下函数： <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab"><code>cv.cvtColor()</code></a></strong>， <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d2/de8/group__core__array.html#ga48af0ab51e36436c5d04340e036ce981"><code>cv.inRange()</code></a></strong> 等。</p></li>
</ul>
<h4 id="改变颜色空间">改变颜色空间</h4>
<p><span class="math inline">\(OpenCV\)</span> 中有超过150种颜色空间转换方法。但我们只看两种使用最广泛的一种： <span class="math inline">\(BGR↔Gray\)</span> 和 <span class="math inline">\(BGR↔HSV\)</span> 。</p>
<p>对于颜色转换，我们使用函数 <code>cv.cvtColor(input_image, flag)</code>，其中 <span class="math inline">\(flag\)</span> 决定转换的类型。</p>
<p>对于 <span class="math inline">\(BGR→Gray\)</span> 转换，我们使用标志<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea"><code>cv.COLOR_BGR2GRAY</code></a>。类似地，对于 <span class="math inline">\(BGR→HSV\)</span>，我们使用标志<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0aa4a7f0ecf2e94150699e48c79139ee12"><code>cv.COLOR_BGR2HSV</code></a>。要获取其他标志，只需在 <span class="math inline">\(Python\)</span> 终端中运行以下命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flags = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv) <span class="keyword">if</span> i.startswith(<span class="string">&#x27;COLOR_&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( flags )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>对于HSV，色相范围为[0,179]，饱和度范围为[0,255]，取值范围为[0,255]。不同的软件使用不同的尺度。所以如果你在比较 <span class="math inline">\(OpenCV\)</span> 值和它们，你需要标准化这些范围。</p>
</blockquote>
<h4 id="跟踪对象">跟踪对象</h4>
<p>现在我们知道了如何将 <span class="math inline">\(BGR\)</span> 图像转换为 <span class="math inline">\(HSV\)</span>，我们可以使用它来提取有颜色的对象。在 $ HSV$ 中，比在 <span class="math inline">\(BGR\)</span> 颜色空间中更容易表示颜色。在我们的应用程序中，我们将尝试提取一个蓝色的对象。方法如下：</p>
<ul>
<li><p>取视频的每一帧。</p></li>
<li><p>从 <span class="math inline">\(BGR\)</span> 转换到 <span class="math inline">\(HSV\)</span> 颜色空间。</p></li>
<li><p>我们阈值的 <span class="math inline">\(HSV\)</span> 图像范围的蓝色。</p></li>
<li><p>现在单独提取蓝色物体，我们可以对图像做任何我们想做的事情。</p></li>
</ul>
<p>下面是详细注释的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># Take each frame</span></span><br><span class="line">    _, frame = cap.read()</span><br><span class="line">    <span class="comment"># Convert BGR to HSV</span></span><br><span class="line">    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)</span><br><span class="line">    <span class="comment"># define range of blue color in HSV</span></span><br><span class="line">    lower_blue = np.array([<span class="number">110</span>,<span class="number">50</span>,<span class="number">50</span>])</span><br><span class="line">    upper_blue = np.array([<span class="number">130</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">    <span class="comment"># Threshold the HSV image to get only blue colors</span></span><br><span class="line">    mask = cv.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line">    <span class="comment"># Bitwise-AND mask and original image</span></span><br><span class="line">    res = cv.bitwise_and(frame,frame, mask= mask)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>,frame)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;mask&#x27;</span>,mask)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;res&#x27;</span>,res)</span><br><span class="line">    k = cv.waitKey(<span class="number">5</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>下图显示了对蓝色物体的跟踪：</p>
<p><img src="/2022/03/30/11-27-50/frame.jpg"></p>
<blockquote>
<p>Note</p>
<p>图像中有一些噪声。我们将在后面的章节中看到如何删除它。</p>
<p>这是目标跟踪中最简单的方法。一旦你学会了轮廓函数，你就可以做很多事情，比如找到物体的质心并使用它来跟踪物体，通过在摄像机前移动你的手来绘制图表，以及其他有趣的事情。</p>
</blockquote>
<h4 id="如何找到hsv值跟踪">如何找到HSV值跟踪？</h4>
<p>这是在 <a target="_blank" rel="noopener" href="https://www.stackoverflow.com/">stackoverflow.com</a> 中发现的一个常见问题。它非常简单，你可以使用相同的函数<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab"><code>cv.cvtColor()</code></a>。你只需传递你想要的 <span class="math inline">\(BGR\)</span> 值，而不是传递一个图像。例如，要找到绿色的 <span class="math inline">\(HSV\)</span> 值，请在 $ Python$ 终端中尝试以下命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>green = np.uint8([[[<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span> ]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsv_green = cv.cvtColor(green,cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( hsv_green )</span><br><span class="line">[[[ <span class="number">60</span> <span class="number">255</span> <span class="number">255</span>]]]</span><br></pre></td></tr></table></figure>
<p>现在分别取 <span class="math inline">\([H-10, 100,100]\)</span> 和 <span class="math inline">\([H+10, 255,255]\)</span> 为下界和上界。除了这种方法之外，您还可以使用任何图像编辑工具（如 <span class="math inline">\(GIMP\)</span>）或任何在线转换器来查找这些值，但不要忘记调整 <span class="math inline">\(HSV\)</span> 范围。</p>
<h4 id="附加资源">附加资源</h4>
<p>练习：</p>
<p>试着找出一种方法来提取不止一种颜色的对象，例如，同时提取红色、蓝色和绿色的对象。</p>
<h3 id="图像的几何变换">图像的几何变换</h3>
<h3 id="图像阈值化">图像阈值化</h3>
<h4 id="目标-1">目标</h4>
<ul>
<li>在本教程中，您将学习简单的阈值，自适应阈值和 <span class="math inline">\(Otsu\)</span> 的阈值。</li>
<li>你们将学习函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold</code></a></strong> 和 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3"><code>cv.adaptiveThreshold</code></a></strong>。</li>
</ul>
<h4 id="简单的阈值">简单的阈值</h4>
<p>在这里，事情很简单。对于每个像素，应用相同的阈值。如果像素值小于阈值，则设置为 <span class="math inline">\(0\)</span>，否则设置为最大值。函数的简历。<span class="math inline">\(Threshold\)</span> 用于应用阈值。第一个参数是源图像，它应该是一个灰度图像。第二个参数是用于对像素值进行分类的阈值。第三个参数是分配给超过阈值的像素值的最大值。<span class="math inline">\(OpenCV\)</span> 提供了由第四个参数给出的不同类型的阈值</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a147222a96556ebc1d948b372bcd7ac59"><code>cv.THRESH_BINARY</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a19120b1a11d8067576cc24f4d2f03754"><code>cv.THRESH_BINARY_INV</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576ac7e89a5e95490116e7d2082b3096b2b8"><code>cv.THRESH_TRUNC</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a0e50a338a4b711a8c48f06a6b105dd98"><code>cv.THRESH_TOZERO</code></a></li>
<li><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a47518a30aae90d799035bdcf0bb39a50"><code>cv.THRESH_TOZERO_INV</code></a></li>
</ul>
<p>请参阅这些类型的文档以了解其区别。</p>
<p>该方法返回两个输出。第一个是所使用的阈值，第二个输出是阈值图像。</p>
<p>这段代码比较了不同的简单阈值类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;gradient.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">ret,thresh1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">ret,thresh2 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TRUNC)</span><br><span class="line">ret,thresh4 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO)</span><br><span class="line">ret,thresh5 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO_INV)</span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>,<span class="string">&#x27;BINARY&#x27;</span>,<span class="string">&#x27;BINARY_INV&#x27;</span>,<span class="string">&#x27;TRUNC&#x27;</span>,<span class="string">&#x27;TOZERO&#x27;</span>,<span class="string">&#x27;TOZERO_INV&#x27;</span>]</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>,vmin=<span class="number">0</span>,vmax=<span class="number">255</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>为了绘制多幅图像，我们使用了 <code>plt.subplot()</code> 函数。详情请查看 <span class="math inline">\(matplotlib\)</span> 文档。</p>
</blockquote>
<p>代码产生如下结果：</p>
<p><img src="/2022/03/30/11-27-50/threshold.jpg"></p>
<h4 id="自适应阈值">自适应阈值</h4>
<p>在前一节中，我们使用一个全局值作为阈值。但这并不是在所有情况下都是好的，例如，如果一个图像在不同的区域有不同的光照条件。在这种情况下，自适应阈值可以有所帮助。在这里，算法根据像素周围的小区域确定阈值。因此，我们对同一幅图像的不同区域采用不同的阈值，对不同光照条件下的图像有较好的处理效果。</p>
<p>除上述参数外，方法 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3"><code>cv.adaptiveThreshold</code></a> 接受三个输入参数：</p>
<p><code>adaptivmethod</code>决定如何计算阈值:</p>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa42a3e6ef26247da787bf34030ed772cad0c5199ae8637a6b195062fea4789fa9"><code>cv.ADAPTIVE_THRESH_MEAN_C</code></a>：阈值是邻近区域的平均值减去常数C。</p>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa42a3e6ef26247da787bf34030ed772caf262a01e7a3f112bbab4e8d8e28182dd"><code>cv.ADAPTIVE_THRESH_GAUSSIAN_C</code></a>：阈值是邻域值减去常数C的高斯加权和。</p>
<p><code>blockSize</code> 决定了邻域区域的大小，<span class="math inline">\(C\)</span> 是一个常数，从邻域像素的平均值或加权和中减去。</p>
<p>下面的代码比较了全局阈值和自适应阈值对不同光照的图像的影响：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\11.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">img = cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line">ret,th1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">th2 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_MEAN_C,cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">th3 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>, <span class="string">&#x27;Global Thresholding (v = 127)&#x27;</span>,<span class="string">&#x27;Adaptive Mean Thresholding&#x27;</span>, <span class="string">&#x27;Adaptive Gaussian Thresholding&#x27;</span>]</span><br><span class="line">images = [img, th1, th2, th3]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/ada_threshold.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">img = cv.imread(r&#x27;C:\Users\qjy\Desktop\65ce8a75cfc0dc33feddd6d4632ab1a.jpg&#x27;,0)</span><br><span class="line">kernel = np.ones((2,1),np.uint8)</span><br><span class="line">closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span><br><span class="line">#erosion = cv.erode(img,kernel,iterations = 1)</span><br><span class="line">cv.imshow(&#x27;res&#x27;,closing)</span><br><span class="line">k = cv.waitKey(0)</span><br></pre></td></tr></table></figure>
<h4 id="otsu-二值法">Otsu 二值法</h4>
<p>在全局阈值中，我们使用任意选择的值作为阈值。相比之下，<span class="math inline">\(Otsu\)</span> 的方法避免了必须选择一个值，并自动确定它。</p>
<p>考虑一个只有两个不同图像值的图像(双峰图像)，其中直方图只包含两个峰。一个合适的阈值应该在这两个值之间。类似地，<span class="math inline">\(Otsu\)</span> 的方法从图像直方图中确定一个最优的全局阈值。</p>
<p>为此，我们使用了 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold()</code></a> 函数，其中 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold()</code></a> 是 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a95251923e8e22f368ffa86ba8bce87ff"><code>cv.THRESH_OTSU</code></a> 被作为一个额外的标志传递。阈值可以任意选择。</p>
<p>看看下面的例子。输入图像是一个有噪声的图像。在第一种情况下，应用值为 <span class="math inline">\(127\)</span> 的全局阈值。在第二种情况下，直接应用 <span class="math inline">\(Otsu\)</span> 的阈值。在第三种情况下，首先用 <span class="math inline">\(5x5\)</span> 高斯核滤波去除噪声，然后应用 <span class="math inline">\(Otsu\)</span> 阈值。看看噪声滤波是如何改善结果的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;noisy2.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># global thresholding</span></span><br><span class="line">ret1,th1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line"><span class="comment"># Otsu&#x27;s thresholding</span></span><br><span class="line">ret2,th2 = cv.threshold(img,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="comment"># Otsu&#x27;s thresholding after Gaussian filtering</span></span><br><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line">ret3,th3 = cv.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="comment"># plot all the images and their histograms</span></span><br><span class="line">images = [img, <span class="number">0</span>, th1,</span><br><span class="line">          img, <span class="number">0</span>, th2,</span><br><span class="line">          blur, <span class="number">0</span>, th3]</span><br><span class="line">titles = [<span class="string">&#x27;Original Noisy Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&#x27;Global Thresholding (v=127)&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Original Noisy Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>,</span><br><span class="line">          <span class="string">&#x27;Gaussian filtered Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">1</span>),plt.imshow(images[i*<span class="number">3</span>],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">2</span>),plt.hist(images[i*<span class="number">3</span>].ravel(),<span class="number">256</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">1</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">3</span>),plt.imshow(images[i*<span class="number">3</span>+<span class="number">2</span>],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">2</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/otsu.jpg"></p>
<h3 id="otsu-二值化是如何工作的">Otsu 二值化是如何工作的？</h3>
<p>本节演示了 <span class="math inline">\(Otsu\)</span> 二值化的 <span class="math inline">\(Python\)</span> 实现，以展示它实际上是如何工作的。如果你不感兴趣，你可以跳过这个。</p>
<p>由于我们使用的是双峰图像，<span class="math inline">\(Otsu\)</span> 的算法试图找到一个阈值<span class="math inline">\((t)\)</span>，使由关系给出的<strong>weighted within-class variance</strong>最小化： <span class="math display">\[
\sigma_w^2(t) = q_1(t)\sigma_1^2(t)+q_2(t)\sigma_2^2(t)
\]</span> 其中： <span class="math display">\[
\begin{gather*}
\mu_1(t) = \sum_{i=1}^{t} \frac{iP(i)}{q_1(t)} \quad \&amp; \quad \mu_2(t) = \sum_{i=t+1}^{I} \frac{iP(i)}{q_2(t)}\\
\mu_1(t) = \sum_{i=1}^{t} \frac{iP(i)}{q_1(t)} \quad \&amp; \quad \mu_2(t) = \sum_{i=t+1}^{I} \frac{iP(i)}{q_2(t)}\\
\sigma_1^2(t) = \sum_{i=1}^{t} [i-\mu_1(t)]^2 \frac{P(i)}{q_1(t)} \quad \&amp; \quad \sigma_2^2(t) = \sum_{i=t+1}^{I} [i-\mu_2(t)]^2 \frac{P(i)}{q_2(t)}
\end{gather*}
\]</span> 它实际上找到了一个 <span class="math inline">\(t\)</span> 的值，它位于两个峰值之间，使得这两个类的方差都是最小的。它可以简单地在 <span class="math inline">\(Python\)</span> 中实现如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&#x27;noisy2.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line"><span class="comment"># find normalized_histogram, and its cumulative distribution function</span></span><br><span class="line">hist = cv.calcHist([blur],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">hist_norm = hist.ravel()/hist.<span class="built_in">sum</span>()</span><br><span class="line">Q = hist_norm.cumsum()</span><br><span class="line">bins = np.arange(<span class="number">256</span>)</span><br><span class="line">fn_min = np.inf</span><br><span class="line">thresh = -<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">    p1,p2 = np.hsplit(hist_norm,[i]) <span class="comment"># probabilities</span></span><br><span class="line">    q1,q2 = Q[i],Q[<span class="number">255</span>]-Q[i] <span class="comment"># cum sum of classes</span></span><br><span class="line">    <span class="keyword">if</span> q1 &lt; <span class="number">1.e-6</span> <span class="keyword">or</span> q2 &lt; <span class="number">1.e-6</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    b1,b2 = np.hsplit(bins,[i]) <span class="comment"># weights</span></span><br><span class="line">    <span class="comment"># finding means and variances</span></span><br><span class="line">    m1,m2 = np.<span class="built_in">sum</span>(p1*b1)/q1, np.<span class="built_in">sum</span>(p2*b2)/q2</span><br><span class="line">    v1,v2 = np.<span class="built_in">sum</span>(((b1-m1)**<span class="number">2</span>)*p1)/q1,np.<span class="built_in">sum</span>(((b2-m2)**<span class="number">2</span>)*p2)/q2</span><br><span class="line">    <span class="comment"># calculates the minimization function</span></span><br><span class="line">    fn = v1*q1 + v2*q2</span><br><span class="line">    <span class="keyword">if</span> fn &lt; fn_min:</span><br><span class="line">        fn_min = fn</span><br><span class="line">        thresh = i</span><br><span class="line"><span class="comment"># find otsu&#x27;s threshold value with OpenCV function</span></span><br><span class="line">ret, otsu = cv.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(thresh,ret) )</span><br></pre></td></tr></table></figure>
<h4 id="附加资源-1">附加资源</h4>
<ol type="1">
<li>Digital Image Processing, Rafael C. Gonzalez</li>
</ol>
<h4 id="exercises">Exercises</h4>
<ol type="1">
<li>There are some optimizations available for Otsu's binarization. You can search and implement it.</li>
</ol>
<h3 id="平滑图像">平滑图像</h3>
<h4 id="目标-2">目标</h4>
<p>学习：</p>
<ul>
<li><p>用各种低通滤波器模糊图像</p></li>
<li><p>为图像应用定制滤镜(2D卷积)</p></li>
</ul>
<h4 id="二维卷积图像滤波">二维卷积（图像滤波）</h4>
<p>和一维信号一样，图像也可以用各种低通滤波器（<span class="math inline">\(LPF\)</span>）、高通滤波器（<span class="math inline">\(HPF\)</span>）等进行滤波。<span class="math inline">\(LPF\)</span> 有助于去除噪声、模糊图像等。高频滤波器有助于在图像中找到边缘。</p>
<p>$OpenCV $ 提供了一个函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga27c049795ce870216ddfb366086b5a04"><code>cv.filter2D()</code></a></strong> 来将内核与图像进行卷积。例如，我们将尝试在图像上使用平均滤镜。一个 <span class="math inline">\(5x5\)</span> 平均的过滤器内核看起来如下所示： <span class="math display">\[
K = \frac{1}{25} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \end{bmatrix}
\]</span> 操作是这样的：将该内核保持在一个像素之上，将该内核之下的所有25个像素相加，取平均值，并用新的平均值替换中心像素。对图像中的所有像素继续执行此操作。尝试以下代码并检查结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv_logo.png&#x27;</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.float32)/<span class="number">25</span></span><br><span class="line">dst = cv.filter2D(img,-<span class="number">1</span>,kernel)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">&#x27;Averaging&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/filter.jpg"></p>
<h4 id="图像模糊图像平滑">图像模糊（图像平滑）</h4>
<p>图像模糊是通过卷积图像与低通滤波核。它对消除噪声很有用。它实际上从图像中去除高频内容（如噪声和边缘）。所以在这个操作中，边缘会模糊一些（也有一些模糊技术不会模糊边缘）<span class="math inline">\(OpenCV\)</span> 提供了四种主要的模糊技术。</p>
<ol type="1">
<li><p>平均值</p>
<p>这是通过卷积图像与一个标准化的盒子过滤器。它只是取内核区域下所有像素的平均值，然后替换中心元素。这是由函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37"><code>cv.blur()</code></a></strong> 或 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3"><code>cv.boxFilter()</code></a></strong> 完成的。查看文档了解更多关于内核的细节。我们应该指定内核的宽度和高度。一个 <span class="math inline">\(3x3\)</span> 标准化的框状滤波器看起来如下所示： <span class="math display">\[
K = \frac{1}{9} \begin{bmatrix} 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \end{bmatrix}
\]</span></p>
<blockquote>
<p>Note</p>
<p>如果您不想使用规范化的框过滤器，请使用 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3"><code>cv.boxFilter()</code></a></strong>。传递一个参数 <code>normalize=False</code> 给函数。</p>
</blockquote>
<p>查看下面一个 <span class="math inline">\(5x5\)</span> 内核大小的示例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv-logo-white.png&#x27;</span>)</span><br><span class="line">blur = cv.blur(img,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blur),plt.title(<span class="string">&#x27;Blurred&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/blur.jpg"></p></li>
<li><p>高斯模糊</p>
<p>在此方法中，使用高斯核代替盒形滤波器。这是通过函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1"><code>cv.GaussianBlur()</code></a></strong> 完成的。我们应该指定内核的宽度和高度，它们应该是正的和奇数的。我们还应该指定X和Y方向的标准差，分别是 $ sigmaX$ 和 <span class="math inline">\(sigmaY\)</span>。如果只指定了 <span class="math inline">\(sigmaX\)</span>，则 <span class="math inline">\(sigmaY\)</span> 与 $ sigmaX$ 取相同的值。如果两者都是 <span class="math inline">\(0\)</span>，则从内核大小计算。高斯模糊是去除图像高斯噪声的一种有效方法。</p>
<p>如果你愿意，你可以用函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa"><code>cv.getGaussianKernel()</code></a></strong> 创建一个高斯核。</p>
<p>以上代码可以修改为高斯模糊：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/gaussian.jpg"></p></li>
<li><p>模糊中值</p>
<p>在这里，函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9"><code>cv.medianBlur()</code></a></strong> 取内核区域下所有像素的中值，并将中心元素替换为这个中值。这对于图像中的椒盐噪声是非常有效的。有趣的是，在上面的过滤器中，中心元素是一个新计算的值，它可能是图像中的像素值，也可能是一个新值。但在中值模糊中，中心元素往往被图像中的某个像素值所替代。有效地降低了噪声。它的内核大小应该是一个正奇数。2</p>
<p>在这个演示中，我给原始图像添加了 <span class="math inline">\(50%\)</span> 的噪声，并应用了中间值模糊。检查结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">median = cv.medianBlur(img,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/median.jpg"></p></li>
<li><p>双边滤波</p>
<p><strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed"><code>cv.bilateralFilter()</code></a></strong> 在去除噪声的同时保持边缘锋利是非常有效的。但与其他滤波器相比，其运算速度较慢。我们已经知道高斯滤波器取像素周围的邻域并求其高斯加权平均值。该高斯滤波器是一个单独的空间函数，即在滤波时考虑附近的像素。它不考虑像素是否有几乎相同的强度。它不考虑一个像素是否是边缘像素。它也会模糊边缘，这是我们不想做的。</p>
<p>双边滤波也在空间中采用高斯滤波器，但多了一个高斯滤波器，它是像素差的函数。空间高斯函数保证了只考虑附近像素进行模糊处理，而强度差高斯函数保证了只考虑那些与中心像素强度相似的像素进行模糊处理。所以它保留了边缘，因为边缘上的像素会有很大的强度变化。</p>
<p>下面的示例展示了双边过滤器的使用(关于参数的详细信息，请访问docs)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blur = cv.bilateralFilter(img,<span class="number">9</span>,<span class="number">75</span>,<span class="number">75</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/bilateral.jpg"></p>
<p>看，表面的纹理消失了，但边缘还保留着。</p></li>
</ol>
<h4 id="附加资源-2">附加资源</h4>
<ol type="1">
<li>Details about the <a target="_blank" rel="noopener" href="https://people.csail.mit.edu/sparis/bf_course/">bilateral filtering</a></li>
</ol>
<h4 id="exercises-1">Exercises</h4>
<h3 id="形态学变换">形态学变换</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\65ce8a75cfc0dc33feddd6d4632ab1a.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">2</span>,<span class="number">2</span>),np.uint8)</span><br><span class="line"><span class="comment">#closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span></span><br><span class="line"><span class="comment">#erosion = cv.erode(img,kernel,iterations = 1)</span></span><br><span class="line"><span class="comment">#dilation = cv.dilate(img,kernel,iterations = 1)</span></span><br><span class="line">opening = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)</span><br><span class="line">cv.imshow(<span class="string">&#x27;res&#x27;</span>,opening)</span><br><span class="line">k = cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="目标-3">目标</h4>
<p>在这一章</p>
<ul>
<li><p>我们将学习不同的形态操作，如腐蚀，膨胀，开操作，闭操作等等。</p></li>
<li><p>我们将看到不同的函数： <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb"><code>cv.erode()</code></a></strong>, <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c"><code>cv.dilate()</code></a></strong>, <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f"><code>cv.morphologyEx()</code></a></strong> 等等。</p></li>
</ul>
<h4 id="理论">理论</h4>
<p>形态变换是一种基于图像形状的简单操作。它通常在二值图像上执行。它需要两个输入，一个是原始图像，另一个是决定运算性质的结构元素或核。两个基本的形态运算符是腐蚀和膨胀。然后它的变体形式，如开操作，闭操作和梯度等也会发挥作用。我们将在下图的帮助下一个一个地看到它们：</p>
<p><img src="/2022/03/30/11-27-50/j-16487088974263.png"></p>
<ol type="1">
<li><p><strong>腐蚀</strong></p>
<p>腐蚀的基本概念就像土壤腐蚀一样，它腐蚀了前景对象的边界（尽量保持前景为白色）。那么它有什么作用呢？核在图像中滑动（就像在二维卷积中一样）。只有当核下的所有像素都是 <span class="math inline">\(1\)</span> 时，原始图像中的一个像素（<span class="math inline">\(1\)</span> 或 $ 0$）才会被认为是 <span class="math inline">\(1\)</span>，否则它会被腐蚀（变成 <span class="math inline">\(0\)</span>）。</p>
<p>所以进行腐蚀操作时发生的是，边界附近的所有像素都会被丢弃，这取决于内核的大小。因此前景物体的厚度或尺寸减小，或者图像中的白色区域减小。它可以用来去除小的白色噪音（正如我们在色彩空间章节中看到的），分离两个连接的物体等等。</p>
<p>在这里，作为一个例子，我将使用一个充满1的5x5内核。让我们看看它是如何工作的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv.imread(<span class="string">&#x27;j.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">erosion = cv.erode(img,kernel,iterations = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/erosion-16487092156135.png"></p></li>
<li><p><strong>膨胀</strong></p>
<p>膨胀与腐蚀正好相反，在膨胀操作中，如果核下至少有一个像素为“1”，则像素元素为“1”。因此，它增加了图像中的白色区域，或增加了前景对象的大小。通常情况下，在去除噪音的情况下，腐蚀之后是膨胀。因为侵蚀去除了白噪音，但也缩小了我们的目标。所以我们把它放大。因为噪音消失了，它们不会回来，但是我们的物体面积增加了。它在连接物体的破碎部分时也很有用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dilation = cv.dilate(img,kernel,iterations = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/dilation-16487093069197.png"></p></li>
<li><p><strong>开操作</strong></p>
<p>开操作只是腐蚀和膨胀的另一个名称。它在去除噪音方面很有用，正如我们上面解释的那样。这里我们使用函数<strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f"><code>cv.morphologyEx()</code></a></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opening = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure>
<img src="/2022/03/30/11-27-50/opening-16487093835949.png" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure></li>
<li><p><strong>闭操作</strong></p>
<p>闭操作是开操作的反向，即先膨胀后腐蚀。它在删除前景物体内部的小洞或物体上的小黑点时很有用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/closing-164870944983811.png"></p></li>
<li><p><strong>形态学梯度</strong></p>
<p>它是图像膨胀和侵蚀的区别，梯度的结果将看起来像对象的轮廓。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradient = cv.morphologyEx(img, cv.MORPH_GRADIENT, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/gradient.png"></p></li>
<li><p><strong>Top Hat</strong></p>
<p>它是输入图像和开操作处理后的输出图像之间的区别。下面的例子是针对9x9内核的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tophat = cv.morphologyEx(img, cv.MORPH_TOPHAT, kernel)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/30/11-27-50/tophat-164870959228714.png"></p></li>
<li><p><strong>Black Hat</strong></p>
<p>它是输入图像的闭操作与输入图像之间的区别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blackhat = cv.morphologyEx(img, cv.MORPH_BLACKHAT, kernel)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/30/11-27-50/blackhat.png"></p></li>
</ol>
<h4 id="结构元素">结构元素</h4>
<p>在前面的例子中，我们在 <span class="math inline">\(Numpy\)</span> 的帮助下手工创建了一个结构化元素。它是长方形的。但在某些情况下，您可能需要椭圆形/圆形的核。为此，<span class="math inline">\(OpenCV\)</span> 有一个函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc"><code>cv.getStructuringElement()</code></a></strong>。你只需要传递内核的形状和大小，就可以得到想要的内核。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rectangular Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_RECT,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># Elliptical Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_ELLIPSE,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># Cross-shaped Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_CROSS,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br></pre></td></tr></table></figure>
<h4 id="额外的资源">额外的资源</h4>
<ol type="1">
<li><a target="_blank" rel="noopener" href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm">Morphological Operations</a> at HIPR2</li>
</ol>
<h4 id="练习">练习</h4>
<h3 id="图像的梯度">图像的梯度</h3>
<h3 id="canny-边缘检测">Canny 边缘检测</h3>
<h3 id="图像金字塔">图像金字塔</h3>
<h3 id="opencv-的轮廓">OpenCV 的轮廓</h3>
<h3 id="opencv-的直方图">OpenCV 的直方图</h3>
<h3 id="opencv-中的图像变换">OpenCV 中的图像变换</h3>
<h3 id="模板匹配">模板匹配</h3>
<h3 id="hough-直线检测">Hough 直线检测</h3>
<h3 id="基于分水岭算法的图像分割">基于分水岭算法的图像分割</h3>
<h3 id="基于-grabcut-算法的交互式前景提取">基于 GrabCut 算法的交互式前景提取</h3>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/03/29/16-12-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/29/16-12-02/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-29 16:12:02" itemprop="dateCreated datePublished" datetime="2022-03-29T16:12:02+08:00">2022-03-29</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/03/29/16-12-02/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/03/29/16-12-02/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">clc; </span><br><span class="line">close all; </span><br><span class="line">clear all; </span><br><span class="line">I=imread(&#x27;2019050913413134.png&#x27;);%要求你.m文件下有test.bmp这个图像文件 </span><br><span class="line">PR=I(:,:,1);%提取红色分量 </span><br><span class="line">PG=I(:,:,2);%提取绿色分量 </span><br><span class="line">PB=I(:,:,3);%提取蓝色分量 </span><br><span class="line"> </span><br><span class="line">figure; </span><br><span class="line">subplot(2,2,1);imshow(I);title(&#x27;原图像&#x27;); </span><br><span class="line">subplot(2,2,2);imshow(PR);title(&#x27;提取红分量后&#x27;); </span><br><span class="line">subplot(2,2,3);imshow(PG);title(&#x27;提取绿色分量后&#x27;); </span><br><span class="line">subplot(2,2,4);imshow(PB);title(&#x27;提取蓝色分量后&#x27;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">I=imread(&#x27;2019050913413134.png&#x27;); </span><br><span class="line">[m,n,d]=size(I); </span><br><span class="line"> </span><br><span class="line">level=15;%设置阈值 </span><br><span class="line">level2=70;%设置阈值 </span><br><span class="line"> </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,1)-I(i,j,2)&gt;level2)&amp;&amp;(I(i,j,1)-I(i,j,3)&gt;level2)) </span><br><span class="line">            r(i,j,1)=I(i,j,1); </span><br><span class="line">            r(i,j,2)=I(i,j,2); </span><br><span class="line">            r(i,j,3)=I(i,j,3); </span><br><span class="line">       else  </span><br><span class="line">            r(i,j,1)=255; </span><br><span class="line">            r(i,j,2)=255; </span><br><span class="line">            r(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">figure; </span><br><span class="line">subplot(2,2,1);imshow(I);title(&#x27;原图像&#x27;); </span><br><span class="line">subplot(2,2,2);imshow(r);title(&#x27;提取红分量后&#x27;);%显示提取红分量后的图 </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">%提取绿分量，不满足阈值的变为白色 </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,2)-I(i,j,1)&gt;level)&amp;&amp;(I(i,j,2)-I(i,j,3)&gt;level)) </span><br><span class="line">            g(i,j,1)=I(i,j,1); </span><br><span class="line">            g(i,j,2)=I(i,j,2); </span><br><span class="line">            g(i,j,3)=I(i,j,3); </span><br><span class="line">        else </span><br><span class="line">            g(i,j,1)=255; </span><br><span class="line">            g(i,j,2)=255; </span><br><span class="line">            g(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">subplot(2,2,3);imshow(g);title(&#x27;提取绿分量后&#x27;); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">%提取蓝色分量 </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,3)-I(i,j,1)&gt;level)&amp;&amp;(I(i,j,3)-I(i,j,2)&gt;level)) </span><br><span class="line">                    b(i,j,1)=I(i,j,1); </span><br><span class="line">                    b(i,j,2)=I(i,j,2); </span><br><span class="line">                    b(i,j,3)=I(i,j,3); </span><br><span class="line">        else </span><br><span class="line">            b(i,j,1)=255; </span><br><span class="line">            b(i,j,2)=255; </span><br><span class="line">            b(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">subplot(2,2,4);imshow(b);title(&#x27;提取蓝色分量后&#x27;);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%清空变量，读取图像</span></span><br><span class="line">RGB = imread(<span class="string">&#x27;2019050913413134.png&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;process&#x27;</span>),</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(RGB),title(<span class="string">&#x27;原始RGB&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%convert frame from RGB to YCBCR colorspace（转换到YCBCR空间）</span></span><br><span class="line">YCBCR = rgb2ycbcr(RGB);</span><br><span class="line">whos,</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(YCBCR),title(<span class="string">&#x27;YCBCR&#x27;</span>),</span><br><span class="line"><span class="comment">%filter YCBCR image between values and store filtered image to threshold</span></span><br><span class="line"><span class="comment">%matrix（用各个通道的阈值对其进行二值化处理）</span></span><br><span class="line">Y_MIN = <span class="number">0</span>;  Y_MAX = <span class="number">256</span>;</span><br><span class="line">Cb_MIN = <span class="number">100</span>;   Cb_MAX = <span class="number">127</span>;</span><br><span class="line">Cr_MIN = <span class="number">138</span>;   Cr_MAX = <span class="number">170</span>;</span><br><span class="line">threshold=roicolor(YCBCR(:,:,<span class="number">1</span>),Y_MIN,Y_MAX)&amp;roicolor(YCBCR(:,:,<span class="number">2</span>),Cb_MIN,Cb_MAX)&amp;roicolor(YCBCR(:,:,<span class="number">3</span>),Cr_MIN,Cr_MAX);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),imshow(threshold),title(<span class="string">&#x27;YCBCR二值化&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%perform morphological operations on thresholded image to eliminate noise</span></span><br><span class="line"><span class="comment">%and emphasize the filtered object(s)（进行形态学处理：腐蚀、膨胀、孔洞填充）</span></span><br><span class="line">erodeElement = strel(<span class="string">&#x27;square&#x27;</span>, <span class="number">3</span>) ;</span><br><span class="line">dilateElement=strel(<span class="string">&#x27;square&#x27;</span>, <span class="number">8</span>) ;</span><br><span class="line">threshold = imerode(threshold,erodeElement);</span><br><span class="line">threshold = imerode(threshold,erodeElement);</span><br><span class="line">threshold=imdilate(threshold, dilateElement);</span><br><span class="line">threshold=imdilate(threshold, dilateElement);</span><br><span class="line">threshold=imfill(threshold,<span class="string">&#x27;holes&#x27;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>),imshow(threshold),title(<span class="string">&#x27;形态学处理&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%获取区域的&#x27;basic&#x27;属性， &#x27;Area&#x27;, &#x27;Centroid&#x27;, and &#x27;BoundingBox&#x27; </span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;处理结果&#x27;</span>),</span><br><span class="line">stats = regionprops(threshold, <span class="string">&#x27;basic&#x27;</span>);</span><br><span class="line">[C,area_index]=<span class="built_in">max</span>([stats.Area]);</span><br><span class="line"><span class="comment">%定位脸部区域</span></span><br><span class="line">face_locate=[stats(area_index).Centroid(<span class="number">1</span>),stats(area_index).Centroid(<span class="number">2</span>)];</span><br><span class="line">imshow(RGB);title(<span class="string">&#x27;after&#x27;</span>),<span class="built_in">hold</span> on</span><br><span class="line">text(face_locate(<span class="number">1</span>),face_locate(<span class="number">2</span>)<span class="number">-40</span>,  <span class="string">&#x27;face&#x27;</span>,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(face_locate(<span class="number">1</span>),face_locate(<span class="number">2</span>), <span class="string">&#x27;b*&#x27;</span>);</span><br><span class="line">rectangle(<span class="string">&#x27;Position&#x27;</span>,[stats(area_index).BoundingBox],<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;--&#x27;</span>,<span class="string">&#x27;EdgeColor&#x27;</span>,<span class="string">&#x27;r&#x27;</span>),</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/03/23/15-24-59/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/23/15-24-59/" class="post-title-link" itemprop="url">电子专业资料共享计划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-23 15:24:59" itemprop="dateCreated datePublished" datetime="2022-03-23T15:24:59+08:00">2022-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-31 21:42:20" itemprop="dateModified" datetime="2022-07-31T21:42:20+08:00">2022-07-31</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/03/23/15-24-59/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/03/23/15-24-59/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言">前言</h1>
<blockquote>
<p>我也曾很努力地收集各种课程资料，但到最后，某些重要信息的得到却往往依然是纯属偶然。这种状态时常令我感到后怕与不安。我也曾在课程结束后终于有了些许方法与总结，但这些想法无处诉说，最终只能把花费时间与精力才换来的经验耗散在了漫漫的遗忘之中。</p>
<p>我为这一年一年，这么多人孤军奋战的重复劳动感到不平。</p>
<p>我希望能够将这些隐晦的、不确定的、口口相传的资料和经验，变为公开的、易于获取的和大家能够共同完善、积累的共享资料。</p>
<p>我希望只要是前人走过的弯路，后人就不必再走。这是我的信念，也是我建立这个项目的原因。</p>
</blockquote>
<p>注：如果您对本篇博客的目的存在疑问，请阅读<a target="_blank" rel="noopener" href="https://qsctech.github.io/zju-icicles/">此文</a>。</p>
<h3 id="加入我们">加入我们：</h3>
<p><strong>如果您有意愿加入该计划，请注册wolai账号并在<a target="_blank" rel="noopener" href="https://www.wolai.com/aPVPDQTgKUnVaE9JQzKudx">此处</a>进行编辑，请选择文章最后一部分的”推荐模板“，并复制在其上面，然后将副标题改做”来自xxx的推荐“，结束后在评论区评论以联系我去将内容发布在博客内。</strong></p>
<h4 id="资料链接">资料链接：</h4>
<p>链接：https://pan.baidu.com/s/1JEZYkR3-MfOQYS646UjtBg 提取码：2038</p>
<h1 id="河南大学迈阿密学院电子信息专业培养计划及其课本">河南大学迈阿密学院电子信息专业培养计划及其课本</h1>
<h3 id="大一上学期">大一上学期：</h3>
<table>
<colgroup>
<col style="width: 43%">
<col style="width: 56%">
</colgroup>
<thead>
<tr class="header">
<th>第一学期课程（Curriculum in First Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 读写教程 1 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td><em>3 Longman Academic Writing Series</em><br> （无中文版）</td>
</tr>
<tr class="even">
<td>口语</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 视听说教程 1 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>中国近现代史纲要</td>
<td>《中国近现代史纲要 （2018年版）》</td>
</tr>
<tr class="even">
<td>形式与政策</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>大学体育（一）College Physical Education I</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>工程微积分Ⅰ（Calculus Ⅰ for Engineers）</td>
<td><em>Calculus (2nd Edition)</em> <br>《微积分 中文版 上》<br>参考答案</td>
</tr>
<tr class="odd">
<td>线性代数导论（Introduction to Linear Algebra）</td>
<td><a target="_blank" rel="noopener" href="https://kdocs.cn/l/cbVej03YO5yb?f=201"><em>Elementary Linear Algebra</em><br></a>（无中文版和答案）</td>
</tr>
<tr class="even">
<td>大学物理Ⅰ（University Physics Ⅰ）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 上》<br>参考答案</td>
</tr>
<tr class="odd">
<td>工程学导论Ⅰ（Introduction to Engineering Ⅰ）</td>
<td><em>Thinking Like an Engineer</em><br>（无中文版和答案）</td>
</tr>
<tr class="even">
<td>编程导论（Introduction to Programming）</td>
<td><em>C++ Pregramming program Design Including Data Structures</em><br>（无中文版和答案）</td>
</tr>
</tbody>
</table>
<h3 id="大一下学期">大一下学期：</h3>
<table>
<colgroup>
<col style="width: 46%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th>第二学期课程（Curriculum in Second Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 读写教程 2 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td>The Everyday Writer 6th Edition <br>（无中文版）</td>
</tr>
<tr class="even">
<td>口语</td>
<td>《流畅英语口语教程 第二册》</td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 视听说教程 2 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>思想道德修养与法律基础</td>
<td>《思想道德修养与法律基础 （2021年版）》</td>
</tr>
<tr class="even">
<td>毛泽东思想与中国特色社会主义理论体系概论</td>
<td>《毛泽东思想与中国特色社会主义理论体系概论（2021年版）》</td>
</tr>
<tr class="odd">
<td>大学体育（二）College Physical Education II</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>微积分Ⅱ和III（Calculus Ⅱ and III）</td>
<td><em>Calculus (2nd Edition)</em> <br>《微积分 中文版 下》<br>参考答案</td>
</tr>
<tr class="odd">
<td>大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 下》<br>参考答案</td>
</tr>
<tr class="even">
<td>大学物理实验</td>
<td>《大学物理实验》</td>
</tr>
<tr class="odd">
<td>工程学导论Ⅱ（Introduction to Engineering Ⅱ）</td>
<td><em>Engineering Circuit Analysis</em><br>《工程电路分析 中文版》<br></td>
</tr>
<tr class="even">
<td>电路原理及实验（Electrical Circuit Theory and Lab）</td>
<td><em>Electric Circuit Ninth Edition</em><br>《电路 中文版》<br>参考答案</td>
</tr>
<tr class="odd">
<td>电路实验</td>
<td>“教师讲义 + 教学课件”</td>
</tr>
</tbody>
</table>
<h3 id="大二上学期">大二上学期：</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>第三学期课程（Curriculum in Third Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 第三版 读写教程 3 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td><em>Technical Writing A Practical Guide for Engineers, Scientists, and Nontechnical Professionals by Phillip A. Laplante</em><br>无中文版</td>
</tr>
<tr class="even">
<td>口语</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 第三版 视听说教程 3 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>马克思主义基本原理概论</td>
<td>《马克思主义基本原理概论 （2021年版）》</td>
</tr>
<tr class="even">
<td>毛泽东思想与中国特色社会主义理论体系概论</td>
<td>《毛泽东思想与中国特色社会主义理论体系概论（2021年版）》</td>
</tr>
<tr class="odd">
<td>大学体育（三）College Physical Education III</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>常微分方程导论（Introduction to Ordinary Differential）</td>
<td><em>A Textbook on Ordinary Differential Equations</em><br>（无中文版和参考答案）<br>参考书：《常微分方程（第三版）简明本》</td>
</tr>
<tr class="odd">
<td>大学物理III及实验（University Physics III and Lab）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 下》<br>参考答案</td>
</tr>
<tr class="even">
<td>大学物理实验</td>
<td>《大学物理实验》</td>
</tr>
<tr class="odd">
<td>数据结构（Data Structures）</td>
<td>《数据结构（C语言版）》<br><em>Data Structures Using C</em><br>参考资料：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fv4y1f7T1">视频课</a></td>
</tr>
<tr class="even">
<td>电子学Ⅰ及实验（Electronics Ⅰ and Lab）</td>
<td><em>Microelectronic Circuits</em><br><em>Microelectronics Circuit Analysis and Design</em><br>《微电子电路 中文版 上》<br>《微电子电路 中文版 下》<br>《电子电路分析与设计 中文版》<br>参考资料：《模拟电子技术 中文版》</td>
</tr>
<tr class="odd">
<td>电子学实验</td>
<td>“教师讲义”</td>
</tr>
</tbody>
</table>
<h3 id="大二下学期">大二下学期：</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>第四学期课程（Curriculum in Forth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共两门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 第三版 读写教程 4 智慧版》</td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 第三版 视听说教程 4 智慧版》</td>
</tr>
<tr class="even">
<td>大学体育（四）（College Physical Education IV）</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>工程概率基础（Introduction to Engineering Probability）</td>
<td><em>Probability, Statistics, and Random Processes For Electrical Engineerin</em><br>《机率与统计 第三版 中文版 台版》<br><a href>参考答案</a><br>参考资料：《概率论与数理统计 (第四版)》</td>
</tr>
<tr class="even">
<td>信号与系统（Circuits，Signals and System）</td>
<td>《信号与系统（郑君里）第三版 上》<br>参考书籍：<br>《信号与系统（郑君里）第三版 下》<br>《信号与系统（奥本海姆）第二版》</td>
</tr>
<tr class="odd">
<td>逻辑设计（Logic Design）</td>
<td><em>Fundamentals Of Logic Design Seven Edition</em><br>《逻辑设计基础 中文版》<br>参考答案</td>
</tr>
<tr class="even">
<td>数字设计实验（Digital Design Lab）</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>电子学Ⅱ和实验（Electronics Ⅱ and Lab）</td>
<td><em>Microelectronic Circuits</em><br><em>Microelectronics Circuit Analysis and Design</em><br>《微电子电路 中文版 上》<br>《微电子电路 中文版 下》<br>《电子电路分析与设计 中文版》<br>参考资料：《模拟电子技术 中文版》</td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</td>
<td>ARM：《微机原理与接口技术 第三版 基于ARM Cortex-M4 田辉》<br><em>Practical Microcontroller Engineering with ARMÂ­ Technology by Ying Bai<br></em>参考资料：x86：《微型计算机原理与接口技术》</td>
</tr>
<tr class="even">
<td><del>电子电路CAD （Electronic Circuit CAD）</del></td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="大三上学期">大三上学期：</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>第五学期课程（Curriculum in Fifth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>离散时间信号与系统（Discrete-Time Signals and Systems）</td>
<td><em>Signal &amp; System</em><br>《中文版 信号与系统 奥本海姆》</td>
</tr>
<tr class="even">
<td>电磁场原理（Electromagnetic Field Theory）</td>
<td><em>Field and Wave Electromagnetics by David K. Cheng</em><br>《电磁场与电磁波 中文版》<br>参考答案</td>
</tr>
<tr class="odd">
<td>固态电子学（Solid-State Electronics）</td>
<td><em>Semiconductor physics and devices basic principles by Donald A. Neamen</em><br>《半导体物理与器件 中文版》</td>
</tr>
<tr class="even">
<td>单片机原理（MCU Principle）</td>
<td><em>The 8051 Microcontroller A Systems Approach (Mazidi, Muhammad AliMcKinlay, Rolin DMazidi etc.)</em> <br>《8051单片机系统》<br>《单片机原理及接口技术 第5版》</td>
</tr>
<tr class="odd">
<td>结构化数字设计（含FPGA）Structured Digital Design</td>
<td><em>Verilog HDL - A Guide To Digital Design And Synth<br></em>《Verilog HDL 数字设计与综合》</td>
</tr>
<tr class="even">
<td>创新项目实践（一）Practice of Innovation Project I</td>
<td><del>无课本</del></td>
</tr>
</tbody>
</table>
<h3 id="大三下学期">大三下学期：</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>第六学期课程（Curriculum in Sixth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>嵌入式微处理系统设计（Embedded Microprocessor System Design）</td>
<td><del>《嵌入式系统设计——基于STM32CubeMX与HAL库》</del></td>
</tr>
<tr class="even">
<td>通信系统（Communication Systems）</td>
<td><em>Communication Systems 4th Edition by Simon Haykin<br></em>《通信系统 中文版》<br>《通信原理 第七版》</td>
</tr>
<tr class="odd">
<td>线性控制系统（Linear Control Systems）</td>
<td><em>Communication Systems 4th Edition by Simon Haykin</em><br>参考答案</td>
</tr>
<tr class="even">
<td>电力电子（Power Electronics）</td>
<td>《电力电子技术》<br>参考答案</td>
</tr>
<tr class="odd">
<td>VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</td>
<td><em>Digital integrated circuits a design perspective</em><br>《数字集成电路——电路系统与设计 中文版》</td>
</tr>
<tr class="even">
<td>模拟集成电路（Analog Integrated Circuit）</td>
<td><em>Design of Analog CMOS Integrated Circuits by Behzad Razavi</em><br>《数字集成电路：电路、系统与设计第2版》<br></td>
</tr>
<tr class="odd">
<td>创新项目实践（二）Practice of Innovation Project II</td>
<td><del>无课本</del></td>
</tr>
</tbody>
</table>
<h1 id="电子专业课程书籍课程资源推荐">电子专业课程书籍课程资源推荐</h1>
<h2 id="来自邱金羽的推荐">——来自邱金羽的推荐</h2>
<h3 id="大一上学期-1">大一上学期：</h3>
<table>
<colgroup>
<col style="width: 43%">
<col style="width: 56%">
</colgroup>
<thead>
<tr class="header">
<th>第一学期课程（Curriculum in First Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程微积分Ⅰ（Calculus Ⅰ for Engineers）</td>
<td>课本讲的挺不错<br>入学前可以看一下 <span class="math inline">\(3Blue1Brown\)</span> 的数学频道，微积分对应为：《<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qW411N7FU">微积分的本质</a>》<br>国内常用教材为：《高等数学》<br>推荐一个写微积分比较好的知乎文章：《<a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1249046061567741952">Re:从零开始的数学世界生活</a>》，里面包括微积分、线性代数和概率论的知识</td>
</tr>
<tr class="even">
<td>线性代数导论（Introduction to Linear Algebra）</td>
<td><span class="math inline">\(3Blue1Brown\)</span> 的数学频道：《<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ys411472E">线性代数的本质</a>》</td>
</tr>
<tr class="odd">
<td>大学物理Ⅰ（University Physics Ⅰ）</td>
<td>无</td>
</tr>
<tr class="even">
<td>工程学导论Ⅰ（Introduction to Engineering Ⅰ）</td>
<td>工程学导论教学内容：Excal + Matlab + 编程基础 + CAD基础<br>Excal要求很低，会使用基本函数就行<br>Matlab很值得学习，主要包括基本的语法和绘图操作，建议跟着官网的教程学习：<a target="_blank" rel="noopener" href="https://matlabacademy.mathworks.com/details/matlab-onramp/gettingstarted">Matlba Courses</a><br>Matlab学习中实现一些小项目可以帮助自己去理解，善用谷歌搜索和官网文档解决问题<br>对电子来说编程基础与编程导论课程内容重复<br>CAD基础，课时很少，简单了解</td>
</tr>
<tr class="odd">
<td>编程导论（Introduction to Programming）</td>
<td>推荐网课：《<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ls411w7rx?spm_id_from=..search-card.all.click">C语言程序设计</a>》<br>推荐书籍：《C Primer Plus 中文版》（这本书适合作为工具书使用，其中代码写的比较规范，适合跟着敲练习）<br> 《C Primer Plus 中文版》</td>
</tr>
</tbody>
</table>
<h3 id="大一下学期-1">大一下学期：</h3>
<table>
<colgroup>
<col style="width: 46%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th>第二学期课程（Curriculum in Second Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>微积分Ⅱ和III（Calculus Ⅱ and III）</td>
<td>同上</td>
</tr>
<tr class="even">
<td>大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</td>
<td>大物二：声热光，相对没大物三的电磁重要</td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td>大物实验课比较水</td>
</tr>
<tr class="even">
<td>工程学导论Ⅱ（Introduction to Engineering Ⅱ）</td>
<td>Matlab绘图：如果大一学的好，现在应该不需要再学了<br>推荐一些博客：<br>《<a target="_blank" rel="noopener" href="http://cighao.com/2016/04/11/draw-picture-with-matlab-001-line-style/">matlab 画图</a>》<br>《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4220232.html">MATLAB学习笔记</a>》</td>
</tr>
<tr class="odd">
<td>电路原理及实验（Electrical Circuit Theory and Lab）</td>
<td>强烈推荐看完整个《电路》课本，里面很多知识很重要</td>
</tr>
<tr class="even">
<td>电路实验</td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="大二上学期-1">大二上学期：</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>第三学期课程（Curriculum in Third Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>常微分方程导论（Introduction to Ordinary Differential）</td>
<td>可以参考国内教材：《常微分方程（第三版）简明本》</td>
</tr>
<tr class="even">
<td>大学物理III及实验（University Physics III and Lab）</td>
<td>电磁部分比较难，需要认真学</td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td>比较水</td>
</tr>
<tr class="even">
<td>数据结构（Data Structures）</td>
<td>强烈推荐使用此视频入门数据结构：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fv4y1f7T1">深入浅出数据结构 - 顶尖程序员图文讲解</a><br>课程较难，需要认真学习</td>
</tr>
<tr class="odd">
<td>电子学Ⅰ及实验（Electronics Ⅰ and Lab）</td>
<td>可以使用此课程进行半导体器件的入门，比较生动：《<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qt411m7Vm">可汗学院-半导体器件</a>》<br>强烈推荐使用此课程进行学习《<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TJ411G7sk?p=1">【电子】模拟电子技术基础 上海交通大学 郑益慧主讲</a>》<br>书籍推荐：</td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td>与理论课不匹配</td>
</tr>
</tbody>
</table>
<h3 id="大二下学期-1">大二下学期：</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>第四学期课程（Curriculum in Forth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程概率基础（Introduction to Engineering Probability）</td>
<td></td>
</tr>
<tr class="even">
<td>信号与系统（Circuits，Signals and System）</td>
<td>想考高分，做好作业<br>承前是电路原理，往后是控制系统（不止）<br>想学明白一点，考虑找<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CZ4y1j7hs?spm_id_from=..search-card.all.click">祖师爷</a>吧</td>
</tr>
<tr class="odd">
<td>逻辑设计（Logic Design）</td>
<td></td>
</tr>
<tr class="even">
<td>数字设计实验（Digital Design Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>电子学Ⅱ和实验（Electronics Ⅱ and Lab）</td>
<td>强烈推荐使用此课程进行学习《<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1TJ411G7sk?p=1">【电子】模拟电子技术基础 上海交通大学 郑益慧主讲</a>》<br>书籍推荐：</td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td>有一点匹配</td>
</tr>
<tr class="odd">
<td>微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</td>
<td>学习微机原理这门课的第一件事就是扔掉学校配的课本，切忌在学懂这门课之前翻看课本<br>第二件事是买一本：《数字设计和计算机结构体系》，仔细阅读第一章和第六章，粗略阅读中间章节<br>然后找到课本，直接阅读第四章<br>然后去学习stm32课程，比较推荐这个，日后做竞赛也会用到：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1q4411d7RX?vd_source=848d96f76bd7922d39f70343e2f35a57">STM32系列视频(CubeMX+MDK5+HAL库+库函数一站式学习)</a>；除了看一些基本的操作外，还应该阅读一下这个<a target="_blank" rel="noopener" href="https://gaoyichao.com/Xiaotu/?book=stm32&amp;title=index">STM32入门</a>中的内容。<br>可以看一下我博客上的微机原理章节，目前没有整理好，只是一份复习笔记。</td>
</tr>
</tbody>
</table>
<h3 id="大三上学期-1">大三上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第五学期课程（Curriculum in Fifth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>离散时间信号与系统（Discrete-Time Signals and Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电磁场原理（Electromagnetic Field Theory）</td>
<td></td>
</tr>
<tr class="odd">
<td>固态电子学（Solid-State Electronics）</td>
<td></td>
</tr>
<tr class="even">
<td>单片机原理（MCU Principle）</td>
<td></td>
</tr>
<tr class="odd">
<td>结构化数字设计（含FPGA）Structured Digital Design</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大三下学期-1">大三下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第六学期课程（Curriculum in Sixth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>嵌入式微处理系统设计（Embedded Microprocessor System Design）</td>
<td></td>
</tr>
<tr class="even">
<td>通信系统（Communication Systems）</td>
<td></td>
</tr>
<tr class="odd">
<td>线性控制系统（Linear Control Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电力电子（Power Electronics）</td>
<td></td>
</tr>
<tr class="odd">
<td>VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</td>
<td></td>
</tr>
<tr class="even">
<td>模拟集成电路（Analog Integrated Circuit）</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="电子专业课程书籍课程资源推荐-1">电子专业课程书籍课程资源推荐</h1>
<h2 id="推荐模板">——推荐模板</h2>
<h3 id="大一上学期-2">大一上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第一学期课程（Curriculum in First Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程微积分Ⅰ（Calculus Ⅰ for Engineers）</td>
<td></td>
</tr>
<tr class="even">
<td>线性代数导论（Introduction to Linear Algebra）</td>
<td></td>
</tr>
<tr class="odd">
<td>大学物理Ⅰ（University Physics Ⅰ）</td>
<td></td>
</tr>
<tr class="even">
<td>工程学导论Ⅰ（Introduction to Engineering Ⅰ）</td>
<td></td>
</tr>
<tr class="odd">
<td>编程导论（Introduction to Programming）</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大一下学期-2">大一下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第二学期课程（Curriculum in Second Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>微积分Ⅱ和III（Calculus Ⅱ and III）</td>
<td></td>
</tr>
<tr class="even">
<td>大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td></td>
</tr>
<tr class="even">
<td>工程学导论Ⅱ（Introduction to Engineering Ⅱ）</td>
<td></td>
</tr>
<tr class="odd">
<td>电路原理及实验（Electrical Circuit Theory and Lab）</td>
<td></td>
</tr>
<tr class="even">
<td>电路实验</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大二上学期-2">大二上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第三学期课程（Curriculum in Third Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>常微分方程导论（Introduction to Ordinary Differential）</td>
<td></td>
</tr>
<tr class="even">
<td>大学物理III及实验（University Physics III and Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td></td>
</tr>
<tr class="even">
<td>数据结构（Data Structures）</td>
<td></td>
</tr>
<tr class="odd">
<td>电子学Ⅰ及实验（Electronics Ⅰ and Lab）</td>
<td></td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大二下学期-2">大二下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第四学期课程（Curriculum in Forth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程概率基础（Introduction to Engineering Probability）</td>
<td></td>
</tr>
<tr class="even">
<td>信号与系统（Circuits，Signals and System）</td>
<td></td>
</tr>
<tr class="odd">
<td>逻辑设计（Logic Design）</td>
<td></td>
</tr>
<tr class="even">
<td>数字设计实验（Digital Design Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>电子学Ⅱ和实验（Electronics Ⅱ and Lab）</td>
<td></td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td></td>
</tr>
<tr class="odd">
<td>微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大三上学期-2">大三上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第五学期课程（Curriculum in Fifth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>离散时间信号与系统（Discrete-Time Signals and Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电磁场原理（Electromagnetic Field Theory）</td>
<td></td>
</tr>
<tr class="odd">
<td>固态电子学（Solid-State Electronics）</td>
<td></td>
</tr>
<tr class="even">
<td>单片机原理（MCU Principle）</td>
<td></td>
</tr>
<tr class="odd">
<td>结构化数字设计（含FPGA）Structured Digital Design</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大三下学期-2">大三下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第六学期课程（Curriculum in Sixth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>嵌入式微处理系统设计（Embedded Microprocessor System Design）</td>
<td></td>
</tr>
<tr class="even">
<td>通信系统（Communication Systems）</td>
<td></td>
</tr>
<tr class="odd">
<td>线性控制系统（Linear Control Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电力电子（Power Electronics）</td>
<td></td>
</tr>
<tr class="odd">
<td>VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</td>
<td></td>
</tr>
<tr class="even">
<td>模拟集成电路（Analog Integrated Circuit）</td>
<td></td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://y006.github.io/2022/03/15/15-32-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="邱金羽">
      <meta itemprop="description" content="联系我：2420457716@qq.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/15/15-32-05/" class="post-title-link" itemprop="url">记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-15 15:32:05" itemprop="dateCreated datePublished" datetime="2022-03-15T15:32:05+08:00">2022-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-31 15:06:04" itemprop="dateModified" datetime="2022-03-31T15:06:04+08:00">2022-03-31</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/03/15/15-32-05/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/03/15/15-32-05/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="fpga">FPGA</h1>
<h3 id="时序约束">时序约束</h3>
<ol type="1">
<li>如通信实验，时钟频率比较高的实验，需要进行时序约束</li>
<li>当占用芯片的逻辑资源多的时候，需要使用时序约束：因为FPGA在布线时会优先考虑面积</li>
</ol>
<p>时钟约束用来描述设计人员对于时序的要求，包括时钟频率和输入输出延时</p>
<p>D触发器</p>
<p>arduino 机械臂</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Servo myservo_1;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line">Servo myservo_2;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line">Servo myservo_3;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line"><span class="type">int</span> pos_1 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"><span class="type">int</span> pos_2 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"><span class="type">int</span> pos_3 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  myservo_1.attach(<span class="number">12</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">    myservo_2.attach(<span class="number">11</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">      myservo_3.attach(<span class="number">10</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  myservo_1.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">myservo_2.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">myservo_3.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">for</span> (pos_1 = <span class="number">0</span>; pos_1 &lt;= <span class="number">10</span>; pos_1 ++) &#123; <span class="comment">// 0°到180°</span></span><br><span class="line">    <span class="comment">// in steps of 1 degree</span></span><br><span class="line">    myservo_1.write(pos_1);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">      <span class="keyword">for</span> (pos_2 = <span class="number">0</span>; pos_2 &lt;= <span class="number">60</span>; pos_2 ++) &#123; <span class="comment">// 从180°到0°</span></span><br><span class="line">    myservo_2.write(pos_2);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (pos_3 = <span class="number">0</span>; pos_3 &lt;= <span class="number">30</span>; pos_3 ++) &#123; <span class="comment">// 从180°到0°</span></span><br><span class="line">    myservo_3.write(pos_3);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">myservo_3.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">1000</span>);</span><br><span class="line">myservo_2.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">1000</span>);</span><br><span class="line">myservo_1.write(<span class="number">-5</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////  for (pos_1 = 0; pos_1 &lt;= 120; pos_1 ++) &#123; // 0°到g180°</span></span><br><span class="line"><span class="comment">////    // in steps of 1 degree</span></span><br><span class="line"><span class="comment">////    myservo_1.write(pos_1);              // 舵机角度写入</span></span><br><span class="line"><span class="comment">////    delay(5);                       // 等待转动到指定角度</span></span><br><span class="line"><span class="comment">////  &#125;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数字电路中的逻辑值">数字电路中的逻辑值：</h3>
<ul>
<li>逻辑 0：表示低电平，相当于电路 GND。</li>
<li>逻辑 1：表示高电平，相当于电路 VCC。</li>
<li>逻辑 X：表示未知，高或低。</li>
<li>逻辑 Z：表示高阻态，悬空状态</li>
</ul>
<h3 id="verilog-中的数字表示">Verilog 中的数字表示：</h3>
<p>“（数字的二进制）位宽 + 进制（缩写） + 数值”来表示一个数字。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二进制0101的表示</span></span><br><span class="line"><span class="number">4&#x27;b0101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//十进制2的表示，数字2的二进制表示为0010占4位</span></span><br><span class="line"><span class="number">4&#x27;d2</span></span><br></pre></td></tr></table></figure>
<p>Verilog 的默认二进制位宽为32位，默认的进制为十进制。</p>
<p>当二进制数字位数多的时候可以使用下划线增加可读性，编译时下划线会被去掉。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16&#x27;b1001_1010_1010_1001</span></span><br></pre></td></tr></table></figure>
<h4 id="标识符">标识符：</h4>
<p>Verilog 的标识符可以用于定义模块名、端口名和信号名。</p>
<p>Verilog 的命名规则与 C 语言变量名的命名规则基本相同：只有一点，可以在命名中包含$符号。</p>
<p>标识符规则：</p>
<ul>
<li></li>
</ul>
<p>标识符推荐写法：</p>
<ul>
<li>不建议大小写混合</li>
<li>普通内部信号全部小写</li>
<li>信号命名体现含义</li>
<li>使用下划线区分词</li>
<li>采用前后缀：比如时钟可以采用：clk_50，clk_cpu</li>
</ul>
<h3 id="数据类型">数据类型</h3>
<p>三种数据类型：</p>
<ul>
<li><p>寄存器数据类型：实际电路物理模型</p>
<ul>
<li><p>抽象数据存储单元，可以通过赋值语句改变寄存器储存的值</p></li>
<li><p>关键字：reg，默认初始值为 X 不确定</p></li>
<li><p>```verilog // reg + [位宽：31:0 指32位位宽，高位在前] + 标识符名称（寄存器名称） reg [31:0] delay_cnt; //延时计数使用的寄存器 reg key_reg; //没给位宽时默认位宽为1 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + reg 类型的数据只能在 always 语句和 initial 语句中被赋值</span><br><span class="line"></span><br><span class="line">  + 如果 always 中带有时钟信号即过程语句描述的是时序逻辑，则寄存器对应为触发器</span><br><span class="line"></span><br><span class="line">  + 如果 always 中不带有时钟信号即过程语句描述的是组合逻辑，则寄存器对应为硬件连线</span><br><span class="line"></span><br><span class="line">  + </span><br><span class="line"></span><br><span class="line">+ 线网数据类型：实际电路物理模型</span><br><span class="line"></span><br><span class="line">+ 参数数据类型：给编译器用的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 图像处理</span><br><span class="line"></span><br><span class="line">OV7725摄像头</span><br><span class="line"></span><br><span class="line">主控器控制OV7725时采用SCCB协议读写其寄存器，而它输出图像时则使用VGA或QVGA时序， 其中VGA在输出图像分辨率为480*640时采用，QVGA是Quarter VGA，其输出分辨率为240*320， 这些时序跟控制液晶屏输出图像数据时十分类似。</span><br><span class="line"></span><br><span class="line">OV7725传感器输出图像时，一帧帧地输出，在帧内的数据一般从左到右，从上到下， 一个像素一个像素地输出(也可通过寄存器修改方向)，见图 [摄像头数据输出](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#id20) 。</span><br><span class="line"></span><br><span class="line">![摄像头数据输出](记录/OV7725012.jpg)</span><br><span class="line"></span><br><span class="line">例如，见图 [像素同步时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#id21) 和图 [QVGA帧图像同步时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#qvga) ， 若我们使用D2-D9数据线，图像格式设置为RGB565，&lt;img src=&quot;记录/image-20220326130518483.png&quot; alt=&quot;image-20220326130518483&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">```verilog</span><br><span class="line">//RGB数据转换为YCBCR</span><br><span class="line">//因为FPGA处理除法是比较耗费资源的，所以我们团队采用左移右移以替代乘除法。处理整形数据可以将数据整体左移八位，再进行计算，最后在右移回去即可。</span><br><span class="line"></span><br><span class="line">Y’ = 0.257R’ + 0.504G’ + 0.098*B’ + 16</span><br><span class="line">Cb’ = -0.148R’ - 0.291G’ + 0.439*B’ + 128</span><br><span class="line">Cr’ = 0.439R’ - 0.368G’ - 0.071*B’ + 128</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<p>进行数据输出时，D2-D9数据线在PCLK在上升沿阶段维持稳定， 并且会在1个像素同步时钟PCLK的驱动下发送1字节的数据信号，所以2个PCLK时钟可发送1个RGB565格式的像素数据。 当HREF为高电平时，像素数据依次传输，每传输完一行数据时，行同步信号HREF会输出一个电平跳变信号间隔开当前行和下一行的数据； 一帧的图像由N行数据组成，当VSYNC为低电平时，各行的像素数据依次传输，每传输完一帧图像时，VSYNC会输出一个电平跳变信号。</p>
<p><img src="/2022/03/15/15-32-05/image-20220326132950059.png" alt="image-20220326132950059" style="zoom:50%;"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">rows=<span class="number">200</span></span><br><span class="line">cols=<span class="number">300</span></span><br><span class="line">num=<span class="number">2000</span> <span class="comment">#随机像素点的个数</span></span><br><span class="line">img=np.zeros((rows,cols,<span class="number">3</span>),np.uint8)</span><br><span class="line">pos1=np.random.randint(<span class="number">200</span>,size=(num,<span class="number">1</span>)) <span class="comment">#行位置随机数组</span></span><br><span class="line">pos2=np.random.randint(<span class="number">300</span>,size=(num,<span class="number">1</span>)) <span class="comment">#列</span></span><br><span class="line"><span class="comment">#随机位置处设置像素点值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">0</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">1</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">2</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">如果在OpenCV中处理图像，是BGR的顺序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">I=numpy.zeros((<span class="number">3</span>,<span class="number">3</span>),dtype=numpy.uint8) </span><br><span class="line"><span class="comment">#图片I大小为3*3，灰度值全为0，也就是黑色图像</span></span><br><span class="line">I=cv2.cvtColor(I,cv2.COLOR_GRAY2BGR)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#此时图像I变成了三个通道的每个像素点的值都为0</span></span><br><span class="line"><span class="comment">#有27个像素值，HSV色彩空间也是同样的方式，只是只是通道数不同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">emptyImage = np.zeros(img.shape, np.uint8)</span><br><span class="line">cv2.imshow(<span class="string">&quot;EmptyImage&quot;</span>, emptyImage) </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\strawberry.jpg&#x27;</span>) </span><br><span class="line">cv2.imshow(<span class="string">&quot;Image&quot;</span>, img) </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">Strawberry=cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\strawberry.jpg&#x27;</span>) </span><br><span class="line"><span class="comment">#Strawberry=cv2.imread(&quot;strawberry.jpg&quot;)</span></span><br><span class="line">Lower = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>])</span><br><span class="line">Upper = np.array([<span class="number">40</span>, <span class="number">40</span>, <span class="number">255</span>])</span><br><span class="line">Binary = cv2.inRange(Strawberry, Lower, Upper)</span><br><span class="line">cv2.imshow(<span class="string">&quot;strawberry&quot;</span>, Binary)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fruit = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\fruits.jpg&#x27;</span>)</span><br><span class="line">fruit = cv2.cvtColor(fruit,cv2.COLOR_BGR2YUV)</span><br><span class="line">Y,U,V = cv2.split(fruit)</span><br><span class="line">Blueberry = cv2.inRange(U,<span class="number">130</span>,<span class="number">255</span>)</span><br><span class="line">Strawberry = cv2.inRange(V,<span class="number">170</span>,<span class="number">255</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;blueberry&quot;</span>,Blueberry)</span><br><span class="line">cv2.imshow(<span class="string">&quot;strawberry&quot;</span>,Strawberry)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\1.jpg&#x27;</span>, cv2.IMREAD_COLOR)</span><br><span class="line">ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)</span><br><span class="line">gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">(y, cr, cb) = cv2.split(ycrcb)</span><br><span class="line">cr1 = cv2.GaussianBlur(cr, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>) </span><br><span class="line">skin1 = cv2.threshold(cr1, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image CR&quot;</span>, cr1)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Skin Cr+OSTU&quot;</span>, skin1)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cr_otsu1</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;YCrCb颜色空间的Cr分量+Otsu阈值分割</span></span><br><span class="line"><span class="string">    :param image: 图片路径</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>, cv2.IMREAD_COLOR)</span><br><span class="line">ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)</span><br><span class="line"></span><br><span class="line">(y, cr, cb) = cv2.split(ycrcb)</span><br><span class="line">cr1 = cv2.GaussianBlur(cr, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">_, skin = cv2.threshold(cr1, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;image raw&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image raw&quot;</span>, img)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;image CR&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image CR&quot;</span>, cr1)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;Skin Cr+OTSU&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Skin Cr+OTSU&quot;</span>, skin)</span><br><span class="line"></span><br><span class="line">dst = cv2.bitwise_and(img, img, mask=skin)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;seperate&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;seperate&quot;</span>, dst)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="灰度化">灰度化</h3>
<p>转换色彩空间：</p>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用Opencv进行色彩空间的转换</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\name_of_picture&#x27;</span>)</span><br><span class="line">img_ycbcr = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)</span><br><span class="line"><span class="comment">#img_YUV = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)</span></span><br><span class="line"><span class="comment">#img_hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, img_ycbcr)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>以RGB格式的彩图为例，通常灰度化采用的方法主要有：</p>
<p>方法1：<span class="math inline">\(Gray=(R+G+B)/3\)</span></p>
<p>方法2：<span class="math inline">\(Gray=max(R,G,B)\)</span></p>
<p>方法3：<span class="math inline">\(Gray=0.299R+0.587G+0.114B\)</span>（这种参数考虑到了人眼的生理特点）</p>
<p>所谓阈值处理，就是给定一个阈值，当像素值比指定阈值大或小时做相关的操作。==这个字念yu，不是fa==，方法签名为:<code>cv2.threshold(src,thresh,maxval,type,dst=None)</code>,需要将的是OpenCV中提供的几种type：</p>
<ul>
<li>cv2.THRESH_BINARY：若像素值大于阈值，则置为maxval；否则置0</li>
<li>cv2.THRESH_BINARY_INV：THRESH_BINARY的反转</li>
<li>cv2.THRESH_TRUNC：若像素值大于阈值，则置为阈值；否则不变</li>
<li>cv2.THRESH_TOZERO：小于阈值的部分置为0；其他不变</li>
<li>cv2.THRESH_TOZERO_INV：THRESH_TOZERO的反转</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, thresh1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">_, thresh2 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY_INV)</span><br><span class="line">_, thresh3 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TRUNC)</span><br><span class="line">_, thresh4 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TOZERO)</span><br><span class="line">_, thresh5 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TOZERO_INV)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#固定阈值的二值化处理</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">threshold_value = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> threshold_value &lt; <span class="number">255</span>:</span><br><span class="line">    <span class="keyword">if</span> threshold_value &gt; <span class="number">255</span>:</span><br><span class="line">        threshold_value = <span class="number">255</span></span><br><span class="line">    _, thresh1 = cv2.threshold(img, threshold_value, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, thresh1)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    threshold_value = threshold_value + <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>选则合适的阈值筛选不同的色块，链接下文轮廓识别</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用Opencv进行色彩空间的转换</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">threshold_value = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> threshold_value &lt; <span class="number">255</span>:</span><br><span class="line">    <span class="keyword">if</span> threshold_value &gt; <span class="number">255</span>:</span><br><span class="line">        threshold_value = <span class="number">255</span></span><br><span class="line">    _, thresh1 = cv2.threshold(img, threshold_value, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, thresh1)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    threshold_value = threshold_value + <span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#自适应阈值二值化处理</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"></span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, th1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">th2 = cv2.adaptiveThreshold(img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="number">11</span>, <span class="number">2</span>)</span><br><span class="line">th3 = cv2.adaptiveThreshold(img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="number">11</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th1)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th2)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th3)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="腐蚀">腐蚀</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;i.png&quot;</span>)</span><br><span class="line">img_noise = copy.deepcopy(img)</span><br><span class="line"><span class="comment"># add some noise to original image</span></span><br><span class="line">rows, cols = img_noise.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">	i = random.randint(<span class="number">0</span>, rows - <span class="number">1</span>)</span><br><span class="line">	j = random.randint(<span class="number">0</span>, cols - <span class="number">1</span>)</span><br><span class="line">	img_noise[i, j] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), dtype=np.uint8)</span><br><span class="line">erosion = cv2.erode(img_noise, kernel)</span><br><span class="line">dilation = cv2.dilate(erosion, kernel)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">im = cv2.imread(<span class="string">&#x27;rectangle.jpg&#x27;</span>)</span><br><span class="line">imgray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(imgray, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;一共检测到%d个轮廓&quot;</span> % <span class="built_in">len</span>(contours))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第%d个轮廓:&quot;</span> % (i + <span class="number">1</span>))</span><br><span class="line">	<span class="built_in">print</span>(contours[i])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># -1 代表画出所有轮廓</span></span><br><span class="line">res = cv2.drawContours(im, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, res)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_contours_of_binary_image</span>():</span><br><span class="line">	im = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>)</span><br><span class="line">	imgray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</span><br><span class="line">	ret, thresh = cv2.threshold(imgray, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;一共检测到%d个轮廓&quot;</span> % <span class="built_in">len</span>(contours))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;第%d个轮廓:&quot;</span> % (i + <span class="number">1</span>))</span><br><span class="line">		<span class="built_in">print</span>(contours[i])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># -1 代表画出所有轮廓</span></span><br><span class="line">	res = cv2.drawContours(im, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">3</span>)</span><br><span class="line">   	img_show(res)</span><br><span class="line">    </span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>轮廓检测能用代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">kernel = np.ones((<span class="number">1</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\1.jpg&#x27;</span>)  </span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  </span><br><span class="line">ret, binary = cv2.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)  </span><br><span class="line">binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel, anchor=(<span class="number">2</span>, <span class="number">0</span>), iterations=<span class="number">5</span>)</span><br><span class="line">contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  </span><br><span class="line">cv2.drawContours(img,contours,-<span class="number">1</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)  </span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)  </span><br><span class="line">cv2.waitKey(<span class="number">0</span>)  </span><br></pre></td></tr></table></figure>
<p>能看懂的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#调节二值化的阈值可以描出不同的色块</span></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>)  </span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  </span><br><span class="line">ret, binary = cv2.threshold(gray,<span class="number">100</span>,<span class="number">255</span>,cv2.THRESH_BINARY)  </span><br><span class="line">contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  </span><br><span class="line">cv2.drawContours(img,contours,-<span class="number">1</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)  </span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)  </span><br><span class="line">cv2.waitKey(<span class="number">0</span>)  </span><br></pre></td></tr></table></figure>
<h3 id="二值化">二值化</h3>
<p>二值图也就是黑白图。将灰度图转换成黑白图的过程，就是二值化。二值化的一般算法是：</p>
<p><span class="math inline">\(g={0,f≤t1,f&gt;t}\)</span></p>
<p>其中t被称为阀值。阀值的确定方法有下面几种。</p>
<h2 id="otsu法大津法或最大类间方差法">Otsu法（大津法或最大类间方差法）</h2>
<p>来自霓虹国的大津展之为这种波谷找到了一个合适的数学表达，并于 1979 年发表论文[2]。这个二值化方法称为<strong>大津算法（Otsu’s method）</strong>。</p>
<p>大津算法就是，<strong>从 1 到 255 一个个数字试，找到一个数字能够把两个波峰切开</strong>，让两个波峰内部的类内方差之和最小。类内方差之和就是，单独求这两个波峰各自的方差，乘上波峰的占比权重，然后加起来。</p>
<p>这个数字就能最好的把图像分开，<strong>对应的就是双峰直方图中的波谷</strong>。这个算法最多只需遍历两次直方图数组，速度飞快，至今仍被广泛应用。</p>
<p>图像比较复杂的时候，我们对大津算法稍加扩展也可以完成分割。对大津算法的多级推广成为<strong>多大津算法（multi Otsu method） [3]</strong>。</p>
<p>*这里提到的是局部阈值的基本方法，对于实际使用中常见的其他局部阈值方法，请参阅<strong>Chow-Kaneko 自适应阈值法 [4]</strong>。</p>
<p>局部阈值的应用非常广泛，特别是对白纸黑字的处理非常有效。光学字符识别（OCR）和二维码扫描的算法中，很多都用了局部阈值操作。比如下面这张受光不均的二维码。</p>
<p>该算法是一种动态阈值分割算法。它的主要思想是按照灰度特性将图像划分为背景和目标2部分（这里我们将f≤t的部分称为背景，其他部分称为目标。），选取门限值，使得背景和目标之间的方差最大。</p>
<blockquote>
<p>注：Nobuyuki Otsu（大津展之），东京大学博士，先后在筑波大学和东京大学担任教授。</p>
</blockquote>
<p>其步骤如下：</p>
<p>1.建立图像灰度直方图。</p>
<p>2.计算背景和目标的出现概率。</p>
<p><span class="math inline">\(pA=∑i=0tpi,pB=∑i=t+1L−1pi=1−pA\)</span></p>
<p>其中，A和B分别表示背景部分和目标部分。</p>
<p>3.计算A和B两个区域的类间方差。</p>
<p><span class="math inline">\(公式ωA=∑i=0tipipA,ωB=∑i=t+1L−1ipipB(公式1)\)</span></p>
<p>公式1分别计算A和B区域的平均灰度值；</p>
<p>公式<span class="math inline">\(ω0=pAωA+pBωB=∑i=0L−1ipi\)</span>(公式2)</p>
<p>公式2计算灰度图像全局的灰度平均值；</p>
<p>公式<span class="math inline">\(σ2=pA(ωA−ω0)2+pB(ωB−ω0)2\)</span>(公式3)</p>
<p>公式3计算A、B两个区域的类间方差。</p>
<p>4.针对每一个灰度值，计算类间方差。选择方差最大的灰度值，作为阀值t。</p>
<p>下面是几个在使用opencv作轮廓检测时需要注意的点：</p>
<ul>
<li>为了更精确地提取轮廓，请使用二值图。也就是说，在使用轮廓提取函数前，请将源图片运用阈值进行<code>二值化(cv2.threshold())</code>或者采用<code>Canny边缘检测</code>。</li>
<li>findContours 函数会修改源图片，如果希望在轮廓检测后继续使用源图片，务必提前保存在另一个变量中。</li>
<li>在OpenCV中，轮廓检测视作从黑色背景中提取白色的物体，所以，在结果中，白色表示物体，黑色表示背景。</li>
</ul>
<p><em>提取轮廓的步骤大概会是这样子：</em></p>
<ol type="1">
<li>读取源图片，并转化为灰度图</li>
<li>运用threshold将灰度图片二值化（也可以使用Canny边缘检测）</li>
<li>使用<code>findContours()函数</code>找到所有的轮廓</li>
<li>使用<code>drawContours()函数</code>将轮廓画出来</li>
</ol>
<p>https://gy23333.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</p>
<h2 id="图像处理">图像处理</h2>
<h3 id="形态学">形态学</h3>
<h4 id="膨胀">膨胀</h4>
<h5 id="简介">简介</h5>
<p>膨胀是数学形态学的两种基本运算之一，腐蚀是另一种基本运算。它通常应用于二值图像，但也有适用于灰度图像的版本。该算子对二值图像的基本作用是逐渐扩大前景像素(通常为白色像素)区域的边界。因此，前景像素的区域会增大，而这些区域内的孔会变小。</p>
<h5 id="它是如何运作的">它是如何运作的</h5>
<p>这个描述的有用背景在词汇表的数学形态学部分给出。</p>
<p>膨胀运算符接受两段数据作为输入。首先是要放大的图像。第二个是一组坐标点(通常很小)，称为结构元素(也称为内核)。正是这个构造元素决定了输入图像的精确膨胀效果。</p>
<p>二值图像膨胀的数学定义如下：</p>
<p>设X为输入二值图像对应的欧几里德坐标集，K为构造元素的坐标集。</p>
<p>Kx表示K的平移使其原点在x处。</p>
<p>那么X乘以K的膨胀就是所有点X的集合使得Kx与X的交点非空。</p>
<p>除了与输入图像相关联的一组坐标的导出方式之外，灰度膨胀的数学定义是相同的。此外，这些坐标是三维的，而不是二维的。</p>
<p>作为二元扩张的一个例子</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/default-index/page/2/">2</a><a class="page-number" href="/default-index/page/3/">3</a><a class="extend next" rel="next" href="/default-index/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">邱金羽</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"Bolgqjy","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
