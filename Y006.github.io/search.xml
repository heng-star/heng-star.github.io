<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VScode配置笔记</title>
    <url>/2022/02/20/22-32-35/</url>
    <content><![CDATA[<h2 id="vscode配置笔记">VScode配置笔记</h2>
<ol type="1">
<li><p>下载并安装编译器MinGW：https://bit.ly/mingw10</p></li>
<li><p>将MinGW的bin文件路径添加到系统环境变量中</p></li>
<li><p>在cmd中运行</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">g++ --version</span><br></pre></td></tr></table></figure>
<p>检测是否成功配置路径</p></li>
<li><p>安装VScode：<a href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a></p></li>
<li><p>“设置”中输入"run in terminal"<img src="/2022/02/20/22-32-35/image-20210907225325312.png" alt="image-20210907225325312"></p></li>
<li><p>安装插件”Code Runner“和”C/C++“；选装”Chinese (Simplified) Language Pack for Visual Studio Code“</p></li>
<li><p>为了正确地在文本编辑器上敲除中文，需要给文本编辑器设置合适的编码方式：<img src="/2022/02/20/22-32-35/Users\qjy\AppData\Roaming\Typora\typora-user-images\image-20210916093752004.png" alt="image-20210916093752004"></p>
<p>点红框，选择“通过编码重新打开”，输入编码方式即可。</p>
<p>打开cmd，查看“属性”可得知终端的编码方式</p>
<p><img src="/2022/02/20/22-32-35/image-20210916093952277.png" alt="image-20210916093952277" style="zoom:25%;"></p>
<p>终端的编码方式需要与编辑器的编码方式匹配</p>
<p>在终端输入：“chcp 65001”可以切换代码页到使用UTF8。</p></li>
<li><p>想要正确识别别人代码中的中文，需要“设置”中输入"<strong>files.autoGuessEncoding</strong>"<img src="/2022/02/20/22-32-35/image-20210907225635399.png" alt="image-20210907225635399"></p></li>
<li><p>设置自动保存：“设置“中输入”<strong>auto save</strong>“，选择"afterDelay"选项</p></li>
<li><p>設置自動格式化：“设置”中输入“<strong>editor.formatOnType</strong>”，选择True“</p></li>
<li><p>”ctrl+k“配合”ctrl+t“可快速切换主题</p></li>
<li><p>”ctrl+“是放大</p></li>
<li><p>单行注释：“Ctrl + /”；块注释：“Alt+Shift+A”</p></li>
<li><p>多文件编译：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#code in CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the project name</span></span><br><span class="line"><span class="keyword">project</span>(Tutorial)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(Tutorial tutorial.cxx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output in Chinese</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -Wall -fexec-charset=GB2312&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="补充终端shell命令">补充：终端（shell）命令</h2>
<p>不区分大小写。</p>
<p>tab键补全内容，再次点击切换内容</p>
<h3 id="文件跳转">文件跳转</h3>
<p>磁盘跳转</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">D:</span></span><br></pre></td></tr></table></figure>
<p>显示所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir</span><br></pre></td></tr></table></figure>
<p>树形显示所有文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tree</span><br></pre></td></tr></table></figure>
<p>进入下一级文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 文件名（有空格的夹引号，平时使用tab补全就好）</span><br></pre></td></tr></table></figure>
<p>进入上一级文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd..</span><br></pre></td></tr></table></figure>
<p>退回磁盘根目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd/</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>备忘笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/02/11/16-23-37/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Homework</title>
    <url>/2022/02/24/11-07-35/</url>
    <content><![CDATA[<h2 id="homework">Homework</h2>
<h3 id="home-work">1-Home work</h3>
<p>1.d 2.c 3.a 4.a</p>
<h3 id="home-work-1">2-Home work</h3>
<p>1.b 2.c</p>
<ol start="3" type="1">
<li>Differentiate between insulator, semiconductor and conductor?
<ul>
<li>Insulator : Don't allow the current to pass through.</li>
<li>Semiconductor : have a conductivity between conductors and insulators.</li>
<li>Condctior : Allow the current and heat to pass through.</li>
</ul></li>
<li>What is forbidden energy gap?
<ul>
<li>The bandgap btewenn conduction band and valence band is called forbidden energy gap.</li>
</ul></li>
<li>How does the band gap indicate whether or not your substance is an insulator, semiconductor or conductor?
<ul>
<li>The bandgap of the insulator is very high;</li>
<li>The bandgap of the semiconductor is low;</li>
<li>There is no band gap in the conductor</li>
</ul></li>
</ol>
<h3 id="home-work-2">3-Home work</h3>
<ol type="1">
<li><p>Define doping?</p>
<ul>
<li>The process by which an impurity is added to a semiconductor is known as Doping.</li>
</ul></li>
<li><p>What is difference between a pentavalent atom and a trivalent impurity?</p>
<ul>
<li>They have different numbers of outermost electrons.</li>
<li>Pentavalent atoms have 5 valence electrons; Trivalent atoms have 3 valence electrons.</li>
</ul></li>
<li><p>How is an n-type semiconductor formed? Is N-type material electrically neutral? Comment.</p>
<ul>
<li>N-type semiconductors are formed by adding pentavalent impurity.</li>
<li>N-type material is electrically neutral.</li>
</ul></li>
<li><p>How is an p-type semiconductor formed?</p>
<ul>
<li>N-type semiconductors are formed by adding trivalent impurity.</li>
</ul></li>
<li><p>What is difference between intrinsic and extrinsic semiconductor?</p>
<ul>
<li>Intrinsic semiconductors are pure and there are no impurities in it.</li>
<li>Extrinsic semiconductor aren't pure and there are some impurities in it.</li>
</ul></li>
<li><p>c</p></li>
</ol>
<h3 id="home-work-3">4-Home work</h3>
<ol type="1">
<li>Calculate.</li>
<li>Calculate.</li>
<li>Calculate.</li>
</ol>
<h3 id="home-work-4">5-Home work</h3>
<ol type="1">
<li><p>Calculate.</p></li>
<li><p>Describe the Avalanche and Zener breakdown mechanism in diode.</p>
<ul>
<li><p>Avalanche breakdown:</p>
<p>If high reverse bias voltage is applied to a lightly doped diode, then the minority carriers will move to the PN junction with high velocity and collide with atoms in the depletion region and break the covalent bond.This cumulative process eventually leads current increase suddenly in the device. The phenomena is called avalanche breakdown.</p></li>
<li><p>Zener breakdown:</p>
<p>The depletion width in heavily doped diodes is very narrow, which develops high electric field across the depletion region under reverse voltage. In this case, the covalent bond is disrupted in the depletion region and more and more electrons are liberated. So the current increases repidly in the diode. The phenomena is called Zener breakdown.</p>
<p>The depletion widthe is very narrow in heavily doped diodes, resulting in a large electric field in the depletion region when reverse voltage is applied</p></li>
</ul></li>
<li><p>Draw.</p></li>
<li><p>Differentiate between Zener diode and PN junction normal diode. Also, explain how Zener breakdown differs from Avalanche breakdown.</p>
<ul>
<li><p>Compared with ordinary diodes, Zener diodes are heavily doped diodes, and Zener diodes work in the state of reverse breakdown.</p></li>
<li><p>Avalanche breakdown</p>
<ol type="1">
<li>lightly doped.</li>
<li>Depletion width is wide.</li>
<li>Electric field is weaker in the depletion region as compared to Zener breakdown.</li>
<li>Breakdown voltage is more than 8 V.</li>
<li>Avalanche breakdown occurs due to collision of electron with atoms in the depletion region.</li>
</ol></li>
<li><p>Avalanche breakdown</p>
<ol type="1">
<li>highly doped.</li>
<li>Depletion width is thin.</li>
<li>Electric field is stronger in the depletion region as compared to Avalanche breakdown.</li>
<li>Breakdown voltage is between 5V to 8V.</li>
<li>Zener breakdown occurs Due to rupture of covalent bond in the depletion region since electric field is very strong.</li>
</ol></li>
</ul></li>
</ol>
<h3 id="home-work-5">6-Home work</h3>
<ol type="1">
<li>Draw:
<ul>
<li><span class="math inline">\(AC \Rightarrow Transform \Rightarrow Rectifier \Rightarrow Filter \Rightarrow Regulator \Rightarrow DC\)</span></li>
</ul></li>
<li>Explain the basic circuit operation of half wave rectifier.
<ul>
<li>In half wave rectifier circuit, when the AC voltage is positive, the diode is forward biased so the current will pass through the circuit. when the AC voltage is negatve, the diode is reverse biased and the current can't pass through the circuit. Hence only positive half of the signal can pass through the circuit and the other half is zero.</li>
</ul></li>
<li>Calcution.</li>
</ol>
<h3 id="home-work-6">7-Home work</h3>
<ol type="1">
<li>Why half-wave rectifiers are generally not used in dc power supply？
<ul>
<li>Its efficiency is low and its ripple factor is high.</li>
</ul></li>
<li>Define ripple in a rectifier circuit.
<ul>
<li>The AC harmonics in DC are called ripple. And we have full wave rectifier as an substitute.</li>
</ul></li>
<li>Calculate.</li>
<li>Draw.</li>
<li>Calculate.</li>
</ol>
<h3 id="home-work-7">8-Home work</h3>
<ol type="1">
<li>What are the bias voltage that need to be applied to an NPN transistor such that the transistor is biased in the forward active mode？
<ul>
<li>The input voltage should exceed cut-in voltage and make transisitor biased in the forward active region.</li>
</ul></li>
<li>What is the necessity of biasing a transistor circuit.State different types.
<ul>
<li>To achieve faithful amplification, the input voltage should exceed cut-in voltage and the transistor should be in the active region, so we need biasing to set the operating point.</li>
<li>Fixed bias, Emitter bias, collector feedback bias and voltage divider bias.</li>
</ul></li>
<li>Define common base,common emitter and common current gain.
<ul>
<li>Equation.</li>
</ul></li>
<li>Define the Parameters that define a load line.define Q-point and it's significance in details. （i）Q-point region near cut off point （ii）Q-point near saturation region （iii）Q-point in the middle of the load line
<ul>
<li>The load line is jointly determined by Vcc and Rc, and the Q point is at the midpoint of the load line</li>
<li>if the Q point is close to the saturation area or the cut-off area, the output signal will be clipped</li>
<li>and if it is in the amplification area, a stable waveform can be output</li>
</ul></li>
<li>Mention the parameters that can cause shift in Q point in transistor circuit.
<ul>
<li><span class="math inline">\(I_B\)</span> and <span class="math inline">\(R_C\)</span></li>
</ul></li>
<li>Define Thermal Runaway in transistor and how to mitigate
<ul>
<li>Negative feedback and heat sink.</li>
</ul></li>
</ol>
<h2 id="assignment">Assignment</h2>
<ol type="1">
<li><p>Define intrinsic and extrinsic semiconductor. Also describe need of trivalent and pentavalent imurities in semiconductor.</p>
<ul>
<li>Intrinsic semiconductors are pure and there are no impurities in it.</li>
<li>Extrinsic semiconductor aren't pure and there are some impurities in it.</li>
<li>N-type semiconductors are formed by adding pentavalent imurities and P-type semiconductors are formed by adding trivalent imurities.</li>
</ul></li>
<li><p>Explain P-N junction under no-bias, forward bias and reverse bias conditions.</p>
<ul>
<li>The concentration gradient lets the PN junction forms a diffusion current, resulting in a built-in electric field. When the built-in electric field and the concentration gradient reach equilibrium, the diffusion stops and a depletion layer is formed.</li>
<li>When the PN junction is forward biased, the depletion width reduce and the balance between the built-in electric field and the concentration gradient is destroyed. The diffusion current continues to flow from the N-side to the P-side.</li>
<li>When the PN junction is reverse biased, the depletion width increase and diffusion current is further suppressed. Only drift current exists when reverse biased.</li>
</ul></li>
<li><p>Define Knee voltage, reverse saturation current and Breakdown voltage.</p>
<ul>
<li>Knee voltage: The forword bias voltage at which current increase through diode rapidly.</li>
<li>Reverse saturation current: Current due to minority carrier drift during reverse bias.</li>
<li>Breakdown voltage: The reverse bias voltage at which current increase through diode rapidly.</li>
</ul></li>
<li><p>Explain the basic concept of mass-action law in semiconductor and <strong>Calculate</strong>.</p>
<ul>
<li>The product of electron and hole concentrations in thermal equilibrium is equal to the square of the intrinsic carrier concentration</li>
</ul></li>
<li><p>Draw.</p></li>
<li><p>Describe the current flow mechanism in NPN transistor. Also compare the input and output characteristics of C-B,C-E and C-C.</p>
<ul>
<li><p>Transistor is used as an amplofying device when EB is forward biased and CB is reverse biased. When EB is forward biased, the electrons move from E into C through B, which formed the emitter current. The hole move from B into E and the hole move from wire into the B formed the base current. The electrons move form E into the C and the reverse current due to the reverse bias of CB formed the collector current.</p></li>
<li><table>
<thead>
<tr class="header">
<th></th>
<th>CB</th>
<th>CC</th>
<th>CE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>输入电阻</td>
<td>minimum</td>
<td>maximum</td>
<td>medium</td>
</tr>
<tr class="even">
<td>输出电阻</td>
<td>same to CE</td>
<td>minimum</td>
<td>same to CB</td>
</tr>
<tr class="odd">
<td>放大情况</td>
<td>only amplified voltage</td>
<td>only amplified current</td>
<td>both</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li><p>What is the necessity of biasing in a transistor. State different types biasing in detail.</p>
<ul>
<li>Find operating points for faithful amplification.</li>
<li>Fixed bias:
<ul>
<li>include R_B, R_C and V_{CC}, simple but unstable.</li>
</ul></li>
<li>Emitter bias:
<ul>
<li>Introduce an additional R_E and makes it more stable.</li>
</ul></li>
<li>Voltage divider bias:
<ul>
<li>A voltage divider resistor is used for a more stable effect.</li>
</ul></li>
</ul></li>
<li><p>Calculate.</p></li>
<li><p>Calculate.</p></li>
<li><p>Calculate.</p></li>
<li><ol type="a">
<li>Explain the basic construction, operation and characteristics of N-channel JFET. Also explain the input and output transfer characteristics. If we apply positive VGS to the JFET what will happen with the device?</li>
<li>Draw.</li>
</ol>
<ul>
<li>The main body of an n-channel JFET is an N-type semiconductor, and P-type semiconductors are embedded on both sides to form an n-channel. The top of the N-channel is the drain, the bottom is the source, and the left and right P-type semiconductors are connected to the gate.</li>
<li>The gate controls the voltage across this drain and source</li>
<li>The most important feature is the high input impedance</li>
</ul></li>
<li><p>Compare BJT and JFET.</p>
<ul>
<li><table>
<thead>
<tr class="header">
<th>比较内容</th>
<th>BJT</th>
<th>JFET</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>construction</td>
<td>NPN &amp; PNP</td>
<td>N-channal &amp; P-channal</td>
</tr>
<tr class="even">
<td>current carrier</td>
<td>majorities diffusion<br>minorities drift</td>
<td>majorities diffusion</td>
</tr>
<tr class="odd">
<td>Input</td>
<td>current</td>
<td>voltage</td>
</tr>
<tr class="even">
<td>contralled virable</td>
<td><span class="math inline">\(\beta\)</span></td>
<td><span class="math inline">\(g_m\)</span></td>
</tr>
<tr class="odd">
<td>sensitivity to the temperature</td>
<td>high</td>
<td>low</td>
</tr>
<tr class="even">
<td>stability</td>
<td>bad</td>
<td>good</td>
</tr>
<tr class="odd">
<td>input resistance</td>
<td>small</td>
<td>large</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li><ol type="a">
<li>Describe the operation and charcteristics of the inverting and Non-inverting amplifier.</li>
<li>Draw.</li>
</ol>
<ul>
<li>The amplifier which has 180 degrees out of phase output with respect to input is known as an inverted amplifier,</li>
<li>whereas the amplifier which has the o/p in phase with respect to i/p is known as a non-inverting amplifier.</li>
</ul></li>
<li><p>What is the concept of virtual ground?</p>
<ul>
<li>A node of a circuit that is maintained at a steady reference potential, without being connected directly to the reference potential.</li>
</ul></li>
</ol>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/29/16-12-02/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">clc; </span><br><span class="line">close all; </span><br><span class="line">clear all; </span><br><span class="line">I=imread(&#x27;2019050913413134.png&#x27;);%要求你.m文件下有test.bmp这个图像文件 </span><br><span class="line">PR=I(:,:,1);%提取红色分量 </span><br><span class="line">PG=I(:,:,2);%提取绿色分量 </span><br><span class="line">PB=I(:,:,3);%提取蓝色分量 </span><br><span class="line"> </span><br><span class="line">figure; </span><br><span class="line">subplot(2,2,1);imshow(I);title(&#x27;原图像&#x27;); </span><br><span class="line">subplot(2,2,2);imshow(PR);title(&#x27;提取红分量后&#x27;); </span><br><span class="line">subplot(2,2,3);imshow(PG);title(&#x27;提取绿色分量后&#x27;); </span><br><span class="line">subplot(2,2,4);imshow(PB);title(&#x27;提取蓝色分量后&#x27;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">I=imread(&#x27;2019050913413134.png&#x27;); </span><br><span class="line">[m,n,d]=size(I); </span><br><span class="line"> </span><br><span class="line">level=15;%设置阈值 </span><br><span class="line">level2=70;%设置阈值 </span><br><span class="line"> </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,1)-I(i,j,2)&gt;level2)&amp;&amp;(I(i,j,1)-I(i,j,3)&gt;level2)) </span><br><span class="line">            r(i,j,1)=I(i,j,1); </span><br><span class="line">            r(i,j,2)=I(i,j,2); </span><br><span class="line">            r(i,j,3)=I(i,j,3); </span><br><span class="line">       else  </span><br><span class="line">            r(i,j,1)=255; </span><br><span class="line">            r(i,j,2)=255; </span><br><span class="line">            r(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">figure; </span><br><span class="line">subplot(2,2,1);imshow(I);title(&#x27;原图像&#x27;); </span><br><span class="line">subplot(2,2,2);imshow(r);title(&#x27;提取红分量后&#x27;);%显示提取红分量后的图 </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">%提取绿分量，不满足阈值的变为白色 </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,2)-I(i,j,1)&gt;level)&amp;&amp;(I(i,j,2)-I(i,j,3)&gt;level)) </span><br><span class="line">            g(i,j,1)=I(i,j,1); </span><br><span class="line">            g(i,j,2)=I(i,j,2); </span><br><span class="line">            g(i,j,3)=I(i,j,3); </span><br><span class="line">        else </span><br><span class="line">            g(i,j,1)=255; </span><br><span class="line">            g(i,j,2)=255; </span><br><span class="line">            g(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">subplot(2,2,3);imshow(g);title(&#x27;提取绿分量后&#x27;); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">%提取蓝色分量 </span><br><span class="line">for i=1:m </span><br><span class="line">    for j=1:n </span><br><span class="line">        if((I(i,j,3)-I(i,j,1)&gt;level)&amp;&amp;(I(i,j,3)-I(i,j,2)&gt;level)) </span><br><span class="line">                    b(i,j,1)=I(i,j,1); </span><br><span class="line">                    b(i,j,2)=I(i,j,2); </span><br><span class="line">                    b(i,j,3)=I(i,j,3); </span><br><span class="line">        else </span><br><span class="line">            b(i,j,1)=255; </span><br><span class="line">            b(i,j,2)=255; </span><br><span class="line">            b(i,j,3)=255; </span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">end </span><br><span class="line"> </span><br><span class="line">subplot(2,2,4);imshow(b);title(&#x27;提取蓝色分量后&#x27;);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%清空变量，读取图像</span></span><br><span class="line">RGB = imread(<span class="string">&#x27;2019050913413134.png&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;process&#x27;</span>),</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(RGB),title(<span class="string">&#x27;原始RGB&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%convert frame from RGB to YCBCR colorspace（转换到YCBCR空间）</span></span><br><span class="line">YCBCR = rgb2ycbcr(RGB);</span><br><span class="line">whos,</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(YCBCR),title(<span class="string">&#x27;YCBCR&#x27;</span>),</span><br><span class="line"><span class="comment">%filter YCBCR image between values and store filtered image to threshold</span></span><br><span class="line"><span class="comment">%matrix（用各个通道的阈值对其进行二值化处理）</span></span><br><span class="line">Y_MIN = <span class="number">0</span>;  Y_MAX = <span class="number">256</span>;</span><br><span class="line">Cb_MIN = <span class="number">100</span>;   Cb_MAX = <span class="number">127</span>;</span><br><span class="line">Cr_MIN = <span class="number">138</span>;   Cr_MAX = <span class="number">170</span>;</span><br><span class="line">threshold=roicolor(YCBCR(:,:,<span class="number">1</span>),Y_MIN,Y_MAX)&amp;roicolor(YCBCR(:,:,<span class="number">2</span>),Cb_MIN,Cb_MAX)&amp;roicolor(YCBCR(:,:,<span class="number">3</span>),Cr_MIN,Cr_MAX);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),imshow(threshold),title(<span class="string">&#x27;YCBCR二值化&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%perform morphological operations on thresholded image to eliminate noise</span></span><br><span class="line"><span class="comment">%and emphasize the filtered object(s)（进行形态学处理：腐蚀、膨胀、孔洞填充）</span></span><br><span class="line">erodeElement = strel(<span class="string">&#x27;square&#x27;</span>, <span class="number">3</span>) ;</span><br><span class="line">dilateElement=strel(<span class="string">&#x27;square&#x27;</span>, <span class="number">8</span>) ;</span><br><span class="line">threshold = imerode(threshold,erodeElement);</span><br><span class="line">threshold = imerode(threshold,erodeElement);</span><br><span class="line">threshold=imdilate(threshold, dilateElement);</span><br><span class="line">threshold=imdilate(threshold, dilateElement);</span><br><span class="line">threshold=imfill(threshold,<span class="string">&#x27;holes&#x27;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>),imshow(threshold),title(<span class="string">&#x27;形态学处理&#x27;</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">%获取区域的&#x27;basic&#x27;属性， &#x27;Area&#x27;, &#x27;Centroid&#x27;, and &#x27;BoundingBox&#x27; </span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;处理结果&#x27;</span>),</span><br><span class="line">stats = regionprops(threshold, <span class="string">&#x27;basic&#x27;</span>);</span><br><span class="line">[C,area_index]=<span class="built_in">max</span>([stats.Area]);</span><br><span class="line"><span class="comment">%定位脸部区域</span></span><br><span class="line">face_locate=[stats(area_index).Centroid(<span class="number">1</span>),stats(area_index).Centroid(<span class="number">2</span>)];</span><br><span class="line">imshow(RGB);title(<span class="string">&#x27;after&#x27;</span>),<span class="built_in">hold</span> on</span><br><span class="line">text(face_locate(<span class="number">1</span>),face_locate(<span class="number">2</span>)<span class="number">-40</span>,  <span class="string">&#x27;face&#x27;</span>,<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(face_locate(<span class="number">1</span>),face_locate(<span class="number">2</span>), <span class="string">&#x27;b*&#x27;</span>);</span><br><span class="line">rectangle(<span class="string">&#x27;Position&#x27;</span>,[stats(area_index).BoundingBox],<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;--&#x27;</span>,<span class="string">&#x27;EdgeColor&#x27;</span>,<span class="string">&#x27;r&#x27;</span>),</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>信号与系统</title>
    <url>/2022/02/27/16-42-18/</url>
    <content><![CDATA[<h2 id="信号">信号</h2>
<h3 id="常见的奇异信号">常见的奇异信号</h3>
<p>奇异信号：函数中包含不连续点或其微分与积分有不连续点的函数，统称为奇异函数，也就是奇异信号。</p>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 70%">
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>函数表达式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(f(t)\)</span>：单位斜变信号</td>
<td><span class="math inline">\(f(t) = \begin{cases} 0 &amp; t&lt;0 \\\\ t &amp; t\ge0 \\ \end{cases}\)</span></td>
</tr>
<tr class="even">
<td>$ u(t)$：单位阶跃信号</td>
<td><span class="math inline">\(u(t) = \begin{cases} 0 &amp; t&lt;0 \\\\ 1 &amp; t&gt;0 \\ \end{cases}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\delta(t)\)</span>：单位冲激函数</td>
<td><span class="math inline">\(\begin{cases} \begin{aligned} &amp;\int_{-\infty}^{\infty}\delta(t)dt = 1\\\\ &amp;\delta(t) = 0\quad while(t\not=0) \end{aligned} \end{cases}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\delta(t)&#39;\)</span>：冲激偶函数</td>
<td><span class="math inline">\(\delta(t)&#39;=\frac{d\delta(t)}{dt}\)</span></td>
</tr>
</tbody>
</table>
<h4 id="ft单位斜变信号"><span class="math inline">\(f(t)\)</span>：单位斜变信号</h4>
<p>单位斜变信号的“单位”体现在其非零部分的斜率为 <span class="math inline">\(1\)</span> 。</p>
<p>函数表达式： <span class="math display">\[
f(t) = 
\begin{cases}
0 &amp;     t&lt;0     \\\\
t &amp;     t\ge0   \\
\end{cases}
\]</span> 起始点移位 <span class="math inline">\(t\)</span> 后： <span class="math display">\[
f(t-t_0) = 
\begin{cases}
0       &amp;       t&lt;t_0           \\\\
t-t_0   &amp;       t\ge t_0        \\
\end{cases}
\]</span></p>
<h4 id="ut单位阶跃信号">$ u(t)$：单位阶跃信号</h4>
<p>函数表达式：</p>
<p>由表达式可知 <span class="math inline">\(t=0\)</span> 处函数未定义，可以将 <span class="math inline">\(t=0\)</span> 处函数值定义为 <span class="math inline">\(u(0)=\frac{1}{2}\)</span>。 <span class="math display">\[
u(t) = 
\begin{cases}
0   &amp;       t&lt;0     \\\\
1   &amp;       t&gt;0     \\
\end{cases}
\]</span> 起始点移位 <span class="math inline">\(t\)</span> 后（或认为阶跃延时 <span class="math inline">\(t\)</span> 后），有： <span class="math display">\[
u(t-t_0) = 
\begin{cases}
0   &amp;       t&lt;t_0       \\\\
1   &amp;       t&gt;t_0       \\
\end{cases}
\]</span></p>
<h4 id="deltat单位冲激函数"><span class="math inline">\(\delta(t)\)</span>：单位冲激函数</h4>
<p>狄拉克（Dirac）定义方式： <span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;\int_{-\infty}^{\infty}\delta(t)dt = 1\\\\
&amp;\delta(t) = 0\quad while(t\not=0)
\end{aligned}
\end{cases}
\]</span> 狄拉克（Dirac）定义表明：</p>
<ol type="1">
<li>除了坐标轴零点处，其余位置单位冲激函数的函数值均为 <span class="math inline">\(0\)</span> 。</li>
<li>单位冲激函数仅在一点处取值，而其面积（积分）为 <span class="math inline">\(1\)</span> ，由此可知单位冲激函数为长度为 <span class="math inline">\(1\)</span> 的线段：表示中我们使用长度为 <span class="math inline">\(1\)</span> 的向量来表示，方向与 <span class="math inline">\(y\)</span> 轴正半轴方向相同。</li>
</ol>
<h4 id="deltat冲激偶函数"><span class="math inline">\(\delta(t)&#39;\)</span>：冲激偶函数</h4>
<p>由符号可知冲激偶函数为冲激函数的导数。</p>
<h4 id="常见奇异信号之间的关系">常见奇异信号之间的关系：</h4>
<p><span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;\frac{df(t)}{dt}=u(t)\\\\
&amp;\frac{du(t)}{dt}=\delta(t)\\\\
&amp;\delta(t)&#39;=\frac{d\delta(t)}{dt}
\end{aligned}
\end{cases}
\]</span></p>
<h4 id="单位冲激函数-deltat-的简单性质">单位冲激函数 <span class="math inline">\(\delta(t)\)</span> 的简单性质：</h4>
<ol type="1">
<li><p>单位冲激函数 <span class="math inline">\(\delta(t)\)</span> 具有<strong>抽样特性</strong>（也称“筛选”特性），<span class="math inline">\(\delta(t)\)</span> 可以用来筛选出信号中某一时刻的值（函数值），具体操作如下： <span class="math display">\[
\int_{-\infty}^{\infty}\delta(t-t_0)f(t)dt=f(t_0)
\]</span> 解释：对于任意一个信号 <span class="math inline">\(f(t)\)</span> ，我们使用 <span class="math inline">\(\delta(t)\)</span> 可以筛选出目标的函数值 <span class="math inline">\(f(t_0)\)</span> 。</p></li>
<li><p>单位冲激函数 <span class="math inline">\(\delta(t)\)</span> 是一个偶函数，即 <span class="math inline">\(\delta(t)=\delta(-t)\)</span></p></li>
</ol>
<h3 id="线性时不变系统lti">线性时不变系统——LTI</h3>
<ol type="1">
<li><p>理解线性：</p>
<ol type="1">
<li>满足叠加性和均匀性</li>
</ol></li>
<li><p>理解时不变特性：即系统本身的参数不随时间发生改变</p></li>
<li><p>线性时不变系统还具有的特性：</p>
<ol type="1">
<li><p>微分特性：微分特性由线性和时不变性共同得出，内容为：</p>
<p>若激励信号 <span class="math inline">\(e(t)\)</span> 可使系统产生响应信号 <span class="math inline">\(r(t)\)</span>，则</p>
<ul>
<li>激励 <span class="math inline">\(\frac{de(t)}{dt}\)</span> 可产生响应 <span class="math inline">\(\frac{dr(t)}{dt}\)</span></li>
<li>激励 <span class="math inline">\(\frac{d^2e(t)}{dt}\)</span> 可产生响应 <span class="math inline">\(\frac{d^2r(t)}{dt}\)</span>，其余高阶求导同理</li>
<li>激励 <span class="math inline">\(\int^t_0e(\tau)d\tau\)</span> 可产生响应 <span class="math inline">\(\int^t_0r(\tau)d\tau\)</span></li>
</ul></li>
<li><p>因果特性：因果特性描述了激励信号与响应信号之间的联系，因果特性表明：<span class="math inline">\(t_0\)</span> 时刻的响应只与<span class="math inline">\(t=t_0\)</span> 和 <span class="math inline">\(t&lt;t_0\)</span> 时刻的输入有关，即激励和响应有着因果关系，只有有激励才会有响应。</p></li>
</ol></li>
</ol>
<h3 id="分析lti">分析LTI</h3>
<p>系统建模就是使用数学工具例如方程或者微分方程来建立模型。</p>
<ol type="1">
<li>系统的数学描述方法可以分为两大类：</li>
</ol>
<ul>
<li>输入输出描述法——该方法注重系统激励和响应之间的关系，不关心系统内部变量情况
<ul>
<li>这种方法在数学上表现为一元<span class="math inline">\(n\)</span>阶微分方程</li>
</ul></li>
<li>状态变量描述法
<ul>
<li>可以给出系统响应</li>
<li>提供系统内部各变量的情况</li>
<li>可以用于多输入多输出系统的分析</li>
<li>这种方法在数学上表现为<span class="math inline">\(n\)</span>元联立一阶微分方程</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li>使用数学方法描述了一个系统后，我们就需要一些求解方法来求解系统模型，求解方法大体上也可以分为两类：</li>
</ol>
<ul>
<li>时域分析——时域分析是指在时间域上分析系统；前文可知系统可以简单理解为一个以时间为自变量的函数或函数族，时间域分析就是直接分析这个以时间变量作为自变量的函数。
<ul>
<li>时域分析分析输入输出法描述的系统模型时：
<ul>
<li>可以使用经典的常系数微分方程和差分方程</li>
<li>也可以使用算子符号来简化上面的微分方程和差分方程</li>
<li>卷积是分析线性系统时域的重要数学工具</li>
</ul></li>
<li>时域分析分析状态变量法描述的系统模型时：
<ul>
<li>需要求解矩阵方程</li>
</ul></li>
</ul></li>
<li>变换域分析——变换域是指将时变函数中的自变量：时间变量变换成其他变量函数。变换域分析使得时域分析中复杂的微分积分运算变成了代数运算，将复杂的卷积运算变成了乘法运算</li>
</ul>
<h3 id="电系统的lti数学模型建立">电系统的LTI数学模型建立</h3>
<p>构成电系统的LTI模型表现为微分方程式</p>
<p>构成此类方程式的依据是电系统网络的两类约束特性：</p>
<ul>
<li>电元器件约束特性——电子元器件的伏安特性
<ul>
<li>欧姆定律：
<ul>
<li><span class="math inline">\(V_R(t)=Ri_R(t)\)</span></li>
<li><span class="math inline">\(V_L(t)=L\frac{di(t)}{dt}\)</span></li>
<li><span class="math inline">\(V_C(t)=\frac{1}{C}\int_{-\infty}^ti_C{(\tau)}d\tau\)</span></li>
</ul></li>
</ul></li>
<li>网络拓扑结构——网络结构决定的电流电压关系
<ul>
<li>基尔霍夫定律：
<ul>
<li><span class="math inline">\(\sum i(t)=0\)</span></li>
<li><span class="math inline">\(\sum v(t)=0\)</span></li>
</ul></li>
</ul></li>
</ul>
<p>线性时不变系统的时域分析，微分方程的一般形式： <span class="math display">\[
C_0\frac{d^nr(t)}{dt^n}+C_1\frac{d^{n-1}r(t)}{dt^{n-1}}+···+C_{n-1}\frac{dr(t)}{dt}+C_nr(t)=E_0\frac{d^me(t)}{dt^m}+E_1\frac{d^{m-1}e(t)}{dt^{m-1}}+···+E_{m-1}\frac{de(t)}{dt}+E_me(t)
\]</span> 上式可以缩写为： <span class="math display">\[
\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=\sum_{j=0}^mE_{m-j}\frac{d^je(t)}{dt^j}
\]</span> 特殊形式，例如我们可以整理约束关系得到下式： <span class="math display">\[
\frac{d^3r(t)}{dt^3}+7\frac{d^2r(t)}{dt^2}+16\frac{dr(t)}{dt}+12r(t)=e(t)
\]</span> 微分方程的全解由齐次解 <span class="math inline">\(r_h(t)\)</span> 和特解 <span class="math inline">\(r_h(t)\)</span> )组成，即： <span class="math display">\[
r(t)=r_h(t)+r_h(t)
\]</span> 解法：</p>
<ol type="1">
<li>求齐次解 <span class="math inline">\(r_h(t)\)</span>：</li>
</ol>
<ul>
<li><p>令 <span class="math inline">\(\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=0\)</span>，该式称为齐次方程</p></li>
<li><p>将 <span class="math inline">\(r(t)=Ae^{\alpha t}\)</span> 代入齐次方程得 <span class="math inline">\(\sum_{i=0}^nC_{n-i}\alpha^{i}=0\)</span>，称为特征方程</p></li>
<li><p>根据特征方程可以得齐次解 <span class="math inline">\(r_h(t)\)</span> 为</p>
<ul>
<li><p>特征方程没有重根：<img src="/2022/02/27/16-42-18/image-20220326234840139-16483097818622.png" alt="image-20220326234840139" style="zoom: 40%;"></p></li>
<li><p>特征方程有重根：<img src="/2022/02/27/16-42-18/image-20220326234918784-16483097790591.png" alt="image-20220326234918784" style="zoom: 40%;"></p></li>
</ul></li>
</ul>
<ol start="2" type="1">
<li><p>求特解 <span class="math inline">\(r_h(t)\)</span>：</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 66%">
</colgroup>
<thead>
<tr class="header">
<th>激励函数 <span class="math inline">\(e(t)\)</span></th>
<th>响应函数 <span class="math inline">\(r(t)\)</span> 的特解</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(E\)</span></td>
<td><span class="math inline">\(B\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(t^p\)</span></td>
<td><span class="math inline">\(B_1t^p+B_2t^{p-1}+···+B_pt+B_{p+1}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(e^{\alpha t}\)</span></td>
<td><span class="math inline">\(Be^{\alpha t}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(cos(\omega t)\)</span></td>
<td><span class="math inline">\(B_1cos(\omega t)+B_2sin(\omega t)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(sin(\omega t)\)</span></td>
<td><span class="math inline">\(B_1cos(\omega t)+B_2sin(\omega t)\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(t^pe^{\alpha t}cos(\omega t)\)</span></td>
<td><span class="math inline">\((B_1t^p+···+B_pt+B_{p+1})e^{\alpha t}cos(\omega t)+(D_1t^p+···+D_pt+D_{p+1})e^{\alpha t}sin(\omega t)\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(t^pe^{\alpha t}sin(\omega t)\)</span></td>
<td><span class="math inline">\((B_1t^p+···+B_pt+B_{p+1})e^{\alpha t}cos(\omega t)+(D_1t^p+···+D_pt+D_{p+1})e^{\alpha t}sin(\omega t)\)</span></td>
</tr>
</tbody>
</table></li>
<li><p>求待定系数 <span class="math inline">\(A\)</span>：</p></li>
</ol>
<h3 id="拉普拉斯变换">拉普拉斯变换</h3>
<p>形态上，拉普拉斯变换做了这样一件事： <span class="math display">\[
f(t)\xrightarrow{\sf{拉普拉斯变换}}F(s)
\]</span> 或者说： <span class="math display">\[
f(t)\xrightarrow{\mathscr{L}\{f(t)\}}F(s)
\]</span> 从形态上讲，拉普拉斯变换将一个以时间 <span class="math inline">\(t\)</span> 为自变量的函数变换成了一个以频率 <span class="math inline">\(s\)</span> 为自变量的函数。</p>
<p>拉普拉斯变换将函数从时域变换到了频域，其实就是信号的自变量发生了变化。</p>
<p>意义：拉普拉斯变换可以将时域内的微分方程变换成频域内的代数方程，降低计算难度并且从频域再次回到时域时保证解不变。</p>
<p><span class="math inline">\(\mathscr{L}\{f(t)\}\)</span> 拉氏变换的定义为： <span class="math display">\[
\mathscr{L}\{f(t)\}=\int_{0}^{\infty}f(t)\cdot e^{-st}dt
\]</span> 注意事项：</p>
<ol type="1">
<li>进行拉氏变换的 <span class="math inline">\(f(t)\)</span> 是否存在的问题：
<ul>
<li>首先是初等函数都能进行拉氏变换</li>
<li>默认在线性电路分析中均使用能够进行拉氏变换的电源进行系统的激励</li>
</ul></li>
<li>上述拉氏变换也可以称作单边拉氏变换，此变换忽略了 <span class="math inline">\(t&lt;0\)</span> 时的 <span class="math inline">\(f(t)\)</span></li>
<li><span class="math inline">\(t&lt;0\)</span> 时的 <span class="math inline">\(f(t)\)</span> 可以通过初始条件来考虑</li>
</ol>
<p>分类：</p>
<p>学习拉普拉斯变换将拉普拉斯变换分为函数变换和算子变换</p>
<ul>
<li>函数变换：研究初等函数的拉氏变换</li>
<li>算子变换：研究一般函数的拉氏变换</li>
</ul>
<h4 id="算子变换">算子变换：</h4>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 83%">
</colgroup>
<thead>
<tr class="header">
<th>拉氏变换</th>
<th><span class="math inline">\(\mathscr{L}\{f(t)\}=F(s)\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>乘以常数</td>
<td><span class="math inline">\(\mathscr{L}\{Kf(t)\}=KF(s)\)</span></td>
</tr>
<tr class="even">
<td>加减运算</td>
<td><span class="math inline">\(\mathscr{L}\{f(t_1)+f(t_2)-f(t_3)\}=F(s_1)+F(s_2)-F(s_3)\)</span></td>
</tr>
<tr class="odd">
<td>微分运算</td>
<td>一重微分：<span class="math inline">\(\mathscr{L}\{\frac{df(t)}{dt}\}=sF(s)-f(0^-)\)</span><br><span class="math inline">\(n\)</span> 重微分：<span class="math inline">\(\mathscr{L}\{\frac{d^nf(t)}{dt^n}\}=s^nF(s)-s^{n-1}f(0^-)-\sum_{i=2}^{n}s^{n-i}\frac{d^{i-1}f(0^-)}{dt^{i-1}}\)</span></td>
</tr>
<tr class="even">
<td>积分运算</td>
<td><span class="math inline">\(\mathscr{L}\{\int_{0^-}^{t}f(t)dt\}=F(s)/s\)</span></td>
</tr>
<tr class="odd">
<td>时域平移特性</td>
<td><span class="math inline">\(\mathscr{L}\{f(t-a)\cdot u(t-a)\}=e^{-as}\cdot F(s),\quad a&gt;0\)</span><br><span class="math inline">\(\mathscr{L}\{e^{-as}\cdot F(s)\}=F(s+a)\)</span></td>
</tr>
<tr class="even">
<td>尺度变换特性</td>
<td><span class="math inline">\(\mathscr{L}\{f(at)\}=\frac{1}{a}F\left(\frac{s}{a}\right),\quad a&gt;0\)</span></td>
</tr>
</tbody>
</table>
<h3 id="傅里叶分析简介">傅里叶分析简介</h3>
<p>傅里叶定理表明，任何一个角频率为<span class="math inline">\(\omega_0\)</span>的周期函数都可以表示为无穷多个频率为<span class="math inline">\(\omega_0\)</span>整数倍的正弦函数与余弦函数之和。</p>
<p>对于一个周期函数<span class="math inline">\(f(t)\)</span>，若满足Dirichlet条件，则该周期函数可以展开成傅里叶级数，即： <span class="math display">\[
\begin{aligned}
    &amp;if\quad f(t)=f(t+T)\\\\
    &amp;then\quad f(t)=a_0 + \displaystyle\sum_{n=1}^{\infty}a_ncos(n\omega_0t) +  \displaystyle\sum_{n=1}^{\infty}b_nsin(n\omega_0t)\\
    &amp;\boxed
    {
        \begin{aligned}
        &amp;a_0=\frac{1}{T}\int^{T}_{0}f(t)\,dt\\
        &amp;a_n=\frac{2}{T}\int^{T}_{0} f(t) cos(n\omega_0t) \,dt \\
        &amp;b_n=\frac{2}{T}\int^{T}_{0} f(t) cos(n\omega_0t) \,dt \\
        \end{aligned}
    }
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
    &amp;if \quad f(t)=f(-t)\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\;\,\\\\
    &amp;\boxed
    {
        \begin{aligned}
        &amp;a_0=\frac{2}{T}\int^{T/2}_{0}f(t)\,dt\\
        &amp;a_n=\frac{4}{T}\int^{T/2}_{0} f(t) cos(n\omega_0t) \,dt \\
        &amp;b_n=0 \\
        \end{aligned}
    }
\end{aligned}
\]</span></p>
<p>展开式中<span class="math inline">\(a_0\)</span>称为直流分量，其值等于函数<span class="math inline">\(f(t)\)</span>的平均值；<span class="math inline">\(a_n\)</span>与<span class="math inline">\(b_n(n\not=0)\)</span>是交流分量的幅值 <span class="math display">\[
f(t)=f(t+T)\Rightarrow
f(t)=a_0 + \displaystyle\sum_{n=1}^{\infty}a_ncos(n\omega_0t) + \displaystyle\sum_{n=1}^{\infty}b_nsin(n\omega_0t)\\
\]</span></p>
<p><span class="math display">\[
\begin{array}{c|c|c}
    \begin{aligned}
    &amp;general\quad condition\\
    &amp;\boxed
    {
        \begin{aligned}
            &amp;a_0=\frac{1}{T}\int^{T}_{0}f(t)\,dt\\
            &amp;a_n=\frac{2}{T}\int^{T}_{0} f(t) cos(n\omega_0t) \,dt \\
            &amp;b_n=\frac{2}{T}\int^{T}_{0} f(t) sin(n\omega_0t) \,dt \\
        \end{aligned}
    }
    \end{aligned}
    &amp;
    \begin{aligned}
        &amp;if \quad f(t)=f(-t)\\
        &amp;\boxed
        {
            \begin{aligned}
                &amp;a_0=\frac{2}{T}\int^{T/2}_{0}f(t)\,dt\\
                &amp;a_n=\frac{4}{T}\int^{T/2}_{0} f(t) cos(n\omega_0t) \,dt \\
                &amp;b_n=0 \\
            \end{aligned}
}
    \end{aligned}
    &amp; 
    \begin{aligned}
    &amp;if \quad f(t)=-f(-t)\\
    &amp;\boxed
    {
        \begin{aligned}
            &amp;a_0=0\\
            &amp;a_n=0\\
            &amp;b_n=\frac{4}{T}\int^{T/2}_{0} f(t) sin(n\omega_0t) \,dt  \\
        \end{aligned}
}
    \end{aligned}\\
\end{array}\\
\]</span></p>
<p><span class="math display">\[
P_{1\Omega}=F_{rms}^2=a_0^2+\frac{1}{2}\displaystyle\sum_{n=1}^{\infty}(a_n^2+b_n^2)
\]</span></p>
<p>线性系统：</p>
<p>线性系统是指具有叠加性和均匀性的系统：</p>
<ul>
<li>叠加性：多个激励同时作用时产生的响应 = 多个激励分别作用时产生的响应的和</li>
<li>均匀性：输入增益于输出增益相同</li>
</ul>
<p><span class="math display">\[
v_R(t)=Ri_R(t)\\
v_L(t)=L\frac{i_L(t)}{dt}\\
v_C(t)=\frac{1}{C}\int_{-\infty}^{t}i_C(\tau)d\tau
\]</span></p>
<p><span class="math display">\[
V_L(t)+V_R(t)+V_C(t)=e(t)\\
L\frac{i_L(t)}{dt}+Ri_R(t)+\frac{1}{C}\int_{-\infty}^{t}i_C(\tau)d\tau=e(t)\\
L\frac{d^2i_L(t)}{dt^2}+R\frac{di_R(t)}{dt}+\frac{1}{C}i_C(t)=\frac{de(t)}{dt}\\
对于串联，有i_L=i_R=i_C\\
L\frac{d^2i(t)}{dt^2}+R\frac{di(t)}{dt}+\frac{1}{C}i(t)=\frac{de(t)}{dt}\\
\]</span></p>
<p><span class="math display">\[
i_R(t)=\frac{1}{R}v(t)\\
i_L(t)=\frac{1}{L}\int_{-\infty}^{t}v(\tau)d\tau\\
i_C(t)=C\frac{dv_C(t)}{dt}
\]</span></p>
<p><span class="math display">\[
i_C(t)+i_R(t)+i_L(t)=i_S(t)\\
C\frac{d^2v(t)}{dt^2}+\frac{1}{R}\frac{dv(t)}{dt}+\frac{1}{L}v(t)=\frac{di_S(t)}{dt}\\
\]</span></p>
<p>若组成系统的都是参数恒定的线性元件，则相应的数学模型是一个线性常系数常微分方程，若各器件初始无储能，则为一个线性时不变系统</p>
<p>则对于一个线性时不变系统来说，其数学模型可以使用一个微分方程来描述： <span class="math display">\[
C_0\frac{d^nr(t)}{dt^n}+C_1\frac{d^{n-1}r(t)}{dt^{n-1}}+···+C_{n-1}\frac{dr(t)}{dt}+C_nr(t)=E_0\frac{d^me(t)}{dt^m}+E_1\frac{d^{m-1}e(t)}{dt^{m-1}}+···+E_{m-1}\frac{de(t)}{dt}+E_me(t)
\]</span> 方程的解可以记作： $$</p>
<p>$$</p>
<p>线性电路系统由线性电子元器件构成，描述此类系统需要借助电路网络的两类约束条件：</p>
<ul>
<li>元件约束特性</li>
<li>网络拓扑约束</li>
</ul>
<p>两种约束的数学描述可以由<strong>微分方程组</strong>给出，这类方程组称为系统的<strong>状态方程</strong></p>
<p>我们联立上述方程组可以得到<strong>一个高阶微分方程</strong>，这个高阶微分方程称作<strong>输入输出方程</strong>，其阶数为系统的阶数</p>
<p>系统的输入称为激励，输出称为响应；若能给出系统的<strong>初始状态</strong>和<strong>激励</strong>，则可以获得<strong>响应</strong></p>
<p>系统的初始状态由若干独立条件给出，独立条件的个数与系统的阶数相同</p>
<p>线性时不变系统一般使用一个n阶线性微分方程来描述</p>
<p>这个方程可以被整理为： <span class="math display">\[
\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=\sum_{j=0}^mE_{m-j}\frac{d^je(t)}{dt^j}
\]</span> 一般来说，对于响应，其有实际意义的定义域称为响应区间，即：<span class="math inline">\(0_+ \le t&lt; \infty\)</span></p>
<p><span class="math inline">\(e(t)\)</span>加入前，系统为起始状态（<span class="math inline">\(0_-\)</span>状态） <span class="math display">\[
r^k(0_-)=[r(0_-),\frac{d}{dt}r(0_-),...,\frac{d^n}{dt^n}r(0_-)]
\]</span></p>
<p><span class="math inline">\(e(t)\)</span>加入后，系统为初始状态（<span class="math inline">\(0_+\)</span>状态） <span class="math display">\[
r^k(0_+)=[r(0_+),\frac{d}{dt}r(0_+),...,\frac{d^n}{dt^n}r(0_+)]
\]</span> 因此，决定关系为：</p>
<ul>
<li>起始状态 <span class="math inline">\(+\)</span> <span class="math inline">\(e(t)\)</span> <span class="math inline">\(\rightarrow\)</span> 初始状态</li>
<li>初始状态 <span class="math inline">\(\rightarrow\)</span> 响应齐次解的常系数 <span class="math inline">\(A\)</span></li>
</ul>
<p>响应可以拆解为三种形式：</p>
<ul>
<li>固有响应 <span class="math inline">\(+\)</span> 受迫响应</li>
<li>零输入响应 <span class="math inline">\(+\)</span> 零状态响应</li>
<li>暂态响应 <span class="math inline">\(+\)</span> 稳态响应</li>
</ul>
<h6 id="全响应">全响应：</h6>
<p>对于使用<span class="math inline">\(n\)</span>阶微分方程描述的线性系统： <span class="math display">\[
\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=\sum_{j=0}^mE_{m-j}\frac{d^je(t)}{dt^j}
\]</span> 上述微分方程的解，即系统的响应，为：<span class="math inline">\(r(t)=r_h+r_p\)</span>，求解步骤为：</p>
<ul>
<li>使用特征根求解待定系数的齐次解</li>
<li>使用待定系数法求解特解</li>
<li>求解齐次解中的系数
<ul>
<li>使用 <span class="math inline">\(r^k(0_+)=[r(0_+),\frac{d}{dt}r(0_+),...,\frac{d^n}{dt^n}r(0_+)]\)</span> 来求解系数向量 <span class="math inline">\(A_n\)</span></li>
<li>寻找 <span class="math inline">\(r^k(0_-)\)</span> 与 <span class="math inline">\(r^k(0_+)\)</span> 之间的关系
<ul>
<li>物理法：对于电路系统来说即换路定理：电容电感端性质的连续性</li>
<li>数学法：冲激函数匹配法：微分方程两端保持各阶奇异函数的平衡</li>
</ul></li>
</ul></li>
</ul>
<h6 id="固有响应和受迫响应">固有响应和受迫响应：</h6>
<p><span class="math inline">\(r(t)=r_h+r_p\)</span> <span class="math display">\[
r(t)=\underbrace_{\sf{固有响应}}+\underbrace_{\sf{受迫响应}}
\]</span></p>
<h6 id="零输入响应和零状态响应">零输入响应和零状态响应：</h6>
<p><strong>零输入响应：</strong> <span class="math display">\[
\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=0
\]</span> 其中 <span class="math display">\[
\sum_{j=0}^mE_{m-j}\frac{d^je(t)}{dt^j}=0
\]</span> 说明 <span class="math display">\[
[r(0_+),\frac{d}{dt}r(0_+),...,\frac{d^n}{dt^n}r(0_+)]=r^k(0_-)=[r(0_-),\frac{d}{dt}r(0_-),...,\frac{d^n}{dt^n}r(0_-)]
\]</span> <strong>零状态响应：</strong> <span class="math display">\[
\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=\sum_{j=0}^mE_{m-j}\frac{d^je(t)}{dt^j}
\]</span> 但是与全响应不同的是，零状态响应中： <span class="math display">\[
r^k(0_-)=[r(0_-),\frac{d}{dt}r(0_-),...,\frac{d^n}{dt^n}r(0_-)]=[0,0,...,0]
\]</span> 其余求法依旧是：</p>
<ul>
<li>使用特征根求解待定系数的齐次解</li>
<li>使用待定系数法求解特解</li>
<li>求解齐次解中的系数</li>
</ul>
<p>注意：先求特解再求系数不要乱！</p>
<p>对于使用<span class="math inline">\(n\)</span>阶微分方程描述的线性系统： <span class="math display">\[
\sum_{i=0}^nC_{n-i}\frac{d^ir(t)}{dt^i}=\sum_{j=0}^mE_{m-j}\frac{d^je(t)}{dt^j}
\]</span> 上述微分方程的解，即系统的响应，为：<span class="math inline">\(r(t)=r_h+r_p\)</span>，求解步骤为：</p>
<ul>
<li>使用特征根求解待定系数的齐次解</li>
<li>使用待定系数法求解特解</li>
<li>求解齐次解中的系数：使用 <span class="math inline">\(r^k(0_+)=[r(0_+),\frac{d}{dt}r(0_+),...,\frac{d^n}{dt^n}r(0_+)]\)</span> 来求解系数向量 <span class="math inline">\(A_n\)</span></li>
</ul>
<h2 id="如何从微分方程上判断线性系统">如何从微分方程上判断线性系统</h2>
<ol type="1">
<li>只能出现函数本身，以及函数的任何阶次的导函数；</li>
<li>函数本身跟所有的导函数之间除了加减之外，不可以有任何运算；</li>
<li>函数本身跟本身、各阶导函数本身跟本身，都不可以有任何加减之外的运算；</li>
<li>若有积分项，被积函数应为输入变量，如 <span class="math inline">\(\int_{-\infty}^{t}r(\tau)d\tau\)</span>。其实积分就是微分的负次幂。</li>
<li>不允许对函数本身、各阶导函数做任何形式的复合运算。</li>
</ol>
<p><a href="https://www.zhihu.com/question/40919950">线性微分方程与非线性微分方程的区别是什么？</a></p>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>写给电子专业同学的C语言教程</title>
    <url>/2022/02/27/16-41-11/</url>
    <content><![CDATA[<h1 id="cc语言教程">C/C++语言教程</h1>
<h4 id="递归">递归</h4>
<p>一般来讲，递归对于初学者来说是一个比较困难的内容，就我个人的学习经历来说，递归也是我在初学时比较头痛的一部分。对于这种情况，我想总结一下我学习中遇到的困难，然后在与大家分享递归思想的过程中，尽可能扫清那些影响我的障碍，让递归的学习梯度更缓一些，从而帮助大家更快地学习递归。</p>
<p>首先我想来说一下在我初学递归的过程中，我遇到了哪些困难：首先最重要的一条，我最早接触递归是通过一道习题接触的，就是大名鼎鼎的汉诺塔问题，算是个经典的递归问题了。但是经典归经典，我却不认为初学递归应该从汉诺塔开始，因为汉诺塔本身并不属于掷色子或者猜拳那种人尽皆知的游戏，想要去理解汉诺塔，首先要先看其规则并烂熟于心，然后就是汉诺塔使用了两个递归去完成，自然比单个递归要困难一些：以循环为例，通常的学法是先学明白单循环，再接触双层循环，接受起来才更容易些。因此，在接下来的讲解中，我将从一个非常非常简单的例子：打印1-5这五个数字为例，讲解递归操作的使用。</p>
<p>在讲解例子之前，我们先整体描述一下递归，<strong>递归即函数自己调用自己</strong>。</p>
<p>对于上述的定义，我们拆开来阐述一下：“函数自己调用自己”，这句话可以缩句为“函数调用”，调用谁先不管，要做的事情是函数调用，这件事要首先明确。在之前的课程中我们已经学习了函数的调用，尤其是我们将一段完整的，具有通用性的且需要多次使用的语句封装成一个函数，并在主函数中进行调用，这种操作我们已经非常熟悉，下面我们来看一个简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; cout &lt;&lt; n;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; cout &lt;&lt; n; <span class="built_in">A</span>(n + <span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; cout &lt;&lt; n; <span class="built_in">B</span>(n + <span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">D</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; cout &lt;&lt; n; <span class="built_in">C</span>(n + <span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">E</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; cout &lt;&lt; n; <span class="built_in">D</span>(n + <span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">E</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">C:\Users\qjy\Desktop\递归\递归演示\Debug\递归演示.exe (进程 11560)已退出，代码为 0。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br></pre></td></tr></table></figure>
<p>在这个例子中我们可以看到函数的多个函数依次调用：<code>main()</code> 调用 <code>E()</code>，<code>E()</code> 调用 <code>D()</code>，<code>D()</code> 调用 <code>C()</code>，<code>C()</code> 调用 <code>B()</code>，<code>B()</code> 调用 <code>A()</code>，当函数 <code>A()</code> 运行结束后，函数自动退出，然后就会返回 <code>B()</code>，返回到 <code>B()</code> 后 <code>B()</code> 也走到其函数体的最后了，因此 <code>B()</code> 也退出，然后就会返回 <code>C()</code>，就这样依次返回，最终回到 <code>main()</code>，执行 <code>return 0;</code> 。</p>
<p>在循环中，我们将具有相似结构的语句进行简化，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*本段代码为伪代码。*/</span></span><br><span class="line">sum = <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+...+<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以写为：</span></span><br><span class="line">sum = <span class="number">1</span>;</span><br><span class="line">sum = <span class="number">1</span>+<span class="number">2</span>;</span><br><span class="line">sum = <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">sum = <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+...+<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后可以抽象出：</span></span><br><span class="line">sum = sum+mid;</span><br><span class="line">mid++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//于是可以使用循环解决问题：</span></span><br><span class="line"><span class="keyword">while</span>(mid&lt;=<span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sum = sum+mid;</span><br><span class="line">	mid++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么同样的，对于有着相同形式的函数，就像最前面一段代码中那样，函数 <code>A()</code> 到函数 <code>E()</code> 的函数体具有高度的相似性，我们是否也可以通过类似于循环那样的方法来实现同样的功能呢？</p>
<p>答案是可以的，我们可以只使用函数 <code>A()</code> ，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">6</span>) &#123;</span><br><span class="line">		cout &lt;&lt; n;</span><br><span class="line">		<span class="built_in">A</span>(n + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">A</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">12345</span><br><span class="line">C:\Users\qjy\Desktop\递归\递归演示\Debug\递归演示.exe (进程 5580)已退出，代码为 0。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br></pre></td></tr></table></figure>
<p>接下来我们画图来分析一下，这段代码是如何工作的。</p>
<p>现在你应该对于递归的自调用有一定的概念了，那么现在我们来讨论一个问题，那就是，<strong>为什么是递归</strong>？毕竟我们以及有循环了，在刚才的示例中，我们递归能做的事情，循环可以做的更好，并且还好理解，我们何苦呢。</p>
<p>为了解决目前我们的递归看起来还没啥用的情况，我们引入第二个问题：十进制正整数转二进制数。</p>
<p>首先，解决这个问题，我们首先要知道十进制正整数转二进制数的算法。这个算法是非常简单的，这里我取我们数字电路课本中的例题来说明一下算法：</p>
<figure>
<img src="/2022/02/27/16-41-11/image-20220423044903868-16506605454001-16506605484693-16506605497375.png" alt="image-20220423044903868"><figcaption aria-hidden="true">image-20220423044903868</figcaption>
</figure>
<p>算法如下：</p>
<ol type="1">
<li>十进制正整数不断除以二，记录余数</li>
<li>当除法运算结果为0时，保留这次运算的余数并停止运算</li>
<li>将余数从下往上取出，在等号右侧从左往右依次列出</li>
</ol>
<p>这个算法，使用循环的话，我们会遇到一些麻烦的事情，让循环变得不那么好用了，因为，我们第一个得到的结果，需要在最后被打印出来。</p>
<p>这时候就到了递归登场的时候了，因为递归是函数的自调用，当函数一层一层的调用后，还需要一层一层的退出，比较的话，可以这样看待循环和递归，循环只是前进，而递归要去一趟回一趟，也就是两趟。</p>
<p><img src="/2022/02/27/16-41-11/image-20220423050047145-16506612490237.png" alt="image-20220423050047145" style="zoom:33%;"></p>
<p>这种特性使得我们能够轻松使用递归实现先得到的结果最后展示，在最终公布“十进制正整数转二进制数”题目的答案前，我们插一个小实例，来看一下，递归如何实现先得到的结果最后展示的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="built_in">A</span>(n + <span class="number">1</span>);</span><br><span class="line">		cout &lt;&lt; n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">A</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">54321</span><br><span class="line">C:\Users\qjy\Desktop\递归\递归演示\Debug\递归演示.exe (进程 8548)已退出，代码为 0。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br></pre></td></tr></table></figure>
<p>这段代码看着根前面的那段代码很想，唯一不同的是5、6两行的顺序颠倒了，这样导致的结果就是，程序将会先走到调用的最底层，然后在返回的时候在逐次打印，具体如下图展示。</p>
<p>最后我们来看一下十进制正整数转二进制数的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">A</span>(n / <span class="number">2</span>);</span><br><span class="line">		cout &lt;&lt; n % <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">A</span>(n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">53</span><br><span class="line">110101</span><br><span class="line">C:\Users\qjy\Desktop\递归\递归演示\Debug\递归演示.exe (进程 10544)已退出，代码为 0。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br></pre></td></tr></table></figure>
<p>目前，我们已经使用递归来解决实际问题了，也算是从不懂到会用了。耶！</p>
<p>但是，光看别人写是不够的，因为很多书写的细节对出初学者来说是难以注意到的。值得在你们自己开始写递归前就重点强调一下的书写细节是递归的停止条件。</p>
<p>在循环中，尤其是最常用的 <code>for</code> 循环，具有很明确的开始和截至的标识，在递归中，我们没有一个循环变量小i来直到我们设置递归的层数，但是，无穷的递归是不被允许的，无穷递归很快就会使程序运行内存中一片叫栈的区域爆满（或者专业点，叫溢出）。在上面所有的递归程序中，我们都可以看到，自调用的函数，我们在开头都设置了条件判断，只有在一定条件内的输入才能往后进行迭代，否则就</p>
<p>接下来，我将带领大家，在前面已经理解递归的基础上，从理解汉诺塔的规则开始，一点一点写出整个汉诺塔代码，一行一行的说明我在书写汉诺塔程序时是如何进行思考的。</p>
<p>首先是汉诺塔问题描述，摘录自维基百科：</p>
<blockquote>
<p>有三根杆子A，B，C。A杆上有 N 个 (N&gt;1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：</p>
<ol type="1">
<li>每次只能移动一个圆盘；</li>
<li>大盘不能叠在小盘上面。</li>
</ol>
<p>提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。</p>
<p>问：如何移？最少要移动多少次？</p>
</blockquote>
<p>然后是摘自维基百科的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Towers</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> a,<span class="type">char</span> b,<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Move disk &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; from&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; to &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">Towers</span>(n<span class="number">-1</span>,a,c,b);</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Move disk &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; from&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; to &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		<span class="built_in">Towers</span>(n<span class="number">-1</span>,b,a,c);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">Towers</span>(n,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	cout&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line">Move disk 2 from A to B</span><br><span class="line">Move disk 1 from C to B</span><br><span class="line">Move disk 3 from A to C</span><br><span class="line">Move disk 1 from B to A</span><br><span class="line">Move disk 2 from B to C</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\qjy\Desktop\递归\递归演示\Debug\递归演示.exe (进程 28576)已退出，代码为 0。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br></pre></td></tr></table></figure>
<p>根据运行结果，我们可以画出3个圆盘的汉诺塔是如何实现移动的：</p>
<p><img src="/2022/02/27/16-41-11/cd940d4cbf859995dd8175f2c250e70-165066295755110.jpg" alt="cd940d4cbf859995dd8175f2c250e70" style="zoom: 33%;"></p>
<p>然后问题就来了，因为我们会发现一个问题，那就是，根本找不到规律啊，递归要求一个函数，也就是说一种方法，只改变一下输入参数，不断调用这一个方法就能实现整个过程，但是看上面的图根本就无法找到规律啊。</p>
<p>那么，我们该如何解决现在面临的问题呢？是不是可以考虑，可能是取的数量太少，我们可以试试圆盘数量为4个或者5个？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">Move disk 1 from A to B</span><br><span class="line">Move disk 2 from A to C</span><br><span class="line">Move disk 1 from B to C</span><br><span class="line">Move disk 3 from A to B</span><br><span class="line">Move disk 1 from C to A</span><br><span class="line">Move disk 2 from C to B</span><br><span class="line">Move disk 1 from A to B</span><br><span class="line">Move disk 4 from A to C</span><br><span class="line">Move disk 1 from B to C</span><br><span class="line">Move disk 2 from B to A</span><br><span class="line">Move disk 1 from C to A</span><br><span class="line">Move disk 3 from B to C</span><br><span class="line">Move disk 1 from A to B</span><br><span class="line">Move disk 2 from A to C</span><br><span class="line">Move disk 1 from B to C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\qjy\Desktop\递归\递归演示\Debug\递归演示.exe (进程 25272)已退出，代码为 0。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line">Move disk 2 from A to B</span><br><span class="line">Move disk 1 from C to B</span><br><span class="line">Move disk 3 from A to C</span><br><span class="line">Move disk 1 from B to A</span><br><span class="line">Move disk 2 from B to C</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line">Move disk 4 from A to B</span><br><span class="line">Move disk 1 from C to B</span><br><span class="line">Move disk 2 from C to A</span><br><span class="line">Move disk 1 from B to A</span><br><span class="line">Move disk 3 from C to B</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line">Move disk 2 from A to B</span><br><span class="line">Move disk 1 from C to B</span><br><span class="line">Move disk 5 from A to C</span><br><span class="line">Move disk 1 from B to A</span><br><span class="line">Move disk 2 from B to C</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line">Move disk 3 from B to A</span><br><span class="line">Move disk 1 from C to B</span><br><span class="line">Move disk 2 from C to A</span><br><span class="line">Move disk 1 from B to A</span><br><span class="line">Move disk 4 from B to C</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line">Move disk 2 from A to B</span><br><span class="line">Move disk 1 from C to B</span><br><span class="line">Move disk 3 from A to C</span><br><span class="line">Move disk 1 from B to A</span><br><span class="line">Move disk 2 from B to C</span><br><span class="line">Move disk 1 from A to C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\qjy\Desktop\递归\递归演示\Debug\递归演示.exe (进程 28244)已退出，代码为 0。</span><br><span class="line">要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。</span><br><span class="line">按任意键关闭此窗口. . .</span><br></pre></td></tr></table></figure>
<p>好家伙，我们会发现一个要命的问题——太多了，到五个的时候，就已经接近30次移动了。这要是画出来，可有点麻烦，那怎么办呢？</p>
<p>答案很简单，查资料！因为这实在是一个很普遍的问题，还是来看看其他人是如何理解这个问题的吧。</p>
<p>我们打开知乎直接搜汉诺塔+递归，很快，就出来了一个好回答，我们引用来给大家看一下：</p>
<blockquote>
<p>举例来说，如果要把一个N层<a href="https://www.zhihu.com/search?q=汉诺塔&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%22258015386%22%7D">汉诺塔</a>从A搬到C，那么：</p>
<p>如果前N-1层可以找别人搞定，咱只管搬第N层，会不会变得非常容易？</p>
<p>你看，这一下就简单了：这时当它只有两层就好了，先把前N-1层看作一个整体，把它搬到B；然后把最下面的第N层搬到C；然后再把前N-1层从B搬到C。</p>
</blockquote>
<p>把上面的话变成图像，就是这样子的，我们以四圆盘汉诺塔为例子说明：</p>
<p><img src="/2022/02/27/16-41-11/f5934171b9e47846656830e885174e3-165066362487913.jpg" alt="f5934171b9e47846656830e885174e3" style="zoom:33%;"></p>
<p>好的，看到这个图不知道大家会不会有些疑问哈，可能会有同学觉得，这样搬会不会违反汉诺塔的游戏规则了？emmm，如果你最后的结果是这样搬动的确实是不行的，但是关键在于，我们按照搬动顺序去寻找递归方法是行不通的，我们需要寻找一种能解决问题的通用方法（这里的通用是指对每一层圆盘移动的通用方法），然后我们在解决完问题后，再去调整顺序输出，来实现满足游戏规则的搬动方法。</p>
<p>因此，上述操作，确实可以帮助我们将4个圆盘，从A移动到C，并且我们可以注意到，从第3行到第4行，因为移动的圆盘都比C上的大圆盘小，故移动是随意的，即ABC三个底座都可以放圆盘。</p>
<p><img src="/2022/02/27/16-41-11/69227befb2e0235c3a257acdcc450ad-165066408870616.jpg" alt="69227befb2e0235c3a257acdcc450ad" style="zoom: 50%;"></p>
<p>观察上图，我们可以看到，第一列中有四个圆盘，从第一步到第二部和从第三步到第四步在规则的制约下都不是可以一步实现的，但是因为每一次变化都依旧有三个底座可用，故具有移动方法上的相似性，这使得函数的自调用成为可能。</p>
<p>我们可以看到，随着列数往后数，我们处理的问题的规模在逐渐下降，最初是4个圆盘，第二列时，我们关注的就成了3个圆盘，这样依次下推，最终我们会得到一种情况，这种情况下只有一个圆盘，如图：</p>
<figure>
<img src="/2022/02/27/16-41-11/5898a6106be97a5e17f672399758dd2-165066466531719.jpg" alt="5898a6106be97a5e17f672399758dd2"><figcaption aria-hidden="true">5898a6106be97a5e17f672399758dd2</figcaption>
</figure>
<p>我们观察放大部分中的最后一列，可以看到，最后一列中所有的操作都是将圆盘从A移动到C，这种特性说明了每一次递归的终点都是“将圆盘从A移动到C”，如果你回到上面看代码，你会发现代码中真正打印的移动操作都是从a到c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move_1</span><span class="params">(<span class="type">int</span> level, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;把 &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot; 号盘从 &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; 移动到 &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move_2</span><span class="params">(<span class="type">int</span> level, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	move_1(level - <span class="number">1</span>, a, c, b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;把 &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot; 号盘从 &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; 移动到 &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	move_1(level - <span class="number">1</span>, b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move_3</span><span class="params">(<span class="type">int</span> level, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	move_2(level - <span class="number">1</span>, a, c, b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;把 &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot; 号盘从 &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; 移动到 &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	move_2(level - <span class="number">1</span>, b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">move_4</span><span class="params">(<span class="type">int</span> level,<span class="type">char</span> a,<span class="type">char</span> b,<span class="type">char</span> c)</span> </span><br><span class="line">&#123;</span><br><span class="line">	move_3(level - <span class="number">1</span>, a, c, b);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;把 &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot; 号盘从 &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; 移动到 &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	move_3(level - <span class="number">1</span>, b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Towers</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move disk &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		Towers(n - <span class="number">1</span>, a, c, b);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Move disk &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		Towers(n - <span class="number">1</span>, b, a, c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> level;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; level;</span><br><span class="line">	Towers(level, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-------------------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	move_4(level, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="函数指针">函数指针</h4>
<h5 id="回调函数">回调函数</h5>
<blockquote>
<p>维基百科：</p>
<p>在<a href="https://zh.wikipedia.org/wiki/计算机程序设计">计算机程序设计</a>中，<strong>回调函数</strong>，或简称<strong>回调</strong>（Callback 即call then back 被主函数调用运算后会返回主函数），是指通过<a href="https://zh.wikipedia.org/wiki/參數_(程式設計)">参数</a>将<a href="https://zh.wikipedia.org/wiki/子程序">函数</a>传递到其它代码的，某一块<a href="https://zh.wikipedia.org/wiki/可执行文件">可执行代码</a>的<a href="https://zh.wikipedia.org/wiki/引用_(程序设计)">引用</a>。这一设计允许了<a href="https://zh.wikipedia.org/wiki/抽象層">底层</a>代码调用在高层定义的<a href="https://zh.wikipedia.org/wiki/子程序">子程序</a>。</p>
</blockquote>
<blockquote>
<p>百度百科：</p>
<p>回调函数就是一个被作为参数传递的函数。在C语言中，回调函数只能使用函数指针实现，在C++、Python、ECMAScript等更现代的编程语言中还可以使用仿函数或匿名函数。</p>
<p>回调函数的使用可以大大提升编程的效率，这使得它在现代编程中被非常多地使用。同时，有一些需求必须要使用回调函数来实现。</p>
<p>最著名的回调函数调用有C/C++标准库stdlib.h/cstdlib中的快速排序函数qsort和二分查找函数bsearch中都会要求的一个与strcmp类似的参数，用于设置数据的比较方法。</p>
</blockquote>
<p>回调函数的理解：</p>
<ul>
<li><p>回调函数是一个函数</p></li>
<li><p>回调函数将会成为另一个函数的参数</p></li>
<li><p>在C语言中回调函数需要使用函数指针来实现</p></li>
<li><p>回调函数重要意义在于：底层的代码可以调用上层定义的子程序</p></li>
<li><p>回调函数的形象化理解：</p>
<ul>
<li>如一酒店提供叫醒服务（对应位底层实现的库函数），那么
<ul>
<li>如果不使用回调函数的思想：你提供时间（参数），则叫醒服务将会在所设置的时间叫醒你（将参数传入函数）</li>
<li>如果使用回调函数的思想：你提供时间（普通参数）和叫醒的方法（函数指针），则叫醒服务将会在所设置的时间按照你提供的方法叫醒你</li>
</ul></li>
</ul></li>
<li><p>回调函数实例：</p>
<ul>
<li><p>如你编写了一个排序函数如下（冒泡排序，<a href="https://codeantenna.com/a/sDZANVbjFJ">代码参考此处</a>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> cmd[], <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((cmd[j] &gt; cmd[j + <span class="number">1</span>])) </span><br><span class="line">            &#123;</span><br><span class="line">                temp = cmd[j];</span><br><span class="line">                cmd[j] = cmd[j + <span class="number">1</span>];</span><br><span class="line">                cmd[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此段代码中核心的判断逻辑是：</p>
<p>如果 <code>(cmd[j] &gt; cmd[j + 1])</code> ，则交换 <code>(cmd[j] &gt; cmd[j + 1])</code> ，这种方式实现效果为，较小的数字排在前面，交大的数字排在后面——正序输出，即输出结果： <code>2 25 56 88 100</code></p>
<p>这段代码存在的问题是，如果不去看 <code>sort()</code> 函数的实现，就不能去修改正序输出还是逆序输出。</p>
<p>首先我们很明显能看到，我们有控制输出为正序or逆序的需求，但是不同于自己写的Demo，我们在实际工程中，可能会出现某些情况使得我们难以修改 <code>sort()</code> 函数内部的代码：比如有些库函数的实现不是开源的，你无法查看源码或修改源码；或者有些库函数的实现代码非常复杂，你不希望全部浏览而是希望能在外部直接调用。在这些情况下，我们需要使用回调函数来帮助我们去控制库函数代码的一部分实现细节，而我们自己在书写一些供其他人使用的代码时，也可以使用回调函数来让用户自己补充一些功能细节</p></li>
<li><p>将上述代码改写为回调函数的版本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> cmd[], <span class="type">int</span> len, <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p(cmd[j], cmd[j + <span class="number">1</span>])) </span><br><span class="line">            &#123;</span><br><span class="line">                temp = cmd[j];</span><br><span class="line">                cmd[j] = cmd[j + <span class="number">1</span>];</span><br><span class="line">                cmd[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里修改的方案为：</p>
<ul>
<li>在函数参数列表中加一个函数指针提供外部接口供用户实现</li>
<li><code>if()</code> 判断中调用函数指针 <code>(*p)(cmd[j], cmd[j + 1])</code></li>
</ul></li>
<li><p>使用回调函数，实现了<strong>解耦合</strong>：</p>
<p>没有回调函数的情况下，每一个函数其功能的实现是完全确定的，如果我们想修改其中的任意一部分功能，我们都必须重写此函数。也就是说，我们想要自己调整的功能与函数实现（通常指库函数）是紧密耦合在一起的。如果我们希望从外部可以选择函数实现中的一部分细节，或者在实现函数时希望未来一部分实现方式由用户来完善，那么我们就应该使用回调函数将那部分功能与（库）函数进行解耦合。</p></li>
<li><p>验证代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">small_to_big</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">big_to_small</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &lt; y) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> cmd[], <span class="type">int</span> len, <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*p)(cmd[j], cmd[j + <span class="number">1</span>])) &#123;</span><br><span class="line">                temp = cmd[j];</span><br><span class="line">                cmd[j] = cmd[j + <span class="number">1</span>];</span><br><span class="line">                cmd[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> cmd[], <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((cmd[j] &gt; cmd[j + <span class="number">1</span>])) </span><br><span class="line">            &#123;</span><br><span class="line">                temp = cmd[j];</span><br><span class="line">                cmd[j] = cmd[j + <span class="number">1</span>];</span><br><span class="line">                cmd[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cmd[] = &#123; <span class="number">88</span>, <span class="number">56</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">25</span> &#125;;</span><br><span class="line"></span><br><span class="line">    size = <span class="keyword">sizeof</span>(cmd) / <span class="keyword">sizeof</span>(cmd[<span class="number">0</span>]);</span><br><span class="line">    sort(cmd, size, small_to_big);</span><br><span class="line">    sort(cmd, size, big_to_small);</span><br><span class="line">    <span class="comment">//sort(cmd, size);</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cmd[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p><a href="https://www.jianshu.com/p/b4cd9acd712a">回调函数一个有趣的用法</a></p>
<hr>
<p>分割线内为<a href="https://ost.51cto.com/posts/1114">引用</a></p>
<p><strong>回调函数实例（很有用）</strong></p>
<p>一个GPRS模块联网的小项目，使用过的同学大概知道2G、4G、NB等模块要想实现无线联网功能都需要经历模块上电初始化、注册网络、查询网络信息质量、连接服务器等步骤，这里的的例子就是，利用一个状态机函数（根据不同状态依次调用不同实现方法的函数），通过回调函数的方式依次调用不同的函数，实现模块联网功能，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*********  工作状态处理  *********/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">uint8_t</span> mStatus;</span><br><span class="line"> <span class="type">uint8_t</span> (* Funtion)(<span class="type">void</span>); <span class="comment">//函数指针的形式</span></span><br><span class="line">&#125; M26_WorkStatus_TypeDef;  <span class="comment">//M26的工作状态集合调用函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">** &gt;M26工作状态集合函数</span></span><br><span class="line"><span class="comment">***********************************************/</span></span><br><span class="line">M26_WorkStatus_TypeDef M26_WorkStatus_Tab[] =</span><br><span class="line">&#123;    </span><br><span class="line">    &#123;GPRS_NETWORK_CLOSE,  M26_PWRKEY_Off  &#125;, <span class="comment">//模块关机</span></span><br><span class="line">    &#123;GPRS_NETWORK_OPEN,  M26_PWRKEY_On  &#125;, <span class="comment">//模块开机</span></span><br><span class="line">    &#123;GPRS_NETWORK_Start,   M26_Work_Init  &#125;, <span class="comment">//管脚初始化</span></span><br><span class="line">    &#123;GPRS_NETWORK_CONF,  M26_NET_Config  &#125;, /AT指令配置</span><br><span class="line">    &#123;GPRS_NETWORK_LINK_CTC,  M26_LINK_CTC  &#125;, <span class="comment">//连接调度中心  </span></span><br><span class="line">    &#123;GPRS_NETWORK_WAIT_CTC, M26_WAIT_CTC  &#125;,  <span class="comment">//等待调度中心回复 </span></span><br><span class="line">    &#123;GPRS_NETWORK_LINK_FEM, M26_LINK_FEM  &#125;, <span class="comment">//连接前置机</span></span><br><span class="line">    &#123;GPRS_NETWORK_WAIT_FEM, M26_WAIT_FEM  &#125;, <span class="comment">//等待前置机回复</span></span><br><span class="line">    &#123;GPRS_NETWORK_COMM,  M26_COMM   &#125;, <span class="comment">//正常工作    </span></span><br><span class="line">    &#123;GPRS_NETWORK_WAIT_Sig,  M26_WAIT_Sig  &#125;,  <span class="comment">//等待信号回复</span></span><br><span class="line">    &#123;GPRS_NETWORK_GetSignal,  M26_GetSignal  &#125;, <span class="comment">//获取信号值</span></span><br><span class="line">    &#123;GPRS_NETWORK_RESTART,  M26_RESET   &#125;, <span class="comment">//模块重启</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************</span></span><br><span class="line"><span class="comment">** &gt;M26模块工作状态机，依次调用里面的12个函数   </span></span><br><span class="line"><span class="comment">***********************************************/</span></span><br><span class="line"><span class="type">uint8_t</span> M26_WorkStatus_Call(<span class="type">uint8_t</span> Start)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Start == M26_WorkStatus_Tab[i].mStatus)</span><br><span class="line">        &#123;          </span><br><span class="line">      <span class="keyword">return</span> M26_WorkStatus_Tab[i].Funtion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span><span class="number">.5</span><span class="number">.6</span><span class="number">.7</span><span class="number">.8</span><span class="number">.9</span><span class="number">.10</span><span class="number">.11</span><span class="number">.12</span><span class="number">.13</span><span class="number">.14</span><span class="number">.15</span><span class="number">.16</span><span class="number">.17</span><span class="number">.18</span><span class="number">.19</span><span class="number">.20</span><span class="number">.21</span><span class="number">.22</span><span class="number">.23</span><span class="number">.24</span><span class="number">.25</span><span class="number">.26</span><span class="number">.27</span><span class="number">.28</span><span class="number">.29</span><span class="number">.30</span><span class="number">.31</span><span class="number">.32</span><span class="number">.33</span><span class="number">.34</span><span class="number">.35</span><span class="number">.36</span><span class="number">.37</span><span class="number">.38</span><span class="number">.39</span><span class="number">.40</span><span class="number">.41</span>.</span><br></pre></td></tr></table></figure>
<p>复制</p>
<p>所以，如果有人想做个NB模块联网项目，可以copy上面的框架，只需要修改回调函数内部的具体实现，或者增加、减少回调函数，就可以很简洁快速的实现模块联网。</p>
<hr>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>大学物理实验绘图</title>
    <url>/2022/02/25/06-07-35/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="标准程序">标准程序</h2>
<h3 id="数据标识标准">数据标识标准</h3>
<blockquote>
<p>实验测量数据统一使用measure的首字母m做下标表示</p>
<p>标准数据使用standard的首字母s做下标表示</p>
<p>通过拟合方程计算得出的结果使用calculate的首字母c做下标表示</p>
</blockquote>
<h3 id="相对误差计算程序">相对误差计算程序</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%计算相对误差</span></span><br><span class="line">prompt = <span class="string">&#x27;请输入测量值Xm=&#x27;</span>;</span><br><span class="line">Xm = input(prompt);</span><br><span class="line">prompt = <span class="string">&#x27;请输入标准值Xs=&#x27;</span>;</span><br><span class="line">Xs = input(prompt);</span><br><span class="line"><span class="comment">%计算相对误差</span></span><br><span class="line">RelEor =<span class="built_in">abs</span>((Xm-Xs)/Xs)*<span class="number">100</span>;</span><br><span class="line">R=<span class="built_in">round</span>(RelEor,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;计算得相对误差为:&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>([num2str(R),<span class="string">&#x27;%&#x27;</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="描点作图">描点作图</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Xm=[];</span><br><span class="line">Ym=[];</span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym);</span><br></pre></td></tr></table></figure>
<h3 id="求平均值">求平均值</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Xm=[];</span><br><span class="line">Ym=[];y</span><br><span class="line">Xm_mean=<span class="built_in">mean</span>(Xm,Ym);</span><br></pre></td></tr></table></figure>
<h3 id="一元线性回归">一元线性回归</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%一元线性回归分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%写入数据:</span></span><br><span class="line">Xm=[<span class="number">-1.875</span>,<span class="number">-1.474</span>,<span class="number">-1.262</span>,<span class="number">-0.709</span>,<span class="number">-0.586</span>];</span><br><span class="line">Ym=[<span class="number">8.214</span>,<span class="number">7.408</span>,<span class="number">6.879</span>,<span class="number">5.490</span>,<span class="number">5.196</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">%进行回归分析</span></span><br><span class="line">[p,s]=polyfit(Xm,Ym,<span class="number">1</span>);<span class="comment">%p中存储有k和b的信息，s中存的信息我不知道</span></span><br><span class="line">Yc=p(<span class="number">1</span>)*Xm+p(<span class="number">2</span>);</span><br><span class="line">R2=<span class="number">1</span> - (sum((Yc- Ym).^<span class="number">2</span>) / sum((Ym - <span class="built_in">mean</span>(Ym)).^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%打印回归结果</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;打印回归分析结果:&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;y=%fx+%f\n&#x27;</span>,p(<span class="number">1</span>),p(<span class="number">2</span>));</span><br><span class="line">fprintf(<span class="string">&#x27;R^2=%f\n&#x27;</span>,R2);</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图</span></span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym,<span class="string">&#x27;o&#x27;</span>);<span class="comment">%数据点图</span></span><br><span class="line">Xp=[<span class="built_in">min</span>(Xm):<span class="number">0.1</span>:<span class="built_in">max</span>(Xm)];</span><br><span class="line">Yp=p(<span class="number">1</span>)*Xp+p(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(Xp,Yp);<span class="comment">%拟合曲线图</span></span><br><span class="line">grid on;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="绘图">绘图</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">title(<span class="string">&quot;标题&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;X轴&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;Y轴&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="隐函数族图像绘制">隐函数族图像绘制</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">z</span> = <span class="title">z</span><span class="params">(x,y,k)</span></span></span><br><span class="line">z = <span class="number">0.5</span>*x^<span class="number">2</span>+<span class="number">3</span>*x*y+<span class="number">0.5</span>*y^<span class="number">2</span>-k;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%k限定着函数族的范围</span></span><br><span class="line">k = <span class="number">-10</span>;</span><br><span class="line"><span class="keyword">while</span> k &lt; <span class="number">10</span></span><br><span class="line">    k = k + <span class="number">1</span>;</span><br><span class="line">    ezplot(@(x,y)z(x,y,k));</span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="实验数据处理">实验数据处理</h2>
<h3 id="非线性负组电路元件伏安特性">非线性负组电路元件伏安特性</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">Ym=[<span class="number">-0.002</span>,<span class="number">-0.011</span>,<span class="number">-0.031</span>,<span class="number">-0.046</span>,<span class="number">-0.072</span>,<span class="number">-0.140</span>,<span class="number">-0.618</span>,<span class="number">-0.731</span>,<span class="number">-0.894</span>,<span class="number">-1.148</span>,<span class="number">-1.582</span>,<span class="number">-1.672</span>,<span class="number">-1.688</span>,<span class="number">-1.748</span>,<span class="number">-1.901</span>,<span class="number">-2.068</span>,<span class="number">-2.250</span>,<span class="number">-2.677</span>,<span class="number">-2.926</span>,<span class="number">-3.206</span>,<span class="number">-3.888</span>,<span class="number">-4.311</span>,<span class="number">-4.806</span>,<span class="number">-6.106</span>,<span class="number">-6.276</span>,<span class="number">-6.493</span>,<span class="number">-6.618</span>,<span class="number">-6.803</span>,<span class="number">-7.195</span>,<span class="number">-8.105</span>,<span class="number">-8.656</span>,<span class="number">-9.267</span>,<span class="number">-9.962</span>,<span class="number">-10.353</span>,<span class="number">-10.766</span>,<span class="number">-11.214</span>,<span class="number">-11.214</span>,<span class="number">-11.533</span>,<span class="number">-11.645</span>,<span class="number">-11.893</span>,<span class="number">-12.094</span>,<span class="number">-12.146</span>,<span class="number">-12.273</span>,<span class="number">-12.352</span>,<span class="number">-12.457</span>];</span><br><span class="line">R=[<span class="number">300</span>,<span class="number">600</span>,<span class="number">900</span>,<span class="number">1000</span>,<span class="number">1100</span>,<span class="number">1200</span>,<span class="number">1300</span>,<span class="number">1305</span>,<span class="number">1310</span>,<span class="number">1315</span>,<span class="number">1320</span>,<span class="number">1325</span>,<span class="number">1330</span>,<span class="number">1350</span>,<span class="number">1400</span>,<span class="number">1450</span>,<span class="number">1500</span>,<span class="number">1600</span>,<span class="number">1650</span>,<span class="number">1700</span>,<span class="number">1800</span>,<span class="number">1850</span>,<span class="number">1900</span>,<span class="number">2000</span>,<span class="number">2010</span>,<span class="number">2020</span>,<span class="number">2030</span>,<span class="number">2040</span>,<span class="number">2060</span>,<span class="number">2100</span>,<span class="number">2120</span>,<span class="number">2140</span>,<span class="number">2160</span>,<span class="number">2170</span>,<span class="number">2180</span>,<span class="number">2190</span>,<span class="number">2200</span>,<span class="number">2700</span>,<span class="number">3000</span>,<span class="number">4000</span>,<span class="number">5000</span>,<span class="number">6000</span>,<span class="number">8000</span>,<span class="number">10000</span>,<span class="number">15000</span>];</span><br><span class="line">I=Ym./R;</span><br><span class="line">Xm=I;</span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym);<span class="comment">%数据点图</span></span><br><span class="line">title(<span class="string">&quot;非线性负组电路元件伏安特性&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;电流(A)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;电压(V)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="弦线上波的传播规律">弦线上波的传播规律</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%固定张力和线密度</span></span><br><span class="line">f=[<span class="number">70</span> <span class="number">90</span> <span class="number">110</span> <span class="number">130</span> <span class="number">150</span> <span class="number">180</span>];</span><br><span class="line">lamt=[<span class="number">1.22</span> <span class="number">0.9122</span> <span class="number">0.74</span> <span class="number">0.6136</span> <span class="number">0.5264</span> <span class="number">0.449</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%一元线性回归分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%写入数据:</span></span><br><span class="line">Xm=<span class="built_in">log</span>(lamt);</span><br><span class="line">Ym=<span class="built_in">log</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="comment">%进行回归分析</span></span><br><span class="line">[p,s]=polyfit(Xm,Ym,<span class="number">1</span>);<span class="comment">%p中存储有k和b的信息，s中存的信息我不知道</span></span><br><span class="line">Yc=p(<span class="number">1</span>)*Xm+p(<span class="number">2</span>);</span><br><span class="line">R2=<span class="number">1</span> - (sum((Yc- Ym).^<span class="number">2</span>) / sum((Ym - <span class="built_in">mean</span>(Ym)).^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%打印回归结果</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;打印回归分析结果:&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;y=%fx+%f\n&#x27;</span>,p(<span class="number">1</span>),p(<span class="number">2</span>));</span><br><span class="line">fprintf(<span class="string">&#x27;R^2=%f\n&#x27;</span>,R2);</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图</span></span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym,<span class="string">&#x27;o&#x27;</span>);<span class="comment">%数据点图</span></span><br><span class="line">Xp=[<span class="built_in">min</span>(Xm):<span class="number">0.1</span>:<span class="built_in">max</span>(Xm)];</span><br><span class="line">Yp=p(<span class="number">1</span>)*Xp+p(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(Xp,Yp);<span class="comment">%拟合曲线图</span></span><br><span class="line">grid on;</span><br><span class="line">title(<span class="string">&quot;log(波长)与log(频率)的拟合图像&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;log(波长)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;log(频率)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Xm</span><br><span class="line">Ym</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/25/06-07-35/image-20211106173254618.png" alt="image-20211106173254618" style="zoom:33%;"></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">打印回归分析结果:</span><br><span class="line">y=<span class="number">-0.935900</span>x+<span class="number">4.421856</span></span><br><span class="line">R^<span class="number">2</span>=<span class="number">0.998356</span></span><br><span class="line"></span><br><span class="line">Xm =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.1989</span>   <span class="number">-0.0919</span>   <span class="number">-0.3011</span>   <span class="number">-0.4884</span>   <span class="number">-0.6417</span>   <span class="number">-0.8007</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ym =</span><br><span class="line"></span><br><span class="line">    <span class="number">4.2485</span>    <span class="number">4.4998</span>    <span class="number">4.7005</span>    <span class="number">4.8675</span>    <span class="number">5.0106</span>    <span class="number">5.1930</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%固定频率和线密度</span></span><br><span class="line">T=[<span class="number">2.45</span> <span class="number">7.34</span> <span class="number">12.23</span> <span class="number">17.12</span> <span class="number">22.02</span> <span class="number">26.91</span>];</span><br><span class="line">lamt=[<span class="number">0.449</span> <span class="number">0.6850</span> <span class="number">0.8934</span> <span class="number">1.032</span> <span class="number">1.148</span> <span class="number">1.2662</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%一元线性回归分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%写入数据:</span></span><br><span class="line">Xm=<span class="built_in">log</span>(T);</span><br><span class="line">Ym=<span class="built_in">log</span>(lamt);</span><br><span class="line"></span><br><span class="line"><span class="comment">%进行回归分析</span></span><br><span class="line">[p,s]=polyfit(Xm,Ym,<span class="number">1</span>);<span class="comment">%p中存储有k和b的信息，s中存的信息我不知道</span></span><br><span class="line">Yc=p(<span class="number">1</span>)*Xm+p(<span class="number">2</span>);</span><br><span class="line">R2=<span class="number">1</span> - (sum((Yc- Ym).^<span class="number">2</span>) / sum((Ym - <span class="built_in">mean</span>(Ym)).^<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">%打印回归结果</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;打印回归分析结果:&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;y=%fx+%f\n&#x27;</span>,p(<span class="number">1</span>),p(<span class="number">2</span>));</span><br><span class="line">fprintf(<span class="string">&#x27;R^2=%f\n&#x27;</span>,R2);</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘图</span></span><br><span class="line"><span class="built_in">plot</span>(Xm,Ym,<span class="string">&#x27;o&#x27;</span>);<span class="comment">%数据点图</span></span><br><span class="line">Xp=[<span class="built_in">min</span>(Xm):<span class="number">0.1</span>:<span class="built_in">max</span>(Xm)];</span><br><span class="line">Yp=p(<span class="number">1</span>)*Xp+p(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(Xp,Yp);<span class="comment">%拟合曲线图</span></span><br><span class="line">grid on;</span><br><span class="line">title(<span class="string">&quot;log(波长)与log(周期)的拟合图像&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;log(波长)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;log(周期)&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Xm</span><br><span class="line">Ym</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/25/06-07-35/image-20211106173033589.png" alt="image-20211106173033589" style="zoom: 33%;"></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">打印回归分析结果:</span><br><span class="line">y=<span class="number">0.435631</span>x+<span class="number">-1.209052</span></span><br><span class="line">R^<span class="number">2</span>=<span class="number">0.997443</span></span><br><span class="line"></span><br><span class="line">Xm =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.8961</span>    <span class="number">1.9933</span>    <span class="number">2.5039</span>    <span class="number">2.8402</span>    <span class="number">3.0920</span>    <span class="number">3.2925</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ym =</span><br><span class="line"></span><br><span class="line">   <span class="number">-0.8007</span>   <span class="number">-0.3783</span>   <span class="number">-0.1127</span>    <span class="number">0.0315</span>    <span class="number">0.1380</span>    <span class="number">0.2360</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="磁滞曲线">磁滞曲线</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="number">0.2</span>:<span class="number">3</span>;</span><br><span class="line">&gt;&gt; y1=[<span class="number">-1.4</span>,<span class="number">-1.2</span>,<span class="number">-1.1</span>,<span class="number">-1.0</span>,<span class="number">-0.9</span>,<span class="number">-0.8</span>,<span class="number">-0.6</span>,<span class="number">-0.3</span>,<span class="number">0</span>,<span class="number">0.4</span>,<span class="number">0.7</span>,<span class="number">1.1</span>,<span class="number">1.4</span>,<span class="number">1.8</span>,<span class="number">1.9</span>,<span class="number">2.0</span>];</span><br><span class="line">&gt;&gt; y2=[<span class="number">1.4</span> <span class="number">1.3</span> <span class="number">1.4</span> <span class="number">1.4</span> <span class="number">1.6</span> <span class="number">1.6</span> <span class="number">1.6</span> <span class="number">1.7</span> <span class="number">1.7</span> <span class="number">1.8</span> <span class="number">1.8</span> <span class="number">1.8</span> <span class="number">1.8</span> <span class="number">1.9</span> <span class="number">2.0</span> <span class="number">2.0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(x,y1)</span><br><span class="line">&gt;&gt; <span class="built_in">hold</span> on</span><br><span class="line">&gt;&gt; <span class="built_in">plot</span>(x,y2)</span><br><span class="line">&gt;&gt; <span class="built_in">plot</span>(-x,-y2)</span><br><span class="line">&gt;&gt; <span class="built_in">hold</span> on</span><br><span class="line">&gt;&gt; <span class="built_in">plot</span>(-x,-y1)</span><br><span class="line"></span><br><span class="line">title(<span class="string">&quot;磁滞曲线&quot;</span>,<span class="string">&#x27;FontName&#x27;</span>,<span class="string">&#x27;SimHei&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/02/25/06-07-35/Users\qjy\Desktop\untitled.png" alt="untitled"><figcaption aria-hidden="true">untitled</figcaption>
</figure>
]]></content>
      <tags>
        <tag>备忘笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>常微分方程笔记</title>
    <url>/2022/02/25/05-07-35/</url>
    <content><![CDATA[<p>​</p>
<p>[TOC]</p>
<hr>
<h3 id="分类和解法">分类和解法</h3>
<h4 id="一阶线性方程">一阶线性方程</h4>
<p>$$ First,order,linear,differential,equation:x'+p(t)x=q(t) \\ solution:</p>
<p>e<sup>{<em>{}{}{p(t)}dt}x'+e^{</em>{}{}{p(t)}dt}p(t)x=e</sup>{<em>{}{}{p(t)}dt}q(t) \  \ (e^{</em>{}{}{p(t)}dt}x)'=e^{_{}{}{p(t)}dt}q(t) $$</p>
<h4 id="变量分离方程">变量分离方程</h4>
<p><span class="math display">\[
Separable\,equation : x&#39;=h(t)g(x) \qquad g(x)!= 0
\\\\
solution:x&#39;=h(t)g(x) \xrightarrow{x&#39;=\frac{dx}{dt}} \frac{dx}{g(x)}=h(t)dt
\\
\Downarrow 
\\
\int_{}{}{\frac{1}{g(x)}}dx=\int_{}{}{h(t)}dt
\]</span></p>
<h4 id="恰当方程">恰当方程</h4>
<p><span class="math display">\[
Exact\,equation:
\begin{cases}
M(x,y)dx+N(x,y)dy=0\\
\\
N_x=M_y\\
\end{cases}
\\\\
\]</span></p>
<h3 id="二阶线性常微分方程">二阶线性常微分方程</h3>
<p>最一般的二阶线性微分方程为： <span class="math display">\[
a_0(t)x&#39;&#39;+a_1(t)x&#39;+a_2(t)x=g(t)
\]</span> 下述讨论中，我们仅讨论<span class="math inline">\(a_0(t)\not=0\)</span>的情况</p>
<p>即： <span class="math display">\[
x&#39;&#39;+p(t)x&#39;+q(t)x=f(t)
\]</span></p>
<h4 id="齐次方程">齐次方程：</h4>
<p>求解目标： <span class="math display">\[
x&#39;&#39;+p(t)x&#39;+q(t)x=0\tag{1}
\]</span> 求齐次方程通解的方法：</p>
<ol type="1">
<li><p>找到两个特解<span class="math inline">\(x_1\)</span>与<span class="math inline">\(x_2\)</span></p>
<ol type="1">
<li><p>如果不能找到两个特解，那就先找到一个特解<span class="math inline">\(x_1\)</span>，那么<span class="math inline">\(x_2\)</span>为：</p>
<ol type="1">
<li>设<span class="math inline">\(x_2=v_1(t)x_1\)</span>，将<span class="math inline">\(x_2\)</span>带入到<span class="math inline">\(x&#39;&#39;+p(t)x&#39;+q(t)x=0\)</span>中，整理求出<span class="math inline">\(v_1(t)\)</span></li>
</ol>
<p><span class="math display">\[
x_2=x_1\int \frac{e^{-\int p(t)dt}}{x_1^2}dt
\]</span></p></li>
<li><p>如果一个特解也找不到：</p>
<p>？？？？？</p></li>
</ol></li>
<li><p>验证两个特解<strong>线性无关</strong>:<span class="math inline">\(W(t)\not=0\)</span></p>
<ol type="1">
<li><p>Remark：若<span class="math inline">\(x_1\)</span>与<span class="math inline">\(x_2\)</span>是二阶常微分方程的解，则：<span class="math inline">\(x_1\)</span>与<span class="math inline">\(x_2\)</span>线性相关<span class="math inline">\(\,\Leftrightarrow W(x_1,x_2)(t)=0\)</span></p></li>
<li><p>其中： <span class="math display">\[
W(x_1,x_2)(t)=\begin{vmatrix}
x_1 &amp; x_2\\
x_1&#39; &amp; x_2&#39;
\end{vmatrix}=x_1x_2&#39;-x_1&#39;x_2
\]</span></p></li>
</ol></li>
<li><p>若两特解线性无关，则齐次方程(1)式的通解为：<span class="math inline">\(x=c_1x_1+c_2x_2\)</span></p></li>
</ol>
<h4 id="非齐次方程">非齐次方程</h4>
<p>求解目标： <span class="math display">\[
x&#39;&#39;+p(t)x&#39;+q(t)x=f(t)\tag{2}
\]</span> 求非齐次方程通解的方法：</p>
<ol type="1">
<li><p>先令<span class="math inline">\(f(t)\equiv 0\)</span>，求出<span class="math inline">\(x&#39;&#39;+p(t)x&#39;+q(t)x=f(t)\)</span>的通解<span class="math inline">\(x_1\)</span>与<span class="math inline">\(x_2\)</span></p></li>
<li><p>非齐次方程的通解可以表示为：<span class="math inline">\(x=c_1x_1+c_2x_2+x_p\)</span>，其中<span class="math inline">\(x_p=v_1(t)x_1+v_2(t)x_2\)</span></p></li>
<li><p>求解<span class="math inline">\(v_1(t),v_2(t)\)</span></p>
<ol type="1">
<li><p>列方程组 <span class="math display">\[
\begin{cases}
\begin{aligned}
v_1&#39;x_1+v_2&#39;x_2&amp;=0\\\\
v_1&#39;x_1&#39;+v_2&#39;x_2&#39;&amp;=f(t)
\end{aligned}
\end{cases}
\]</span></p></li>
<li><p>利用克莱姆法则：</p>
<ul>
<li><p>克莱姆法则：</p>
<p><img src="/2022/02/25/05-07-35/image-20211126105116954.png" alt="image-20211126105116954" style="zoom:33%;"></p>
<p><img src="/2022/02/25/05-07-35/Users\qjy\AppData\Roaming\Typora\typora-user-images\image-20211126105131958.png" alt="image-20211126105131958" style="zoom:33%;"></p></li>
</ul>
<p><span class="math display">\[
v1&#39;=\frac{\begin{vmatrix}0 &amp; x_2\\f(t) &amp; x_1&#39;\end{vmatrix}}{W(t)}=-\frac{x_2f(t)}{W(t)}\\\\
v2&#39;=\frac{\begin{vmatrix}x_1 &amp; 0\\x_1&#39; &amp; f(t)\end{vmatrix}}{W(t)}=-\frac{x_1f(t)}{W(t)}
\]</span></p></li>
<li><p>最终对<span class="math inline">\(v_1&#39;\)</span>和<span class="math inline">\(v_2&#39;\)</span>进行积分 <span class="math display">\[
v_1=\int{}v_1&#39;dt\,,\:v_2=\int{}v_2&#39;dt,
\]</span></p></li>
</ol></li>
<li><p>最终得到非齐次方程的通解：<span class="math inline">\(x=c_1x_1+c_2x_2+x_p\)</span></p></li>
</ol>
<h4 id="常系数的二阶微分方程">常系数的二阶微分方程</h4>
<p>求解目标： <span class="math display">\[
ax&#39;&#39;+bx&#39;+cx=0\,,\:(a\not= 0)
\]</span> 求解方法： <span class="math display">\[
Let\;\;x=e^{mt}\;x&#39;=me^{mt}\;x&#39;&#39;=m^2e^{mt}\\ \Downarrow\\
ax&#39;&#39;+bx&#39;+cx=am^2e^{mt}+bme^{mt}+ce^{mt}=0\\ \Downarrow\\
e^{mt}(am^2+bm+c)=0
\]</span> 对于：<span class="math inline">\(am^2+bm+c=0\)</span></p>
<ul>
<li><p>case 1: <span class="math display">\[
\Delta &gt; 0\\
&amp;m_1=\frac{-b+\sqrt{b^2-4ac}}{2a}\\
&amp;m_2=\frac{-b-\sqrt{b^2-4ac}}{2a}\\
so\\
&amp;x_1=e^{m_1t}\;x_2=e^{m_2t}\\
&amp;x=c_1x_1+c_2x_2=c_1e^{m_1t}+c_2e^{m_2t}
\]</span></p></li>
<li><p>case 2: <span class="math display">\[
\Delta = 0\\
&amp;m=-\frac{b}{2a}\\
so\\
&amp;x_1=e^{mt}=e^{-\frac{b}{2a}t}\\
&amp;x_2=te^{-\frac{b}{2a}t}\\
&amp;x=c_1x_1+c_2x_2=c_1e^{-\frac{b}{2a}t}+c_2te^{-\frac{b}{2a}t}
\]</span></p></li>
<li><p>case 3: <span class="math display">\[
i^2=-1
\]</span></p>
<p>$$ =b^2-4ac &lt; 0\ &amp;m==i=i\</p>
<p>&amp;x=e^{t}(cos(t)+isin(t)) $$</p></li>
</ul>
<h4 id="欧拉等式">欧拉等式</h4>
<p>求解目标： <span class="math display">\[
at^2x&#39;&#39;+btx&#39;+cx=0
\]</span> 求解方法：</p>
<ol type="1">
<li><p>首先令：<span class="math inline">\(t=e^s,s=lnt\)</span></p></li>
<li><p>则有：<span class="math inline">\(x&#39;(s)=tx&#39;(t);\, x&#39;&#39;(s)-x&#39;(s)=t^2x&#39;&#39;(t)\)</span></p></li>
<li><p>上面两个式子带入<span class="math inline">\(at^2x&#39;&#39;+btx&#39;+cx=0\)</span>有：</p>
<p><span class="math inline">\(\begin{aligned}at^2x(t)&#39;&#39;+btx(t)&#39;+cx(t)\\&amp;=a(x&#39;&#39;(s)-x&#39;(s))+bx&#39;(s)+cx(s)\\&amp;=ax&#39;&#39;(s)+(b-a)x&#39;(s)+cx(s)\\&amp;=0\end{aligned}\)</span></p></li>
<li><p>根据常系数的二阶微分方程的求解方法：<span class="math inline">\(e^{mt}(am^2+(b-a)m+c)=0\)</span></p></li>
<li><p><span class="math display">\[
(am^2+(b-a)m+c)=0\;\;\sf{分三种情况讨论：}
\begin{cases}
\begin{aligned}
\Delta&gt;0\\\\
\Delta=0\\\\
\Delta&lt;0\\\\
\end{aligned}
\end{cases}
\]</span></p></li>
</ol>
<p>如果<span class="math inline">\(A\)</span>是一个<span class="math inline">\(n × n\)</span>矩阵，那么下列语句是等价的。</p>
<ol type="1">
<li><span class="math inline">\(A\)</span>是可逆的。</li>
<li><span class="math inline">\(Ax = 0\)</span>只有平凡解。</li>
<li><span class="math inline">\(A\)</span>的行简化阶梯形是<span class="math inline">\(I_n\)</span>。</li>
<li>A可以表示为初等矩阵的乘积.</li>
<li><span class="math inline">\(Ax = b\)</span>对每个<span class="math inline">\(n × 1\)</span>矩阵<span class="math inline">\(b\)</span>都是一致的。</li>
<li><span class="math inline">\(Ax = b\)</span>对每个<span class="math inline">\(n × 1\)</span>矩阵<span class="math inline">\(b\)</span>只有一个解</li>
<li><span class="math inline">\(det(A) \not= 0\)</span></li>
<li><span class="math inline">\(A\)</span>的列向量是线性无关的。</li>
<li><span class="math inline">\(A\)</span>的行向量是线性无关的。</li>
<li><span class="math inline">\(A\)</span>张成空间<span class="math inline">\(R_n\)</span>的列向量。</li>
<li><span class="math inline">\(A\)</span>的行向量张成<span class="math inline">\(R_n\)</span>。</li>
<li><span class="math inline">\(A\)</span>的列向量形成<span class="math inline">\(R_n\)</span>的一组基。</li>
<li><span class="math inline">\(A\)</span>的行向量形成<span class="math inline">\(R_n\)</span>的一组基。</li>
<li><span class="math inline">\(A\)</span>的等级是<span class="math inline">\(n\)</span>。</li>
<li><span class="math inline">\(A\)</span>的零度为零。</li>
<li><span class="math inline">\(A\)</span>的零空间的正交补是<span class="math inline">\(R_n\)</span>。</li>
<li><span class="math inline">\(A\)</span>的行空间的正交补是<span class="math inline">\(\{0\}\)</span>。</li>
</ol>
<p>线性相关性，两种表述方式 <span class="math display">\[
x_3=c_1x_1+c_2x_2\\
\]</span> 线性无关：只有系数全为0时线性组合才恒为0</p>
<p>线性相关：能找出一组非零常数使得线性组合结果为0</p>
<h2 id="高阶微分方程">高阶微分方程</h2>
<h3 id="线性微分方程的一般理论">线性微分方程的一般理论</h3>
<p>本章讨论的问题：求解微分方程（高阶导数使用数字上标表示） <span class="math display">\[
x^n+a_1x^{n-1}+\cdot\cdot\cdot+a_{n-1}x&#39;+a_n=f(t)\tag{1}
\]</span></p>
<ol type="1">
<li><p>齐次形式： <span class="math display">\[
x^n+a_1x^{n-1}+\cdot\cdot\cdot+a_{n-1}x&#39;+a_n=f(t)\tag{2}
\]</span></p></li>
<li><p>解的存在唯一性：</p>
<p>如果<span class="math inline">\(a_i(t)(i=1,2,\cdot\cdot\cdot,n)\)</span>及<span class="math inline">\(f(t)\)</span>都是$a t b <span class="math inline">\(上的连续函数，则对于任一\)</span>t_0<span class="math inline">\(及任意的\)</span>x_0<span class="math inline">\(，\)</span>x_0'<span class="math inline">\(，\)</span><span class="math inline">\(，\)</span>x_0^{(n-1)}<span class="math inline">\(，方程（1）存在唯一解\)</span>x(t)<span class="math inline">\(，符号记为\)</span>x=(t)<span class="math inline">\(，定义于\)</span>a t b $，且满足初值条件： <span class="math display">\[
\varphi(t_0)=x_0,\;\varphi(t_0)&#39;=x_0&#39;,\;\varphi(t_0)^{(n-1)}=x_0^{(n-1)}
\]</span></p></li>
</ol>
<h4 id="齐次线性微分方程解的性质和结构"><code>齐次线性微分方程解</code>的性质和结构</h4>
<ol type="1">
<li><code>齐次线性微分方程的解</code>的<code>叠加原理</code>
<ol type="1">
<li>描述：<code>齐次线性微分方程的解</code>的<code>线性叠加</code>仍为<code>齐次线性微分方程的解</code></li>
<li>原理：
<ol type="1">
<li>常数可以从微分号下提出来</li>
<li>和的导数等于导数的和</li>
</ol></li>
<li>问题：什么情况下解的线性组合可以成为齐次线性微分方程的通解？</li>
</ol></li>
<li></li>
</ol>
<p>变量分离方程：</p>
<p>解法：</p>
<ol type="1">
<li>非初值问题
<ol type="1">
<li>先研究是否存在常数解：<span class="math inline">\(g(k)=0;x(t)=k\)</span>是方程的解</li>
<li>再研究非常数解：<span class="math inline">\(\int_{}{}{\frac{1}{g(x)}}dx=\int_{}{}{h(t)}dt\)</span></li>
</ol></li>
<li>初值问题
<ol type="1">
<li>先研究是否存在常数解：<span class="math inline">\(g(k)=0;x(t)=k\)</span>是方程的解
<ol type="1">
<li>若<span class="math inline">\(x=0\)</span>是方程的解，则<span class="math inline">\(x\)</span>要么恒大于0，要么恒小于0</li>
</ol></li>
<li>再研究非常数解：<span class="math inline">\(\int_{}{}{\frac{1}{g(x)}}dx=\int_{}{}{h(t)}dt\)</span>，其中<span class="math inline">\(g(x)\not=0\)</span></li>
<li>最后使用<span class="math inline">\(x(t_0)=x_0\)</span>求解常数<span class="math inline">\(c\)</span></li>
</ol></li>
</ol>
<p>备注：如果求解出的<span class="math inline">\(x(t)\)</span>的分母可以等于0，那么要排除等于0的点；如果带有初值，那么t的取值范围为带有初值的那一部分</p>
<p>如何寻找常数解？对于常数解，我们7有<span class="math inline">\(x&#39;=0\)</span>，所以只要寻找使得方程右边为<span class="math inline">\(0\)</span>的常数<span class="math inline">\(k\)</span>就好了</p>
<p>存在唯一性定理：</p>
<p>解的存在和个数由f在(x0,t0)附近的性质决定</p>
<p>如果f在(x0,t0)附近连续即可知初值问题至少存在局部唯一解</p>
<p>如果f在(x0,t0)附近连续 &amp;&amp; <span class="math inline">\(f_x\)</span>在(x0,t0)上连续 =&gt; 解在局部唯一</p>
<p>如果f在(x0,t0)附近连续 &amp;&amp; <span class="math inline">\(f_x\)</span>在(x0,t0)上连续 &amp;&amp; 偏导数在一条形区域内有界 =&gt; 则在条形区间内有唯一解</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学公式(Latex)</title>
    <url>/2022/02/20/23-32-35/</url>
    <content><![CDATA[<h1 id="数学公式latex">数学公式(LATEX)</h1>
<h3 id="测试">测试：</h3>
<p>行内公式测试：<span class="math inline">\(A_a\)</span>，希腊字母：<span class="math inline">\(\beta\)</span></p>
<p>行间公式测试： <span class="math display">\[
f(t)=a_t
\]</span> 换行测试</p>
<ol type="1">
<li><p>行内 <span class="math inline">\(\begin{gather*}a_2\\d^5\end{gather*}\)</span> 行内测试完毕</p></li>
<li><p>行间 <span class="math display">\[
\begin{gather*}
a_2\\
d^5
\end{gather*}、
\]</span></p></li>
</ol>
<p>可以正常渲染公式。</p>
<h3 id="常用">常用</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;gather*&#125;</span><br><span class="line">上下标：y<span class="built_in">_</span>下标=x<span class="built_in">^</span>上标<span class="keyword">\\</span></span><br><span class="line">分式与求导:<span class="keyword">\frac</span>&#123;分子&#125;&#123;分母&#125;<span class="keyword">\\</span></span><br><span class="line">求导：求导其实就是输入字母<span class="keyword">\\</span></span><br><span class="line">积分：<span class="keyword">\int</span><span class="built_in">_</span>&#123;积分下限&#125;<span class="built_in">^</span>&#123;积分上限&#125;&#123;积分变量&#125;d被积变量<span class="keyword">\\</span></span><br><span class="line">大括号:</span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">括号内第一行<span class="keyword">\\</span></span><br><span class="line">括号内第二行<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;<span class="keyword">\\</span></span><br><span class="line">极限:<span class="keyword">\lim</span><span class="built_in">_</span>&#123;n<span class="keyword">\rightarrow</span><span class="keyword">\infty</span>&#125;&#123;x&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vec</span>&#123;向量&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\sum</span><span class="built_in">_</span>&#123;n=起始值&#125;<span class="built_in">^</span>&#123;终值&#125;&#123;a<span class="built_in">_</span>n&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\prod</span><span class="built_in">_</span>&#123;n=起始值&#125;<span class="built_in">^</span>&#123;终值&#125;&#123;a<span class="built_in">_</span>n&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\sqrt</span> e<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\approx</span></span><br><span class="line"><span class="keyword">\end</span>&#123;gather*&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
上下标：y_下标=x^上标\\
分式与求导:\frac{分子}{分母}\\
求导：求导其实就是输入字母\\
积分：\int_{积分下限}^{积分上限}{积分变量}d被积变量\\
大括号:
\begin{cases}
括号内第一行\\
括号内第二行\\
\end{cases}\\
极限:\lim_{n\rightarrow\infty}{x}\\
\vec{向量}\\
\sum_{n=起始值}^{终值}{a_n}\\
\prod_{n=起始值}^{终值}{a_n}\\
\sqrt e\\
\approx
\end{gather*}
\]</span></p>
<h3 id="运算符">运算符</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">-</span><br><span class="line"><span class="keyword">\times</span></span><br><span class="line">/</span><br><span class="line"><span class="keyword">\div</span></span><br><span class="line"><span class="keyword">\cdot</span></span><br><span class="line"><span class="keyword">\#</span></span><br><span class="line"><span class="keyword">\%</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
+
-
\times
/
\div
\cdot
\#
\%
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\cap</span></span><br><span class="line"><span class="keyword">\cup</span></span><br><span class="line"><span class="keyword">\land</span></span><br><span class="line"><span class="keyword">\lor</span></span><br><span class="line"><span class="keyword">\sqcup</span></span><br><span class="line"><span class="keyword">\sqcap</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\cap
\cup
\land
\lor
\sqcup
\sqcap
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\circ</span></span><br><span class="line"><span class="keyword">\ast</span></span><br><span class="line"><span class="keyword">\star</span></span><br><span class="line"><span class="keyword">\otimes</span></span><br><span class="line"><span class="keyword">\oplus</span></span><br><span class="line"><span class="keyword">\odot</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\circ
\ast
\star
\otimes
\oplus
\odot
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\pm</span></span><br><span class="line"><span class="keyword">\mp</span></span><br><span class="line"><span class="keyword">\dotplus</span></span><br><span class="line"><span class="keyword">\divideontimes</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\pm
\mp
\dotplus
\divideontimes
\]</span></p>
<h4 id="约等于">约等于</h4>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">=</span><br><span class="line">= <span class="keyword">\not</span></span><br><span class="line"><span class="keyword">\equiv</span></span><br><span class="line"><span class="keyword">\approx</span></span><br><span class="line"><span class="keyword">\approxeq</span></span><br><span class="line"><span class="keyword">\cong</span></span><br><span class="line"><span class="keyword">\sim</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
=
= \not
\equiv
\approx
\approxeq
\cong
\sim
\]</span></p>
<h4 id="比较">比较</h4>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&lt;</span><br><span class="line">&gt;<span class="keyword">\\</span></span><br><span class="line">0 <span class="keyword">\le</span> <span class="keyword">\omega</span> t <span class="keyword">\le</span> <span class="keyword">\pi</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\ge</span></span><br><span class="line"><span class="keyword">\gg</span></span><br><span class="line"><span class="keyword">\ll</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
&lt;
&gt;\\
0 \le \omega t \le \pi \\
\ge
\gg
\ll
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\curlyeqprec</span></span><br><span class="line"><span class="keyword">\curlyeqsucc</span></span><br><span class="line"><span class="keyword">\prec</span></span><br><span class="line"><span class="keyword">\succ</span></span><br><span class="line"><span class="keyword">\preceq</span></span><br><span class="line"><span class="keyword">\succeq</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\curlyeqprec
\curlyeqsucc
\prec
\succ
\preceq
\succeq
\]</span></p>
<h3 id="集合逻辑相关">集合/逻辑相关</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\in</span></span><br><span class="line"><span class="keyword">\owns</span> <span class="keyword">\not</span></span><br><span class="line"><span class="keyword">\subset</span> <span class="keyword">\not</span></span><br><span class="line"><span class="keyword">\supset</span></span><br><span class="line"><span class="keyword">\subseteq</span></span><br><span class="line"><span class="keyword">\supseteq</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\cap</span></span><br><span class="line"><span class="keyword">\cup</span></span><br><span class="line"><span class="keyword">\land</span></span><br><span class="line"><span class="keyword">\lor</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\neg</span></span><br><span class="line"><span class="keyword">\emptyset</span></span><br><span class="line"><span class="keyword">\varnothing</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\because</span></span><br><span class="line"><span class="keyword">\forall</span></span><br><span class="line"><span class="keyword">\exists</span></span><br><span class="line"><span class="keyword">\therefore</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\in
\owns \not
\subset \not
\supset
\subseteq
\supseteq
\\
\cap
\cup
\land
\lor
\\
\neg
\emptyset
\varnothing
\\
\because
\forall
\exists
\therefore
\]</span></p>
<h3 id="箭头">箭头</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\gets</span></span><br><span class="line"><span class="keyword">\leftarrow</span></span><br><span class="line"><span class="keyword">\to</span></span><br><span class="line"><span class="keyword">\rightarrow</span></span><br><span class="line"><span class="keyword">\leftrightarrow</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\uparrow</span></span><br><span class="line"><span class="keyword">\downarrow</span></span><br><span class="line"><span class="keyword">\updownarrow</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\gets
\leftarrow
\to
\rightarrow
\leftrightarrow
\\
\uparrow
\downarrow
\updownarrow
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\Leftarrow</span></span><br><span class="line"><span class="keyword">\Rightarrow</span></span><br><span class="line"><span class="keyword">\Leftrightarrow</span></span><br><span class="line"><span class="keyword">\iff</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\Uparrow</span></span><br><span class="line"><span class="keyword">\Downarrow</span></span><br><span class="line"><span class="keyword">\Updownarrow</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\Leftarrow
\Rightarrow
\Leftrightarrow
\iff
\\
\Uparrow
\Downarrow
\Updownarrow
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\nearrow</span></span><br><span class="line"><span class="keyword">\searrow</span></span><br><span class="line"><span class="keyword">\swarrow</span></span><br><span class="line"><span class="keyword">\nwarrow</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\nearrow
\searrow
\swarrow
\nwarrow
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\leftharpoonup</span></span><br><span class="line"><span class="keyword">\leftharpoondown</span></span><br><span class="line"><span class="keyword">\rightharpoonup</span></span><br><span class="line"><span class="keyword">\rightharpoondown</span></span><br><span class="line"><span class="keyword">\rightleftharpoons</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\leftharpoonup
\leftharpoondown
\rightharpoonup
\rightharpoondown
\rightleftharpoons
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mapsto</span></span><br><span class="line"><span class="keyword">\leadsto</span></span><br><span class="line"><span class="keyword">\hookleftarrow</span></span><br><span class="line"><span class="keyword">\hookrightarrow</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\mapsto
\leadsto
\hookleftarrow
\hookrightarrow
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\longleftarrow</span></span><br><span class="line"><span class="keyword">\longrightarrow</span></span><br><span class="line"><span class="keyword">\longleftrightarrow</span></span><br><span class="line"><span class="keyword">\Longleftarrow</span></span><br><span class="line"><span class="keyword">\Longrightarrow</span></span><br><span class="line"><span class="keyword">\Longleftrightarrow</span></span><br><span class="line"><span class="keyword">\longmapsto</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\longleftarrow
\longrightarrow
\longleftrightarrow
\Longleftarrow
\Longrightarrow
\Longleftrightarrow
\longmapsto
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\xrightarrow</span>&#123;over&#125;</span><br><span class="line"><span class="keyword">\xrightarrow</span>[over]&#123;&#125;</span><br><span class="line"><span class="keyword">\xrightarrow</span>[under]&#123;over&#125;</span><br><span class="line"><span class="keyword">\xleftarrow</span>[]&#123;over&#125;</span><br><span class="line"><span class="keyword">\xleftarrow</span>[under]&#123;&#125;</span><br><span class="line"><span class="keyword">\xleftarrow</span>[under]&#123;over&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\xrightarrow{over}
\xrightarrow[over]{}
\xrightarrow[under]{over}
\xleftarrow[]{over}
\xleftarrow[under]{}
\xleftarrow[under]{over}
\]</span></p>
<h3 id="空格间距">空格间距</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;gather*&#125;</span><br><span class="line"><span class="keyword">\sf</span>&#123;紧贴 + 无空格 + 小空格 + 中空格 + 大空格 + 真空格 + 双真空格&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\it</span>&#123;a<span class="keyword">\!</span>b + ab + a<span class="keyword">\,</span>b + a<span class="keyword">\;</span>b + a<span class="keyword">\ </span>b + a<span class="keyword">\quad</span> b + a<span class="keyword">\qquad</span> b&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;gather*&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
\sf{紧贴 + 无空格 + 小空格 + 中空格 + 大空格 + 真空格 + 双真空格}\\
\it{a\!b + ab + a\,b + a\;b + a\ b + a\quad b + a\qquad b}\\
\end{gather*}
\]</span></p>
<h3 id="希腊字母表">希腊字母表</h3>
<table>
<thead>
<tr class="header">
<th>希腊字母</th>
<th>希腊字母</th>
<th>希腊字母</th>
<th>希腊字母</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\alpha\)</span></td>
<td><span class="math inline">\(\beta\)</span></td>
<td><span class="math inline">\(\gamma\)</span></td>
<td><span class="math inline">\(\phi\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\nu\)</span></td>
<td><span class="math inline">\(\epsilon\)</span></td>
<td><span class="math inline">\(\varepsilon\)</span></td>
<td><span class="math inline">\(\varrho\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\Delta\)</span></td>
<td><span class="math inline">\(\pi\)</span></td>
<td><span class="math inline">\(\psi\)</span></td>
<td><span class="math inline">\(\varDelta\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\varPsi\)</span></td>
<td><span class="math inline">\(\zeta\)</span></td>
<td><span class="math inline">\(\kappa\)</span></td>
<td><span class="math inline">\(\xi\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\chi\)</span></td>
<td><span class="math inline">\(\varkappa\)</span></td>
<td><span class="math inline">\(\varsigma\)</span></td>
<td><span class="math inline">\(\Theta\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\Omega\)</span></td>
<td><span class="math inline">\(\varTheta\)</span></td>
<td><span class="math inline">\(\varSigma\)</span></td>
<td><span class="math inline">\(\varOmega\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\lambda\)</span></td>
<td><span class="math inline">\(\omicron\)</span></td>
<td><span class="math inline">\(\tau\)</span></td>
<td><span class="math inline">\(\psi\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\varphi\)</span></td>
<td><span class="math inline">\(\Lambda\)</span></td>
<td><span class="math inline">\(\Upsilon\)</span></td>
<td><span class="math inline">\(\varLambda\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\delta\)</span></td>
<td><span class="math inline">\(\theta\)</span></td>
<td><span class="math inline">\(\mu\)</span></td>
<td><span class="math inline">\(\pi\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(\omega\)</span></td>
<td><span class="math inline">\(\varpi\)</span></td>
<td><span class="math inline">\(\digamma\)</span></td>
<td><span class="math inline">\(\partial\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\imath\)</span></td>
<td><span class="math inline">\(\jmath\)</span></td>
<td><span class="math inline">\(\aleph\)</span></td>
<td><span class="math inline">\(\hbar\)</span></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">No.</th>
<th style="text-align: center;">Lowercase</th>
<th style="text-align: center;">Uppercase</th>
<th style="text-align: center;">English</th>
<th style="text-align: center;">IPA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td>
<td style="text-align: center;"><span class="math inline">\(A\)</span></td>
<td style="text-align: center;"><span class="math inline">\(alpha\)</span></td>
<td style="text-align: center;"><strong>/'ælfə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\beta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(B\)</span></td>
<td style="text-align: center;"><span class="math inline">\(beta\)</span></td>
<td style="text-align: center;"><strong>/'bi:tə/or/'beɪtə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\gamma\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Gamma\)</span></td>
<td style="text-align: center;"><span class="math inline">\(gamma\)</span></td>
<td style="text-align: center;"><strong>/'gæmə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(4\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\delta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Delta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(delta\)</span></td>
<td style="text-align: center;"><strong>/'deltə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(5\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\epsilon\)</span></td>
<td style="text-align: center;"><span class="math inline">\(E\)</span></td>
<td style="text-align: center;"><span class="math inline">\(epsilon\)</span></td>
<td style="text-align: center;"><strong>/'epsɪlɒn/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(6\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\zeta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(Z\)</span></td>
<td style="text-align: center;"><span class="math inline">\(zeta\)</span></td>
<td style="text-align: center;"><strong>/'zi:tə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(7\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\eta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(H\)</span></td>
<td style="text-align: center;"><span class="math inline">\(eta\)</span></td>
<td style="text-align: center;"><strong>/'i:tə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(8\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\theta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Theta\)</span></td>
<td style="text-align: center;"><span class="math inline">\(theta\)</span></td>
<td style="text-align: center;"><strong>/'θi:tə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(9\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\iota\)</span></td>
<td style="text-align: center;"><span class="math inline">\(I\)</span></td>
<td style="text-align: center;"><span class="math inline">\(iota\)</span></td>
<td style="text-align: center;"><strong>/aɪ'əʊtə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(10\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\kappa\)</span></td>
<td style="text-align: center;"><span class="math inline">\(K\)</span></td>
<td style="text-align: center;"><span class="math inline">\(kappa\)</span></td>
<td style="text-align: center;"><strong>/'kæpə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(11\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td>
<td style="text-align: center;"><span class="math inline">\(lambda\)</span></td>
<td style="text-align: center;"><strong>/'læmdə/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(12\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\mu\)</span></td>
<td style="text-align: center;"><span class="math inline">\(M\)</span></td>
<td style="text-align: center;"><span class="math inline">\(mu\)</span></td>
<td style="text-align: center;"><strong>/mju:/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(13\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\nu\)</span></td>
<td style="text-align: center;"><span class="math inline">\(N\)</span></td>
<td style="text-align: center;"><span class="math inline">\(nu\)</span></td>
<td style="text-align: center;"><strong>/nju:/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(14\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\xi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Xi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(xi\)</span></td>
<td style="text-align: center;"><strong>/ksi/or/'zaɪ/or/'ksaɪ/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(15\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\omicron\)</span></td>
<td style="text-align: center;"><span class="math inline">\(O\)</span></td>
<td style="text-align: center;"><span class="math inline">\(omicron\)</span></td>
<td style="text-align: center;"><strong>/əu'maikrən/or/'ɑmɪ,krɑn/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(16\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\pi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Pi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(pi\)</span></td>
<td style="text-align: center;"><strong>/paɪ/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(17\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\rho\)</span></td>
<td style="text-align: center;"><span class="math inline">\(P\)</span></td>
<td style="text-align: center;"><span class="math inline">\(rho\)</span></td>
<td style="text-align: center;"><strong>/rəʊ/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(18\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\sigma\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Sigma\)</span></td>
<td style="text-align: center;"><span class="math inline">\(sigma\)</span></td>
<td style="text-align: center;"><strong>/'sɪɡmə/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(19\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\tau\)</span></td>
<td style="text-align: center;"><span class="math inline">\(T\)</span></td>
<td style="text-align: center;"><span class="math inline">\(tau\)</span></td>
<td style="text-align: center;"><strong>/tɔ:/or/taʊ/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(20\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\upsilon\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Upsilon\)</span></td>
<td style="text-align: center;"><span class="math inline">\(upsilon\)</span></td>
<td style="text-align: center;"><strong>/'ipsilon/or/'ʌpsilɒn/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(21\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Phi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(phi\)</span></td>
<td style="text-align: center;"><strong>/faɪ/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(22\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\chi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(X\)</span></td>
<td style="text-align: center;"><span class="math inline">\(chi\)</span></td>
<td style="text-align: center;"><strong>/kaɪ/</strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(23\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\psi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Psi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(psi\)</span></td>
<td style="text-align: center;"><strong>/psaɪ/</strong></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(24\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\omega\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\Omega\)</span></td>
<td style="text-align: center;"><span class="math inline">\(omega\)</span></td>
<td style="text-align: center;"><strong>/'əʊmɪɡə/or/oʊ'meɡə/</strong></td>
</tr>
</tbody>
</table>
<h3 id="矩阵">矩阵</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">A = <span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
A = \begin{matrix}
a &amp; b\\
c &amp; d
\end{matrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">B = <span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
B = \begin{pmatrix}
a &amp; b\\
c &amp; d
\end{pmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">C = <span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
C = \begin{vmatrix}
a &amp; b\\
c &amp; d
\end{vmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">D = <span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
D = \begin{bmatrix}
a &amp; b\\
c &amp; d
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">E = <span class="keyword">\begin</span>&#123;Vmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;Vmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
E = \begin{Vmatrix}
a &amp; b\\
c &amp; d
\end{Vmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">F = <span class="keyword">\begin</span>&#123;Bmatrix&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;Bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
F = \begin{Bmatrix}
a &amp; b\\
c &amp; d
\end{Bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[A<span class="keyword">\ </span>b] = </span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;c c c|c&#125;</span><br><span class="line">a<span class="built_in">_</span>&#123;11&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;12&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;13&#125; <span class="built_in">&amp;</span> b<span class="built_in">_</span>1<span class="keyword">\\</span></span><br><span class="line">a<span class="built_in">_</span>&#123;21&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;22&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;23&#125; <span class="built_in">&amp;</span> b<span class="built_in">_</span>2<span class="keyword">\\</span></span><br><span class="line">a<span class="built_in">_</span>&#123;31&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;32&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;33&#125; <span class="built_in">&amp;</span> b<span class="built_in">_</span>3<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
[A\ b] = 
\begin{bmatrix}
\begin{array}{c c c|c}
a_{11} &amp; a_{12} &amp; a_{13} &amp; b_1\\
a_{21} &amp; a_{22} &amp; a_{23} &amp; b_2\\
a_{31} &amp; a_{32} &amp; a_{33} &amp; b_3\\
\end{array}
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;c:c:c&#125;</span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">d <span class="built_in">&amp;</span> e <span class="built_in">&amp;</span> f <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hdashline</span></span><br><span class="line"> g <span class="built_in">&amp;</span> h <span class="built_in">&amp;</span> i</span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{array}{c:c:c}
a &amp; b &amp; c \\ 
\hline
d &amp; e &amp; f \\
\hdashline
 g &amp; h &amp; i
\end{array}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">L<span class="built_in">_</span>&#123;n<span class="keyword">\times</span> n&#125; = <span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">a<span class="built_in">_</span>&#123;11&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;12&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;1n&#125; <span class="keyword">\\</span> </span><br><span class="line">a<span class="built_in">_</span>&#123;21&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;22&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;2n&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span><span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line">a<span class="built_in">_</span>&#123;n1&#125; <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;n2&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> a<span class="built_in">_</span>&#123;nn&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
L_{n\times n} = \begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\ 
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\ 
\vdots &amp; \vdots &amp;\ddots &amp; \vdots\\
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} \\ 
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Y = <span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(2) <span class="keyword">\\</span> </span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(3)  <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\vdots</span> <span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(18)  <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
B = \begin{bmatrix} -\frac{1}{2}(x^{(1)}(1)+x^{(1)}(2)) &amp; 1 \\  -\frac{1}{2}(x^{(1)}(2)+x^{(1)}(3)) &amp; 1  \\  \vdots &amp; \vdots \\ -\frac{1}{2}(x^{(1)}(17)+x^{(1)}(18)) &amp; 1  \\  \end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Y = <span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(2) <span class="keyword">\\</span> </span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(3)  <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\vdots</span> <span class="keyword">\\</span></span><br><span class="line">x<span class="built_in">^</span>&#123;(0)&#125;(18)  <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
Y = \begin{bmatrix}
x^{(0)}(2) \\ 
x^{(0)}(3)  \\ 
\vdots \\
x^{(0)}(18)  \\ 
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hat</span>&#123;<span class="keyword">\textbf</span>&#123;u&#125;&#125; = </span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\hat</span>&#123;a&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\hat</span>&#123;b&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line">=<span class="keyword">\textbf</span>&#123;(B&#125;<span class="built_in">^</span>&#123;T&#125;<span class="keyword">\textbf</span>&#123;B&#125;<span class="keyword">\textbf</span>&#123;)&#125;<span class="built_in">^</span>&#123;-1&#125;<span class="keyword">\textbf</span>&#123;B&#125;<span class="built_in">^</span>&#123;T&#125;<span class="keyword">\textbf</span>&#123;Y&#125;</span><br><span class="line">=<span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\hat</span>&#123;a&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\hat</span>&#123;b&#125; <span class="keyword">\\</span> </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\hat{\textbf{u}} = 
\begin{bmatrix}
\hat{a} \\ 
\hat{b} \\ 
\end{bmatrix}
=\textbf{(B}^{T}\textbf{B}\textbf{)}^{-1}\textbf{B}^{T}\textbf{Y}
=\begin{bmatrix}
\hat{a} \\ 
\hat{b} \\ 
\end{bmatrix}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hat</span>&#123;a&#125;=<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hat</span>&#123;b&#125;= <span class="keyword">\\</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\hat{a}=\\
\hat{b}= \\
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;dx<span class="built_in">^</span>&#123;(1)&#125;&#125;&#123;dt&#125;+<span class="keyword">\hat</span>&#123;a&#125;x<span class="built_in">^</span>&#123;(1)&#125;=<span class="keyword">\hat</span>&#123;b&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\frac{dx^{(1)}}{dt}+\hat{a}x^{(1)}=\hat{b}
\]</span></p>
<h3 id="列式方程组">列式/方程组</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line">f(x) <span class="built_in">&amp;</span>= (x+1)<span class="built_in">^</span>2<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>= x<span class="built_in">^</span>2 + 2x + 1</span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{aligned}
f(x) &amp;= (x+1)^2\\
&amp;= x^2 + 2x + 1
\end{aligned}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">f(x) = <span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">a <span class="built_in">&amp;</span><span class="keyword">\text</span>&#123;if b&#125;<span class="keyword">\\</span></span><br><span class="line">b <span class="built_in">&amp;</span><span class="keyword">\text</span>&#123;if a&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
f(x) = \begin{cases}
a &amp;\text{if b}\\
b &amp;\text{if a}\\
\end{cases}
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line">x + 2y <span class="built_in">&amp;</span>= 1<span class="keyword">\\</span></span><br><span class="line">3x - y <span class="built_in">&amp;</span>= 5</span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{cases}
\begin{aligned}
x + 2y &amp;= 1\\
3x - y &amp;= 5
\end{aligned}
\end{cases}
\]</span></p>
<h3 id="注释图片">注释图片</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">&quot;border-radius: 0.3125em;</span></span></span><br><span class="line"><span class="string"><span class="tag">    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;图片地址&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image-20210531181704173&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:orange; border-bottom: 1px solid #d9d9d9;</span></span></span><br><span class="line"><span class="string"><span class="tag">    display: inline-block;</span></span></span><br><span class="line"><span class="string"><span class="tag">    color: #999;</span></span></span><br><span class="line"><span class="string"><span class="tag">    padding: 2px;&quot;</span>&gt;</span>注释<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure>
<center>
<img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/2022/02/20/23-32-35/图片地址" alt="image-20210531181704173"> <br>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
注释
</div>
</center>
<h3 id="字体">字体</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">字体名</th>
<th style="text-align: center;">样式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h3 id="修饰符">修饰符</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hat</span>&#123;<span class="keyword">\theta</span>&#125;</span><br><span class="line"><span class="keyword">\widehat</span>&#123;AB&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\bar</span>&#123;y&#125;</span><br><span class="line"><span class="keyword">\overline</span>&#123;AB&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\tilde</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\widetilde</span>&#123;ac&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\bar</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\acute</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\check</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\grave</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\dot</span>&#123;a&#125;</span><br><span class="line"><span class="keyword">\ddot</span>&#123;a&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\hat{\theta}
\widehat{AB}
\\
\bar{y}
\overline{AB}
\\
\tilde{a}
\widetilde{ac}
\\
\bar{a}
\acute{a}
\check{a}
\grave{a}
\\
\dot{a}
\ddot{a}
\]</span></p>
<h3 id="括号">括号</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;gather*&#125;</span><br><span class="line">(</span><br><span class="line"><span class="keyword">\big</span>(</span><br><span class="line"><span class="keyword">\Big</span>(</span><br><span class="line"><span class="keyword">\bigg</span>(</span><br><span class="line"><span class="keyword">\Bigg</span>(</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line">[]</span><br><span class="line">&lt;&gt;</span><br><span class="line">|绝对值|</span><br><span class="line"><span class="keyword">\&#123;</span><span class="keyword">\&#125;</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\lgroup</span> x <span class="keyword">\rgroup</span></span><br><span class="line"><span class="keyword">\lVert</span> a <span class="keyword">\rVert</span></span><br><span class="line"><span class="keyword">\lceil</span> 2.6 <span class="keyword">\rceil</span></span><br><span class="line"><span class="keyword">\lfloor</span> 1.2 <span class="keyword">\rfloor</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\ulcorner</span></span><br><span class="line"><span class="keyword">\urcorner</span></span><br><span class="line"><span class="keyword">\llcorner</span></span><br><span class="line"><span class="keyword">\lrcorner</span></span><br><span class="line"><span class="keyword">\end</span>&#123;gather*&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{gather*}
(
\big(
\Big(
\bigg(
\Bigg(
\\
[]
&lt;&gt;
|绝对值|
\{\}
\\
\lgroup x \rgroup
\lVert a \rVert
\lceil 2.6 \rceil
\lfloor 1.2 \rfloor
\\
\ulcorner
\urcorner
\llcorner
\lrcorner
\end{gather*}
\]</span></p>
<h3 id="偏微分">偏微分</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> u&#125;&#123;<span class="keyword">\partial</span> t&#125;= h<span class="built_in">^</span>2 <span class="keyword">\left</span>( <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 u&#125;&#123;<span class="keyword">\partial</span> x<span class="built_in">^</span>2&#125; +<span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 u&#125;&#123;<span class="keyword">\partial</span> y<span class="built_in">^</span>2&#125;+ <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>2 u&#125;&#123;<span class="keyword">\partial</span> z<span class="built_in">^</span>2&#125;<span class="keyword">\right</span>)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\frac{\partial u}{\partial t}= h^2 \left( \frac{\partial^2 u}{\partial x^2} +\frac{\partial^2 u}{\partial y^2}+ \frac{\partial^2 u}{\partial z^2}\right)
\]</span></p>
<h3 id="图形">图形</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\Box</span></span><br><span class="line"><span class="keyword">\square</span></span><br><span class="line"><span class="keyword">\blacksquare</span></span><br><span class="line"><span class="keyword">\triangle</span></span><br><span class="line"><span class="keyword">\triangledown</span></span><br><span class="line"><span class="keyword">\blacktriangle</span></span><br><span class="line"><span class="keyword">\diamond</span></span><br><span class="line"><span class="keyword">\Diamond</span></span><br><span class="line"><span class="keyword">\star</span></span><br><span class="line"><span class="keyword">\bigstar</span></span><br><span class="line"><span class="keyword">\circ</span></span><br><span class="line"><span class="keyword">\bullet</span></span><br><span class="line"><span class="keyword">\bigcirc</span></span><br><span class="line"><span class="keyword">\bigodot</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\Box
\square
\blacksquare
\triangle
\triangledown
\blacktriangle
\diamond
\Diamond
\star
\bigstar
\circ
\bullet
\bigcirc
\bigodot
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\diamondsuit</span></span><br><span class="line"><span class="keyword">\clubsuit</span></span><br><span class="line"><span class="keyword">\heartsuit</span></span><br><span class="line"><span class="keyword">\spadesuit</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\diamondsuit
\clubsuit
\heartsuit
\spadesuit
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\angle</span></span><br><span class="line"><span class="keyword">\measuredangle</span></span><br><span class="line"><span class="keyword">\top</span></span><br><span class="line"><span class="keyword">\bot</span></span><br><span class="line"><span class="keyword">\infty</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\angle
\measuredangle
\top
\bot
\infty
\]</span></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\checkmark</span></span><br><span class="line"><span class="keyword">\dagger</span></span><br><span class="line"><span class="keyword">\ddagger</span></span><br><span class="line"><span class="keyword">\yen</span></span><br><span class="line"><span class="keyword">\$</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\checkmark
\dagger
\ddagger
\yen
\$
\]</span></p>
<h3 id="变换符号">变换符号</h3>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%拉氏变换：</span></span><br><span class="line"><span class="keyword">\mathscr</span>&#123;L&#125;&#123;f(t)&#125;</span><br><span class="line"><span class="keyword">\mathcal</span>&#123;L&#125;</span><br><span class="line"><span class="comment">%傅里叶变换：</span></span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\mathscr{L}\{f(t)\}\quad
\mathcal{L}
\]</span></p>
<h1 id="typroa框图博客不支持">typroa框图（博客不支持）</h1>
<h3 id="流程图">流程图</h3>
<p>语法说明：</p>
<ul>
<li>graph LR： 这一行说明要绘制的图形的方向。
<ul>
<li>LR：从左到右，left to right</li>
<li>RL：从右到左，right to left</li>
<li>TB：从上到下，top to bottom</li>
<li>BT：从下到上，bottom to top</li>
</ul></li>
<li>定义节点：有两种定义节点的方式
<ul>
<li>可以直接输入文字信息作为节点名称: node1</li>
<li>也可以在节点名称前加一个id的形式：id2(node2)，这样后续可以通过id1来引用node1这个节点。</li>
</ul></li>
<li>节点图形形状：
<ul>
<li>默认：方形</li>
<li>(node2）: 圆角</li>
<li>{[node3]) ：椭圆</li>
</ul></li>
<li>条件节点：在绘制流程图中会经常用到条件节点，在Mermaid中也可以实现的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/02/20/23-32-35/image-20220225234024945-16458036280891.png" alt="image-20220225234024945"><figcaption aria-hidden="true">image-20220225234024945</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: Start:&gt;http://www.google.com[blank]</span><br><span class="line">e=&gt;end:&gt;http://www.google.com</span><br><span class="line">op1=&gt;operation: My Operation</span><br><span class="line">sub1=&gt;subroutine: My Subroutine</span><br><span class="line">cond=&gt;condition: Yes</span><br><span class="line">or No?:&gt;http://www.google.com</span><br><span class="line">io=&gt;inputoutput: catch something...</span><br><span class="line">para=&gt;parallel: parallel tasks</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;para</span><br><span class="line">para(path1, bottom)-&gt;sub1(right)-&gt;op1</span><br><span class="line">para(path2, top)-&gt;op1</span><br><span class="line">para(path3, top)-&gt;op1</span><br><span class="line">para(path4, top)-&gt;op1</span><br><span class="line">para(path5, top)-&gt;op1</span><br><span class="line">para(path6, top)-&gt;op1</span><br><span class="line">para(path7, top)-&gt;op1</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/02/20/23-32-35/image-20220225234115328-16458036772432.png" alt="image-20220225234115328"><figcaption aria-hidden="true">image-20220225234115328</figcaption>
</figure>
]]></content>
      <tags>
        <tag>备忘笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记</title>
    <url>/2022/02/17/11-07-35/</url>
    <content><![CDATA[<h1 id="数据结构">数据结构</h1>
<h2 id="链表">链表</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">double</span> a, <span class="type">int</span> b, Node* c) : <span class="built_in">coef</span>(a), <span class="built_in">expn</span>(b), <span class="built_in">next</span>(c) &#123;&#125;</span><br><span class="line">    <span class="type">double</span> coef;</span><br><span class="line">    <span class="type">int</span> expn;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(Node*&amp; head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num; std::cin &gt;&gt; num;<span class="comment">//每个链表中数字的个数</span></span><br><span class="line">    <span class="type">double</span> coef;</span><br><span class="line">    <span class="type">int</span> expn;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin &gt;&gt; coef &gt;&gt; expn;</span><br><span class="line">        Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(coef, expn, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">            new_node-&gt;next = head;</span><br><span class="line">        head = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(Node*&amp; head1, Node*&amp; head2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* ptr1 = head1;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (head2-&gt;expn == ptr1-&gt;expn)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr1-&gt;coef = ptr1-&gt;coef + head2-&gt;coef;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ptr1 = ptr1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ptr1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(head2-&gt;coef, head2-&gt;expn, head1);</span><br><span class="line">            head1 = new_node;</span><br><span class="line">        &#125;</span><br><span class="line">        head2 = head2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* x1 = <span class="literal">NULL</span>, * x2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">Create</span>(x1); <span class="built_in">Create</span>(x2);</span><br><span class="line">    <span class="built_in">Add</span>(x1, x2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树">树</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">tree</span>(<span class="type">char</span> a, tree *b, tree *c) : <span class="built_in">data</span>(a), <span class="built_in">left</span>(b), <span class="built_in">right</span>(c) &#123;&#125;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    tree *left;</span><br><span class="line">    tree *right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creat</span><span class="params">(tree *&amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">tree</span>(c, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">Creat</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">Creat</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(tree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;tree *&gt; stack;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !stack.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//此处输出是前序遍历</span></span><br><span class="line">            cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = stack.<span class="built_in">top</span>();</span><br><span class="line">            <span class="comment">//此处输出是中序遍历</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt;root-&gt;data&lt;&lt;&quot; &quot;;</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">Creat</span>(root);</span><br><span class="line">    <span class="built_in">PreOrder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树的非递归前序遍历">树的非递归前序遍历</h4>
<ol type="1">
<li>创建一个栈
<ol type="1">
<li>只要节点不为空或者栈不为空
<ol type="1">
<li>如果节点为空
<ol type="1">
<li>打印</li>
<li>入栈</li>
<li>左走</li>
</ol></li>
<li>如果节点不为空
<ol type="1">
<li>取栈首</li>
<li>右走</li>
<li>出栈</li>
</ol></li>
</ol></li>
</ol></li>
</ol>
<h2 id="图">图</h2>
<h3 id="邻接矩阵">邻接矩阵</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> vertex[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> edge[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">    <span class="type">int</span> vertex_num, edge_num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(Graph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; G-&gt;vertex_num;</span><br><span class="line">    cin &gt;&gt; G-&gt;edge_num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertex_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; G-&gt;vertex[i];</span><br><span class="line">        G-&gt;visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertex_num; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertex_num; j++)</span><br><span class="line">            G-&gt;edge[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;edge_num; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">        G-&gt;edge[v1][v2] = <span class="number">1</span>;</span><br><span class="line">        G-&gt;edge[v2][v1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph* G, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; G-&gt;vertex[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    G-&gt;visited[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertex_num; j++)</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;edge[i][j] == <span class="number">1</span> &amp;&amp; !G-&gt;visited[j])</span><br><span class="line">            <span class="built_in">DFS</span>(G, j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(queue&lt;<span class="type">int</span>&gt;&amp; queue, <span class="type">int</span> i, Graph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G-&gt;visited[i] = <span class="literal">true</span>;</span><br><span class="line">    queue.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vertex_num; i++)</span><br><span class="line">        <span class="keyword">if</span> (!G-&gt;visited[i])<span class="comment">//这个模块起名为访问列吧</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">visit</span>(queue, i, G);<span class="comment">//每列入队</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>())<span class="comment">//行入队后检查队是否为空，队首作为行的检测依据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vertex_num; j++)</span><br><span class="line">                    <span class="keyword">if</span> (G-&gt;edge[queue.<span class="built_in">front</span>()][j] == <span class="number">1</span> &amp;&amp; !G-&gt;visited[j])<span class="comment">//这个模块起名为访问行</span></span><br><span class="line">                        <span class="built_in">visit</span>(queue, j, G);<span class="comment">//每行入队</span></span><br><span class="line">                cout &lt;&lt; G-&gt;vertex[queue.<span class="built_in">front</span>()] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                queue.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//测试数据：9 15  A B C D E F G H I 0 1 0 5 1 2 1 8 1 6 2 3 2 8 3 4 3 7 3 6 3 8 4 5 4 7 5 6 6 7</span></span><br><span class="line">    Graph G;</span><br><span class="line">    <span class="built_in">Create</span>(&amp;G);</span><br><span class="line">    <span class="comment">//每次只能选择一个运行</span></span><br><span class="line">    <span class="comment">//DFS(&amp;G, 0);</span></span><br><span class="line">    <span class="built_in">BFS</span>(&amp;G);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邻接矩阵的广度遍历">邻接矩阵的广度遍历</h4>
<ol type="1">
<li>创建队列</li>
<li>遍历 i (列)所有节点，对于未访问的节点进行下述操作
<ol type="1">
<li>打印 i 处节点并设置为访问过</li>
<li>将数字 i 入队</li>
<li>队列不为空时执行如下操作
<ol type="1">
<li>将队首元素赋值给 i</li>
<li>遍历 j (行)所有节点，当 i 和 j 有关系且 j 处节点未访问时执行如下操作
<ol type="1">
<li>打印 j 处节点并设置为访问过</li>
<li>将数字 j 入队</li>
</ol></li>
<li>队首出队</li>
</ol></li>
</ol></li>
</ol>
<h4 id="邻接矩阵的深度遍历">邻接矩阵的深度遍历</h4>
<ol type="1">
<li>遍历 i (列)所有节点，未访问节点进入 DFS(G,i)</li>
<li>DFS 函数： <br>1. 打印进入 DFS 的节点并设置为访问 <br>2. 遍历 j (行)所有节点，当 i 和 j 有关系且未访问的节点进入 DFS(G,j)</li>
</ol>
<h3 id="邻接表">邻接表</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="type">bool</span> visited;</span><br><span class="line">    list&lt;Vertex*&gt; edge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creat</span><span class="params">(vector&lt;Vertex&gt;&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> vertex_num; cin &gt;&gt; vertex_num;</span><br><span class="line">    <span class="type">int</span> edge_num; cin &gt;&gt; edge_num;</span><br><span class="line"></span><br><span class="line">    Vertex temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertex_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; temp.data;</span><br><span class="line">        temp.visited = <span class="literal">false</span>;</span><br><span class="line">        G.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * edge_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">        G[v1].edge.<span class="built_in">push_back</span>(&amp;G[v2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Vertex* <span class="title">next_vertex</span><span class="params">(Vertex* vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iiter = vertex-&gt;edge.<span class="built_in">begin</span>(); iiter != vertex-&gt;edge.<span class="built_in">end</span>(); iiter++)</span><br><span class="line">        <span class="keyword">if</span> ((*iiter)-&gt;visited == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (*iiter)-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> *iiter;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Vertex* vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vertex != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; vertex-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        vertex-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="built_in">next_vertex</span>(vertex));</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="built_in">next_vertex</span>(vertex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_level</span><span class="params">(queue&lt;Vertex*&gt;&amp; queue, Vertex* vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iiter = vertex-&gt;edge.<span class="built_in">begin</span>(); iiter != vertex-&gt;edge.<span class="built_in">end</span>(); iiter++)</span><br><span class="line">        <span class="keyword">if</span> ((*iiter)-&gt;visited == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (*iiter)-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">            queue.<span class="built_in">push</span>((*iiter));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Vertex* vertex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;Vertex*&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(vertex);</span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; queue.<span class="built_in">front</span>()-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        queue.<span class="built_in">front</span>()-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">get_level</span>(queue, queue.<span class="built_in">front</span>());</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 9 15 A B C D E F G H I 0 1 0 5 1 0 1 2 1 6 1 8 2 1 2 3 2 8 3 2 3 4 3 6 3 7 3 8 4 3 4 5 4 7 5 0 5 4 5 6 6 1 6 3 6 5 6 7 7 3 7 4 7 6 8 1 8 2 8 3</span></span><br><span class="line">    vector&lt;Vertex&gt; G;</span><br><span class="line">    <span class="built_in">Creat</span>(G);</span><br><span class="line">    <span class="comment">//每次只能运行一个</span></span><br><span class="line">    <span class="comment">//DFS(&amp;G[0]);</span></span><br><span class="line">    <span class="built_in">BFS</span>(&amp;G[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邻接表的深度遍历">邻接表的深度遍历</h4>
<p>·只要顶点不为空，打印顶点并设置为访问过；将下一个顶点进入该函数</p>
<h4 id="邻接表的广度遍历">邻接表的广度遍历</h4>
<ol type="1">
<li>创建队列</li>
<li>第一个顶点入队</li>
<li>队不为空，执行下述操作
<ol type="1">
<li>取队首顶点</li>
<li>打印队首顶点并设置为访问过</li>
<li>获得下一层顶点</li>
<li>队首出队</li>
</ol></li>
</ol>
<h4 id="next_node">next_node</h4>
<p>查链表，找到未访问顶点；设置为访问，返回该顶点</p>
<h4 id="get_level">get_level</h4>
<p>查链表，找到未访问顶点；设置为访问，将该顶点入队</p>
<h2 id="排序">排序</h2>
<h3 id="快排">快排</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> arry[], <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sbit = begin;</span><br><span class="line">        <span class="type">int</span> pivot = arry[end];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = begin; j &lt; end; j++)</span><br><span class="line">            <span class="keyword">if</span> (arry[j] &lt; pivot)</span><br><span class="line">              &#123;<span class="built_in">swap</span>(arry[j], arry[sbit]); sbit++;&#125;</span><br><span class="line">              <span class="comment">//每个数字与pivot比较，较小的与sbit交换</span></span><br><span class="line">              <span class="comment">//将pivot与sbit交换</span></span><br><span class="line">        <span class="built_in">swap</span>(arry[sbit], arry[end]);</span><br><span class="line">        <span class="built_in">sort</span>(arry, begin, sbit - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sort</span>(arry, sbit + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arry[<span class="number">8</span>] = &#123; <span class="number">27</span>, <span class="number">13</span>, <span class="number">65</span>, <span class="number">8</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">81</span>, <span class="number">72</span> &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(arry, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排">堆排</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">max_heap</span><span class="params">(<span class="type">int</span> arry[], <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> root = begin;</span><br><span class="line">    <span class="type">int</span> left = root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = root * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arry[left] &lt; arry[right] &amp;&amp; right &lt;= end) left++;</span><br><span class="line">        <span class="keyword">if</span> (arry[left] &lt; arry[root]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arry[left], arry[root]);</span><br><span class="line">            root = left;</span><br><span class="line">            left = root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            right = root * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> arry[], <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = end / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">max_heap</span>(arry, i, end);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = end; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arry[<span class="number">0</span>], arry[i]);</span><br><span class="line">        <span class="built_in">max_heap</span>(arry, <span class="number">0</span>, i<span class="number">-1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arry[<span class="number">11</span>] = &#123; <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">16</span> &#125;;</span><br><span class="line">    <span class="built_in">sort</span>(arry, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>堆排序</li>
<li>得最大堆的方法：
<ol type="1">
<li>范围：从 非叶子节点 到 根节点<br>
</li>
<li>调整对象：循环因子 到 表</li>
</ol></li>
<li>排序的方法：
<ol type="1">
<li>范围：从 表尾 到 根节点前</li>
<li>调整对象：无序首 到 无序尾</li>
</ol></li>
<li>维持堆的方法：</li>
</ol>
]]></content>
      <tags>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论</title>
    <url>/2022/04/10/11-17-01/</url>
    <content><![CDATA[<h1 id="概率与统计">概率与统计</h1>
<h3 id="随机实验">随机实验</h3>
<p>满足条件：</p>
<ol type="1">
<li>可以被重复；</li>
<li>具有多种可能结果并均明确可知；</li>
<li>试验结果不可预先获知。</li>
</ol>
<p>随机实验可能出现的每一种结果称为<strong>样本点</strong>，每一个样本点都彼此不相容，因而它是构成试验结果的最基础原子，故而样本点也被称为<strong>基本事件</strong>。</p>
<p>所有样本点（也即所有的可能结果）的集合就被称为<strong>样本空间</strong></p>
<p>一次试验可能出现的结果称为<strong>随机事件</strong>，随机事件是一个集合，内部元素均为随机实验的样本点</p>
<p>为什么要引入样本空间：</p>
<p>引入样本空间是为了给予“随机”这一相对较为暧昧的机制一个严格的数学范围。在这以后，一切事件的概率才得以在其相对应的样本空间之下具备良好的定义。</p>
<p>这就像样本空间（Sample space）产生出了事件域，而我们讨论相应的事件概率，就只在其定义的样本空间下具有意义，而同一事件在不同样本空间下，其发生的概率可能截然不同</p>
<p>样本空间的引入实际上是在为概率的定义提供了一个严格的范围。</p>
<p>一个样本空间可以是有限的，可数无穷的和不可数无穷的</p>
<p>假如S是可数的，包括有限和可数无穷的，那么S为一个离散的样本空间</p>
<p>假如S是不可数的，即不可数无穷的，那么S为一个连续的样本空间</p>
<p>对于随机试验的结果，即随机事件，其描述可以由多个观测量组成，因此样本空间可以是有不同维度的，维度数即描述一个随机时间的测量量的数目</p>
<p>概率的定义：（概率的本质）</p>
<p>直觉：概率就是事件发生的可能性。</p>
<p>古典概型：</p>
<p>进行<span class="math inline">\(n\)</span>次随机实验，得到的某一结果的次数记作<span class="math inline">\(N_k(n)\)</span>，则得到该结果的相对次数为<span class="math inline">\(f_k(n)=\frac{N_k(n)}{n}\)</span></p>
<p>当<span class="math inline">\(n\)</span>的数值足够大时，<span class="math inline">\(f_k(n)\)</span>则收敛于一个稳定的数值，即<span class="math inline">\(lim_{n-&gt;\infty}f_k(n)=p_k\)</span>，<span class="math inline">\(p_k\)</span>称作概率</p>
<p>古典概型的前提：</p>
<ol type="1">
<li>在古典概型的样本空间中，样本点也即基本事件的个数是有限的（骰子只能掷出6个数字）</li>
<li>每个样本点也即每个基本事件发生的可能性是相等的（投出6和投出1或任意其它一种结果的可能性完全一致）</li>
</ol>
<p>古典概型是<strong>先验</strong>的，因为我们<strong>先验</strong>的认为，这个骰子掷出任意一个数字的可能性都是相同的。并且同样<strong>先验</strong>的确定，掷出任意一个数字的频率都会稳定于古典概型计算出的这个先验概率附近。</p>
<p>先验来自于我们的直觉，来自于实践中的观察</p>
<p><strong>后验</strong>认为，对于事件发生的先验假设，我们不应当存在任何的偏好——即基本事件等可能这种事，并不是理所当然的</p>
<p>后验中我们可以随意假设一个估计性质的开始概率，重要的是，我们可以通过后续的重复试验，来不断的更新纠正这一概率，而当通过试验获取的信息趋近于无穷时，我们最终就可以获得一个收敛于某个具体数值的<strong>后验</strong>概率。</p>
<p>让我们能够摆脱“可能性”的束缚，从而绕开先验与后验的争论，来在数学上精确的定义概率呢？</p>
<p>在有了样本空间将事件构造成的集合以后，再通过测度的方式，将它们映射至0到1取值范围内的实数域 <span class="math inline">\([0,1]\)</span>上。</p>
<p>若以这样的方式来定义概率，我们不就可以将它从事件发生可能性这样的束缚上解脱出来，从而获得一个纯粹的数学定义。为了实现这种测度的构造，就可以人为的对样本空间到实数域的映射规则进行规定，即：</p>
<ol type="1">
<li>概率必然是非负的，即 <span class="math inline">\(P(A)\ge 0\)</span></li>
<li>样本空间所代表的全集，概率规定为1，即 <span class="math inline">\(P(\Omega)=1\)</span></li>
<li>对于任意可列的互不相容事件（即两两交集均为 <span class="math inline">\(\varnothing\)</span> 的子集），它们并集的概率等于它们概率的和，即 <span class="math inline">\(P(A\cup B)=P(A)+P(B)\)</span></li>
</ol>
<p>满足这三个条件的映射，即有概率 <span class="math inline">\(P\)</span> ，这也被称为概率的公理化定义。</p>
<p>也由于这种定义的实质就是将样本空间对实数进行映射，故而这种映射也被称为<strong>概率测度</strong>。</p>
<p>条件概率公式所反映的，实际上是决策树的<strong>剪枝</strong>过程。而条件概率的本质，则是<strong>由于前提事件的发生所导致的待计算事件其样本点与样本空间的同时缩小（如同上文中文氏图所示的右侧聚焦过程）</strong>。</p>
<p><strong>全概率公式</strong>：</p>
<p>假设：样本空间 <span class="math inline">\(S\)</span> 有一个完备的事件组 <span class="math inline">\(A_1,A_2,A_3\)</span>：也就是样本空间被这三个事件瓜分完了</p>
<p>满足两个条件：三个事件：</p>
<ol type="1">
<li><span class="math inline">\(A_1 \cup A_2 \cup A_3=\Omega\)</span></li>
<li><span class="math inline">\(A_1 \cap A_2 \cap A_3=\varnothing\)</span></li>
</ol>
<p>则又有一事件 <span class="math inline">\(B\)</span> 时，<span class="math inline">\(P(B)=P(B \cap \Omega)=P[B\cup (A_1 \cup A_2 \cup A_3)]=P(BA_1 \cup BA_2 \cup BA_3)\)</span></p>
<p>因为 <span class="math inline">\(A_1 \cap A_2 \cap A_3=\varnothing\)</span>，所以 <span class="math inline">\(BA_1 \cup BA_2 \cup BA_3=\varnothing\)</span></p>
<p>所以：<span class="math inline">\(P(BA_1 \cup BA_2 \cup BA_3)=P(BA_1)+P(BA_2)+P(BA_3)\)</span></p>
<p>由条件概率公式可得：</p>
<p><span class="math inline">\(P(B)=P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)\)</span></p>
<p>即全概率公式事实上是一种<strong>对事件的先验分解</strong>。</p>
<p>全概率公式的使用条件，就是连续做多次实验，可以画出决策树，然后每一种分支可能性会发生变化，即前一次的选择会对下一次的选择产生影响；这是若求解第二轮即以后某个结果发生的可能性，则使用全概率公式</p>
<p>贝叶斯公式：</p>
<p>贝叶斯公式是后验的，即，我们已经做了实验，然后通过实验结果我们不断去修正导致这一结果发生的某些概率值</p>
<p>贝叶斯公式可以由全概率公式变形得来： <span class="math display">\[
\begin{aligned}
P(A_1|B)&amp;=\frac{P(A_1B)}{P(B)}\\
&amp;=\frac{P(A_1B)}{P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)}\\
&amp;=\frac{P(A_1)P(B|A_1)}{P(A_1)P(B|A_1)+P(A_2)P(B|A_2)+P(A_3)P(B|A_3)}
\end{aligned}
\]</span></p>
<p>随机变量：随机变量的本质实际上就是<strong>随机事件的数字化</strong>。</p>
<p>现实世界中各色各样具象的随机事件，可以被映射成数学世界中抽象的数字，而这种映射规则就叫做随机变量。</p>
<p>离散随机变量的（概率分布律）概率质量函数（<span class="math inline">\(pmf\)</span>）：</p>
<p>离散性随机变量记作 <span class="math inline">\(X\)</span>，<span class="math inline">\(X\)</span> 的可能值是一个可数集合中的元素：<span class="math inline">\(S_X={x_1,x_2,x_3...}\)</span></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(X\)</span></th>
<th><span class="math inline">\(x=1\)</span></th>
<th><span class="math inline">\(x=0\)</span></th>
<th><span class="math inline">\(x=2\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(pmf\)</span></td>
<td><span class="math inline">\(P(x=1)=0.125\)</span></td>
<td><span class="math inline">\(p(x=0)=0.25\)</span></td>
<td><span class="math inline">\(P(x=2)=0.625\)</span></td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(pmf\)</span> 的性质：</p>
<ul>
<li><p><span class="math display">\[
对于所有\;x\; 都有 \;P_X(x)\ge 0
\]</span></p></li>
<li><p><span class="math display">\[
\sum_{x\in S}P_X(x)=1
\]</span></p></li>
<li><p><span class="math display">\[
P(X\;in\;B)=\sum_{x\in B}P_X(x)\;其中B\subset S_X 
\]</span></p></li>
</ul>
<p>随机变量可以是离散的，连续的和混合的</p>
<p>累积分布函数（<span class="math inline">\(cdf\)</span>：cumulative distribution function），常被使用在随机变量的正式定义中，可以处理三种类型的随机变量</p>
<p>一个离散性随机变量的 <span class="math inline">\(pmf\)</span> 是由 <span class="math inline">\(\{X=b\}\)</span> 来定义的，累计分布函数（<span class="math inline">\(cdf\)</span>：cumulative distribution function）则是由 <span class="math inline">\(\{X\le b\}\)</span> 来定义的。</p>
<p>累计分布函数的优点在于它不局限于离散型随机变量，而是可以在所有类型的随机变量中使用</p>
<ol type="1">
<li><span class="math inline">\(F_X(x)\)</span>必然是一个单调不减函数——因概率不可为负，随着对应样本点的增多，概率的累加必然是单调不减的；</li>
<li><span class="math inline">\(F_X(x)\)</span> 必然是一个右连续函数；</li>
<li><span class="math inline">\(\lim_{n \to -\infty}F_X(x)=0\)</span>，<span class="math inline">\(\lim_{n \to \infty}F_X(x)=1\)</span> ——即对应样本点集合为空时，概率必然为0，而对应样本点集合为整个样本空间时，概率必然为1。</li>
</ol>
<p>可以看到，无论分布函数以何种形式构造，又呈现出何种性质，其最最核心的效用，就是为了能够良好的表示出样本空间的这一性质： <span class="math display">\[
P_1+P_2+P_3+...+P_n=\sum_iP_i=1
\]</span> 即实现样本空间 <span class="math inline">\(S\)</span> 对应的概率<strong>归向于1</strong>，从而完成样本空间向值域 <span class="math inline">\([0,1]\)</span> 的映射。因此，分布函数的本质实际上是<strong>随机变量的归一化</strong>。</p>
<p>而当随机变量由离散型扩展至连续型时，在把握到分布函数的本质是样本点概率的累加函数以后，便可以推测连续型随机变量的分布函数 <span class="math inline">\(F_X(x)\)</span> 必然会表现为一种积分形式。</p>
<p>但是与离散型概率分布中，每个随机变量对应着一个确定的概率值所不同，若以类似的方式来通过分布函数计算连续型随机变量中任意一点的概率，即用这一点的分布函数值减去这一点处左极限的分布函数值： <span class="math display">\[
P\{x=x_0\}=F_X(x_0)-\lim_{n \to x_0^-}F_X(x_0)
\]</span> 由于 <span class="math inline">\(F_X(x)\)</span> 是连续的概率累加，因此它在性质上也必然是一个非负不减的连续函数，故根据连续的性质，有： <span class="math display">\[
F_X(x_0)=\lim_{n \to x_0^+}F_X(x_0)= \lim_{n \to x_0^-}F_X(x_0)
\]</span> 故有： <span class="math display">\[
P\{x=x_0\}=0
\]</span> 由此可以看到，无论我们怎么计算，在连续型随机变量的分布函数上想要直接计算某一点处的概率，它将始终都会是0。</p>
<p>从这一结论，你应该就能明白，在概率论的开篇中，我们提到通过引入测度，将事件的概率测度与它在现实中发生的可能性这两个概念分开具有怎样重要的意义。</p>
<p>可以看到，在连续型随机变量中，某一点出的概率为0，并不意味着它在事件发生的角度来看是不可能的，而只是意味着这一点处的概率测度为0。</p>
<p>而之所以会出现概率测度为0的原因，是因为在这里一开始所着眼的计算目标就错了。打个比方来说就相当于，你并不会去计算一个点的长度，不会去计算一条线的面积，不会去计算一个面的体积。换句话说，在连续型随机变量中，计算某一点处的概率就相当于在求一条线的面积。</p>
<p>在认识到这一点之后，为了刻画连续型随机变量中某点处局部的概率性质就需要另外的工具，而这个工具在微积分的阶段就已经准备好早已被我们熟稔于胸——当然就是导数，即有： <span class="math display">\[
F^{&#39;}_X(x_0)=\lim_{x\to x_0}\frac{F_X(x)-F_X(x_0)}{x-x_0}
\]</span> 换句话说，对于连续型随机变量，我们用以刻画在一点处局部性质的量不是概率，而应该是<strong>概率测度的变化率。</strong></p>
<p>借用我们在散度与测度一章中的两个相类似的例子来说，就是：</p>
<ul>
<li>在位移运动中，刻画某一瞬时性质的不是位移而是速度；</li>
<li>在有质物体中，刻画某一质点性质的不是质量而是密度。</li>
</ul>
<p>也因此，以质量与密度的关系来考量概率与概率变化率，才会将连续型随机变量的分布函数，一个变上限积分：<span class="math inline">\(F(x)=\int^x_{-\infty}f(t)dt\)</span> 的导函数： <span class="math inline">\(F&#39;(x)=f(x)\)</span> 命名为<strong>概率密度</strong>。</p>
<p>更要值得一提的是，如果用离散型随机变量的概率分布即：</p>
<p>一个随机变量对应一个确定的概率测度 <span class="math inline">\(x_i\sim P_i\)</span></p>
<p>来进行类比的话，连续型随机变量的概率分布实际上应当为：</p>
<p>一个随机变量对应其<strong>附近领域</strong>的概率测度 <span class="math inline">\(x_i\sim f(x_i)dx_i\)</span></p>
<p>而非直接对应概率密度函数 <span class="math inline">\(f(x)\)</span>，从这个类比，可以更直观的认为，若视离散型随机变量的分布函数为一个楼层分明的阶梯，那么连续型随机变量的分布函数就是一个将楼层无限增加细分从而使层次分明的阶梯最终转换为一个<strong>平滑化</strong>的斜坡。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>电子学笔记</title>
    <url>/2022/02/21/08-25-17/</url>
    <content><![CDATA[<h1 id="电子学">电子学</h1>
<h3 id="基本概念">基本概念</h3>
<p>组态：</p>
<ul>
<li>定义：晶体管接入电路的方法（晶体管接入电路的形态）。</li>
<li>种类：共基组态（共基极的接入方法）、共射组态和共集组态</li>
<li>F&amp;Q：
<ul>
<li>共"的含义——共在组态的概念中指端口共用。
<ul>
<li>进一步解释端口共用："将 BJT 晶体管看作一个双端口网络模型进行分析时，需要输入输出各两个端口，而晶体管有 3 个端口，因此需要一个端口共用。"</li>
</ul></li>
<li>在组态概念下我们要讨论的问题是什么：
<ul>
<li>首先明确组态概念下讨论的是晶体管本身的伏安特性，谈论组态时是不含不涵盖除晶体管之外的其他元器件的。</li>
<li>不同组态下晶体管展现出的不同的输入输出特性（伏安特性）是我们研究的重点</li>
</ul></li>
</ul></li>
</ul>
<p>电路负载线：</p>
<ul>
<li>定义：电路负载线表征电路对元器件施加的约束，这个约束表现为一种伏安关系</li>
<li>方法：负载线可以由基本的电路定律得到（如基尔霍夫定律）</li>
<li>tips：使用电路定律得到的负载线公式可以整理成针对于某一负载伏安关系的一次函数: <span class="math inline">\(i=k v+b\)</span></li>
</ul>
<p>器件的伏安特性与</p>
<p>耦合：</p>
<ul>
<li>定义：耦合就是连接的意思</li>
<li>耦合电容：晶体管电路中的耦合电容起到连接直流源与交流源的作用</li>
</ul>
<p>偏置与静态工作点：</p>
<ul>
<li><p>偏置的含义：偏置是一种利用直流电压为电路设置固定直流电流和电压的广义称谓</p></li>
<li><p>讨论偏置时的研究对象我们的研究对象不是电子元器件，而是某一电路</p></li>
<li><p>偏置操作不但在"电路网络（黑箱）"外加入了直流电源，而且配合了电阻器件进行约束。</p>
<ul>
<li>以晶体管的偏置为例：直流电源与电阻一起构成了晶体管电路，该对晶体管工作范围进行了约束，这种约束可以使用负载线来表示，并且可以通过数学形式变化将负载线与晶体管的输入输出特征曲线放在同一坐标轴下得到一个交点，称为静态工作点</li>
</ul></li>
<li><p>静态工作点的含义：</p>
<ul>
<li>偏置时设置的固定的电流与电压被称为静态工作点，标记为 Q</li>
<li>静态工作点由元器件伏安特性和电路伏安约束共同确定，对于特定的器件，静态工作点仅由电路的配置决定。</li>
<li>对于晶体管，配置不同的静态工作点有两个目标
<ul>
<li>第一个目标时让晶体管工作在特定的状态，在模拟电子技术中我们希望让晶体管工作在放大的工作状态</li>
<li>第二个目标是针对线性的放大工作范围，我们还要挑选一个合适的位置，不能使得放大的信号失真</li>
</ul></li>
</ul></li>
<li><p>晶体管放大要求（偏置要求）</p>
<ul>
<li><p>输入电压应该超过晶体管导通电压。</p>
<p>The input voltage should exceed <strong>cut-in voltage</strong> for the transistor to be <strong>ON</strong>.</p></li>
<li><p>BJT应该在有源区，作为一个放大器。</p>
<p>The BJT should be in the <strong>active region</strong>, to be operated as an <strong>amplifier</strong>.</p></li>
</ul></li>
</ul>
<p><span class="math display">\[
\begin{gather*}
\begin{aligned}
I_C&amp;=I_{\sf{多子电流}}+I_{\sf{少子电流}}\\
   &amp;=\alpha I_E+I_{CBO}\\
   &amp;=\alpha (I_B+I_C)+I_{CBO}\\
\end{aligned}
\Rightarrow
I_C=\frac{\alpha}{1-\alpha}I_B+\frac{1}{1-\alpha}I_{CBO}=\beta I_B+I_{CEO}
\end{gather*}
\]</span> <span class="math inline">\(I_E=I_se^{v_{BE}/V_T}\)</span></p>
<p><span class="math inline">\(I_C=\alpha I_E+I_{CBO}\)</span></p>
<h3 id="稳定化stabilization">稳定化（Stabilization）</h3>
<p>为了让晶体管</p>
<blockquote>
<p>使操作点独立于温度变化或晶体管参数变化的过程被称为稳定。</p>
<p>The process of making the operating point independent of temperature changes or variations in transistor parameters is known as <strong>Stabilization</strong>.</p>
</blockquote>
]]></content>
      <tags>
        <tag>电子学</tag>
      </tags>
  </entry>
  <entry>
    <title>电子学</title>
    <url>/2022/02/27/16-41-33/</url>
    <content><![CDATA[<h1 id="电子学">电子学</h1>
<h3 id="前言">前言</h3>
<p>本书主要参考尼曼（Donald A. Neamen）的《电子电路分析与设计（第四版）》（Microelectronics: Circuit Analysis And Design Forth Edition）写成。</p>
<h2 id="半导体器件及其基本应用">半导体器件及其基本应用</h2>
<h3 id="半导体">半导体</h3>
<p>在电路课和物理课上我们已经学习了一些电子器件，例如最典型的器件——电阻器。电阻器是导体，其最重要的性质“电阻”表示了导体对于电流的阻碍性质。除此之外我们还学习了电容和电感；电感的性质存在于线圈之中，线圈是使用导体制成的；电容则是导体极板中间夹着一个绝缘体介质形成。如此归纳，我们会发现在之前的课程之中，我们了解的范畴始终存在于导体和绝缘体之中，而半导体材料制作而成的器件却从未被提及。所以，在“半导体”这一节中，我们将注意力集中在半导体上，从研究半导体自身的性质开始，最终我们将得到一个简单的半导体器件。</p>
<p>正式开始本节前，我们简单地回顾一下中学的知识，以下这些是作者默认读者已经了解了的知识。</p>
<ul>
<li>导体中存在大量可以自由移动的电子，称之为自由电子（free electron）。自由电子在受到外电场或外磁场的作用时，能够在物质中自由移动。</li>
<li>导体中自由电子的定向移动形成了电流，电流（current）的定义式为 <span class="math inline">\(i=\frac{dq}{dt}\)</span>。</li>
<li>载流子（charge carrier）指可以自由移动的带有电荷的物质微粒，是物质中电流形成的原因，导体中的载流子是电子。</li>
<li>在半导体中存在两种载流子——电子（electron）和空穴（hole）。空穴是电子移动后留下的空位，从物理模型上可以将空穴看作是正电子。在半导体中，电子和空穴两种载流子共同形成半导体中的电流。</li>
</ul>
<h4 id="本征半导体intrinsic-semiconductor">本征半导体（intrinsic semiconductor）</h4>
<blockquote>
<p>本征半导体是指纯净（pure）的半导体</p>
</blockquote>
<p>本征半导体的概念是我们应当格外注意的，因为这不是一个偏日常化和口语化的词语，但是在这里它的含义却是十分简单——本征，不过就是纯净不含杂质的意思。</p>
<p>强调材料的纯度似乎是一件奇怪的事情，因为常识中我们通常认为提纯是必须的，无需额外强调的。例如我们不会强调一个钢筋的纯度，但是我们知道</p>
<p>本征半导体是指纯净的半导体，强调这个词似乎暗示着有一种不纯净的半导体的存在，并且这种不纯净的半导体的存在是十分有必要的。</p>
<h3 id="二极管及其基本电路">二极管及其基本电路</h3>
<p>TODO</p>
<h3 id="三极管及其基本电路">三极管及其基本电路</h3>
<p>TODO</p>
<h3 id="场效应管及其基本电路">场效应管及其基本电路</h3>
<p>TODO</p>
<h2 id="模拟电子技术">模拟电子技术</h2>
<p>TODO</p>
<h2 id="数字电子技术">数字电子技术</h2>
<p>TODO</p>
<h2 id="运算放大器电路">运算放大器电路</h2>
<p>分析顺序</p>
<ul>
<li>图像</li>
<li>公式</li>
<li>结论</li>
</ul>
<ol type="1">
<li><p>反相放大电路</p>
<ul>
<li><p>反相放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1249-16473232199221.PNG" alt="IMG_1249" style="zoom: 25%;"></p></li>
<li><p>反相放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p>假设运算放大器是理想的，即</p>
<ul>
<li>开环增益 <span class="math inline">\(A_{od}=\infty\)</span>：故输入信号 <span class="math inline">\(v_1\)</span> 和 <span class="math inline">\(v_2\)</span> 是相等的。且由于 <span class="math inline">\(v_2\)</span> 与地面连接，故 <span class="math inline">\(v_2\)</span> 是“接地”，而 <span class="math inline">\(v_1\)</span> 是“虚地”。</li>
<li>输入阻抗大小为 <span class="math inline">\(\infty\)</span>：流入运算放大器的电流为 <span class="math inline">\(0\)</span> 。</li>
</ul>
<p>理想运放约束+基尔霍夫定律可得： <span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;\frac{v_{i_1}-v_1}{R_1}=\frac{v_1-v_o}{R_2}\\\\
&amp;v_1=0
\end{aligned}
\end{cases}
\quad
\Longrightarrow
\quad
A_v=\frac{v_o}{v_{i_1}}=-\frac{R_2}{R_1}\tag{1-1}
\]</span></p></li>
<li><p>结论和注意事项：</p>
<ul>
<li>对于理想运放，闭环电压增益是运放外电阻比值的函数，与运放内部的参数无关。</li>
<li>增益中的负号表示 “反相” ，是反相放大电路名字的由来。</li>
<li>反相放大电路中没有耦合电容（就是电容，作用是耦合所以叫耦合电容），因此反相放大电路可以放大直流电压信号。</li>
</ul></li>
</ul></li>
<li><p>反相放大电路扩展——带 T 型网络的放大电路</p>
<ul>
<li><p>作为改进方案被提出的原因：</p>
<p>反相放大电路的增益 <span class="math inline">\(A_v\)</span> 为 <span class="math inline">\(-\frac{R_2}{R_1}\)</span>，那么如果我们的设计目标是设计一个闭环增益 <span class="math inline">\(A_v=-100\)</span> 且输入电阻 <span class="math inline">\(R_i=R_1=50k\Omega\)</span> 的反相放大电路。于是，反馈电阻 <span class="math inline">\(R_2\)</span> 就必须是 <span class="math inline">\(5M\Omega\)</span>。然而，这个电阻值对大多数实际电路来说太大了。为了解决这个问题我们提出了作为改进方案的带 T 型网络的放大电路。</p></li>
<li><p>带 T 型网络的放大电路的电路图如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1258.PNG" alt="IMG_1258" style="zoom:25%;"></p></li>
<li><p>设 <span class="math inline">\(R_2\)</span>、<span class="math inline">\(R_3\)</span> 和 <span class="math inline">\(R_4\)</span> 三个电阻的公共节点处电势为 <span class="math inline">\(v_x\)</span>，则: <span class="math display">\[
\begin{cases}
\begin{aligned}
&amp;i_2+i_3=i_4\\\\
&amp;\frac{v_1-v_x}{R_2}+\frac{v_x-v_o}{R_3}=\frac{v_x}{R_4}\\\\
&amp;v_1=0
\end{aligned}
\end{cases}
\quad
\Longrightarrow
\quad
A_v=\frac{v_o}{v_{i_1}}=-\frac{R_2}{R_1}
\]</span></p></li>
<li><p>结论和注意事项：</p>
<p>使用带 T 型网络的放大电路，可以在使用合理大小电阻的情况下获得更大的增益。</p></li>
</ul></li>
<li><p>同相放大电路；</p>
<ul>
<li><p>同相放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1253-16473270320863.PNG" alt="IMG_1253" style="zoom: 25%;"></p></li>
<li><p>同相放大电路增益 <span class="math inline">\(A_v=\frac{R_2}{R_1}+1\)</span>： <span class="math display">\[
\begin{aligned}
&amp;\begin{cases}
v_-=v_+=v_i\\\\
\frac{0-v_-}{R1}=\frac{v_--v_o}{R_2}\\
\end{cases}\\\\
&amp;get\quad A_v=\frac{v_o}{v_i}=\frac{R_2}{R_1}+1
\end{aligned}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>电压跟随器：</p>
<ul>
<li><p>电压跟随器连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1246.PNG" alt="IMG_1246" style="zoom:25%;"></p></li>
<li><p>电压跟随器增益 <span class="math inline">\(A_v\)</span>：</p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>求和放大电路：</p>
<ul>
<li><p>求和放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1252.PNG" alt="IMG_1252" style="zoom:25%;"></p></li>
<li><p>输出电压为 <span class="math inline">\(v_o=-R_f\sum_{j=1}^{n}\frac{v_{i_j}}{R_i}\)</span>：</p>
<p><span class="math display">\[
\sum_{j=1}^{n}\frac{v_{i_j}-0}{R_i}=\frac{0-v_o}{R_f}\\
get\quad v_o=-R_f\sum_{j=1}^{n}\frac{v_{i_j}}{R_i}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>差分放大电路：</p>
<ul>
<li><p>差分放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1244.PNG" alt="IMG_1244" style="zoom:25%;"></p></li>
<li><p>输出电压为 <span class="math inline">\(v_o=\frac{R_2}{R_1}(v_{i_2}-v_{i_1})\)</span>：</p>
<p>$$</p>
<span class="math display">\[\begin{aligned}
&amp;if\quad v_{i_2}=0,\;v_{i_1}\not=0\\

&amp;then\quad v_{o_1}=-\frac{R_2}{R_1}v_{i_1}\\\\\\

&amp;if\quad v_{i_2}\not=0,\;v_{i_1}=0\\

&amp;then\quad v_{o_2}=\left(1+\frac{R_2}{R_1}\right)\left(1+\frac{R_4}{R_3+R_4}\right)v_{i_2}\\\\\\

&amp;so\quad v_o=v_{o_1}+v_{o_2}=\left(1+\frac{R_2}{R_1}\right)\left(1+\frac{R_4}{R_3+R_4}\right)v_{i_2}-\frac{R_2}{R_1}v_{i_1}\\

&amp;To\quad satified\quad when\quad v_{i_1}=v_{i_2},v_o=0\,;so\quad \frac{R_4}{R_3}=\frac{R_2}{R_1}\\

&amp;Finally\quad v_o=\frac{R_2}{R_1}(v_{i_2}-v_{i_1})
\end{aligned}\]</span>
<p>$$</p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>积分放大电路：</p>
<ul>
<li><p>积分放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1254.PNG" alt="IMG_1254" style="zoom:25%;"></p></li>
<li><p>积分放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=V_C-\frac{1}{RC}\int_{0}^{t}v_i(\tau)d\tau
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>微分放大电路：</p>
<ul>
<li><p>微分放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1251.PNG" alt="IMG_1251" style="zoom:25%;"></p></li>
<li><p>微分放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=-RC\frac{dv_{i}}{dt}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>对数放大电路：</p>
<ul>
<li><p>对数放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1247.PNG" alt="IMG_1247" style="zoom:25%;"></p></li>
<li><p>对数放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=-V_Tln\left(\frac{v_i}{I_SR_1}\right)
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>指数放大电路：</p>
<ul>
<li><p>指数放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1257.PNG" alt="IMG_1257" style="zoom:25%;"></p></li>
<li><p>指数放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=-I_SR\cdot e^{v_i/V_T}
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
<li><p>仪用放大电路：</p>
<ul>
<li><p>仪用放大电路连接方式如图所示：</p>
<p><img src="/2022/02/27/16-41-33/IMG_1256.PNG" alt="IMG_1256" style="zoom:25%;"></p></li>
<li><p>仪用放大电路增益 <span class="math inline">\(A_v\)</span>：</p>
<p><span class="math display">\[
v_o=\frac{R_4}{R_3}\left(1+\frac{2R_2}{R_1}\right)(v_{i_2}-v_{i_1})
\]</span></p></li>
<li><p>结论和注意事项：</p></li>
</ul></li>
</ol>
<h2 id="集成电路偏置">集成电路偏置</h2>
<p>使用分立电子元器件对晶体管放大电路进行偏置时，我们通常使用的是分压电阻网络。在集成电路设计中，电阻的集成需要比晶体管更大的面积，因此我们更希望通过晶体管来配置放大电路。在接下来的设计中我们可以看到，晶体管可以构成恒流源和负载器件。</p>
<p>集成电路偏置和有源负载这一章节学习了在设计集成电路中需要使用到的<strong>晶体管恒流源——镜像电流源（Current Mirror）</strong>和<strong>晶体管电阻（负载）——有源负载</strong></p>
<p>关于集成电路的部分放到下一阶段学习吧</p>
<p>一个设计良好的电流源电路，必须同时满足如下这四点要求：</p>
<ul>
<li>能够输出符合要求的直流电流；</li>
<li>温度稳定性更好；</li>
<li>受到电源电压等因素的影响较小；</li>
<li>输出电阻要尽可能更大；</li>
</ul>
<p>如果一个电流源能够同时满足上述这些要求，那么就可以将其等效为下面的<strong>理想电流源</strong>：<img src="/2022/02/27/16-41-33/image-20220316212039647-16474368536751.png" alt="image-20220316212039647" style="zoom:25%;"></p>
<p>晶体管和场效应管等有源元件，在放大区的输出电流几乎不受输出电压的影响，展现出恒流特性：</p>
<h2 id="差分和多级放大电路">差分和多级放大电路</h2>
<p>本章介绍的是主要内容是一种多晶体管电路——差分放大电路。与之前理想运放一节不同的是，这里的差分放大电路是由基本的晶体管构成的电路</p>
<p>差分放大电路是模拟电路的基本单元，既是几乎所有运放的输入级，也是高速数字逻辑电路的基础。</p>
<p>差分放大电路为</p>
<h2 id="section"></h2>
<h3 id="施密特触发器">施密特触发器</h3>
<h4 id="比较器">比较器</h4>
<h4 id="施密特触发器-1">施密特触发器</h4>
<figure>
<img src="/2022/02/27/16-41-33/image-20220908164602437.png" alt="image-20220908164602437"><figcaption aria-hidden="true">image-20220908164602437</figcaption>
</figure>
<h1 id="放大电路">放大电路</h1>
<h2 id="基本放大电路的构成">基本放大电路的构成</h2>
<p>设计一个放大电路：</p>
<ol type="1">
<li><p>放大的概念：</p>
<p>放大电路的放大是指对于功率的放大，即小电流电压输入转化为一个大电流电压输出</p></li>
<li><p>本质：</p>
<p>功率放大的本质在于对能量的控制。</p>
<p>为了首先对能量的控制，我们必须在电路中引入一个控制能力的元件——有源元件，具体来说就是三极管和场效应管等。</p></li>
<li><p>前提：</p>
<p>合理放大信号的前提是不失真</p></li>
<li><p>测试：</p>
<p>在实验中我们使用正弦波进行信号放大的测试。</p>
<p>因为声波或其他各种波形，由傅里叶变换可以变换成多个正弦波的叠加，故只要电路系统可以正常的放大分解后的所有正弦波，就可以实现具体的设计目标。</p>
<p>因此在实验中我们使用正弦波进行放大的测试</p></li>
<li><p>放大电路的构建方法：</p>
<ol type="1">
<li>目标：小功率转化为大功率
<ul>
<li>小信号：小的什么程度：几毫伏或几十个毫伏</li>
</ul></li>
<li>条件：
<ul>
<li>有源元件</li>
<li>能量</li>
</ul></li>
<li>技术路线：
<ul>
<li>三极管工作在放大状态下——即 <span class="math inline">\(i_b\)</span> 可以控制 <span class="math inline">\(i_c\)</span></li>
<li>小信号控制 <span class="math inline">\(i_b\)</span></li>
<li>合理的输出</li>
</ul></li>
<li></li>
</ol></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li><p><span class="math display">\[
V_i（一个小信号输出电压）-&gt;放大电路-&gt;实现功率放大
\]</span></p></li>
</ol>
<h4 id="移相式振荡电路">移相式振荡电路</h4>
<p>移相式振荡电路，顾名思义，就是使相位发生移动来产生振荡的电路。</p>
<p>第一个要介绍的振荡电路是移相式振荡电路。移相式振荡电路如下图所示，由一个RC网络和一个反相放大器组成。可以看到放大器的输出即为振荡器的输出。接下来我们将进一步介绍这个振荡电路的细节。</p>
<p>实用移相式振荡电路示意图：</p>
<figure>
<img src="/2022/02/27/16-41-33/image-20220908163737771.png" alt="image-20220908163737771"><figcaption aria-hidden="true">image-20220908163737771</figcaption>
</figure>
<p>为了便于理解，我们将移相式振荡电路中的 RC 网络进行单独分析。在移相式振荡电路中，由于 <span class="math inline">\(R_3\)</span> 右边与运放的反相端相连，而运放的正相端与地相连，由于</p>
<p><img src="/2022/02/27/16-41-33/image-20220908182838269.png" alt="image-20220908182838269"> <span class="math display">\[
\begin{aligned}
&amp;-V_o + \frac{1}{sC}i_1 + R(i_1-i_2) = 0\\ 
&amp;-R(i_1-i_2) + \frac{1}{sC}i_2 + R(i_2-i_3) = 0\\
&amp;-R(i_2-i_3) + \frac{1}{sC}i_3 + Ri_3 = 0
\end{aligned}
\]</span> 由第三个式子得： <span class="math display">\[
-R(i_2-i_3) + \frac{1}{sC}i_3 + Ri_3 = 0 \quad
\longrightarrow \quad
i_2 = \frac{\frac{1}{sC}+2R}{R}i_3
\]</span> <span class="math inline">\(i_2\)</span> 带入第一个式子得： <span class="math display">\[
-R(i_2-i_3) + \frac{1}{sC}i_3 + Ri_3 = 0 \quad
\longrightarrow \quad
i_1 = \frac{ (\frac{1}{sC}+2R)i_3 + V_o }{\frac{1}{sC}+R}
\]</span> <span class="math inline">\(i_1,i_2\)</span> 带入第二个式子得： <span class="math display">\[
\begin{gather}
-R(i_1-i_2) + \frac{1}{sC}i_2 + R(i_2-i_3) = 0\\
\downarrow \\
\left( \frac{\frac{1}{sC}+2R}{R} \right)i_2 = i_3 + i_1\\
\downarrow \\
\left( \frac{\frac{1}{sC}+2R}{R} \right)^2i_3 = i_3 +\frac{ \left( \frac{1}{sC}+2R \right)}{\frac{1}{sC}+R}i_3 + \frac{V_o}{\frac{1}{sC}+R}\\
\downarrow \\
\left(\frac{\frac{1}{(sC)^2}+\frac{4R}{sC}+4R^2}{R^2}-1-\frac{\frac{2}{sC}+3R}{\frac{1}{sC}+R}\right)i_3 = \frac{V_o}{\frac{1}{sC}+R}\\
\downarrow \\
i_3 = \frac{V_o}{\frac{1}{sC}+R} \cdot \left( \frac{R^2\left(\frac{1}{sC}+R\right)}{\frac{1}{(sC)^3}+\frac{5R}{(sC)^2}+\frac{6R^2}{sC}+R^3}\right)\\
\downarrow \\
i_3 = \left( \frac{R^2}{\frac{1}{(sC)^3}+\frac{5R}{(sC)^2}+\frac{6R^2}{sC}+R^3}\right)V_o
\end{gather}
\]</span> 那么此时 <span class="math inline">\(V_3\)</span> 为 <span class="math display">\[
V_3 = \left( \frac{R^2}{\frac{1}{(sC)^3}+\frac{5R}{(sC)^2}+\frac{6R^2}{sC}+R^3}\right)V_o
\]</span> 由图片可知对于上面的 RC 网络，传递函数 <span class="math inline">\(H(s) = V_3/V_o\)</span></p>
<p>故 RC 网络作为移相式振荡电路的选频网络时 <span class="math display">\[
\beta(s) = H(s) = \frac{V_3}{V_o} = \left( \frac{R^3}{\frac{1}{(sC)^3}+\frac{5R}{(sC)^2}+\frac{6R^2}{sC}+R^3}\right)
\]</span> 为了满足 <span class="math display">\[
T(s)=A(s)\beta(s)=1 \quad or \quad T(j\omega_0)=A(j\omega_0)\beta(j\omega_0)=-1
\]</span> 且我们知道反相放大器的增益 <span class="math inline">\(A(s)\)</span> 为实数，故选频网络的 <span class="math inline">\(\beta(s)\)</span> 也应当是实数</p>
<p>我们将 <span class="math inline">\(\beta(s)\)</span> 展开为 <span class="math inline">\(\beta(j\omega_0)\)</span>，以此观察如何确保 <span class="math inline">\(\beta(s)\)</span> 为实数：</p>
<p>首先我们有： <span class="math display">\[
\begin{aligned}
&amp;\frac{1}{sC}=\frac{1}{j\omega C}=-\frac{j}{\omega C}\\
&amp;\frac{1}{(sC)^2}=\frac{1}{(j\omega C)^2}=-\frac{1}{(\omega C)^2}\\
&amp;\frac{1}{(sC)^3}=-\frac{1}{(\omega C)^2} \cdot -\frac{j}{\omega C} = \frac{j}{(\omega C)^3}\\
\end{aligned}
\]</span> 带入到 <span class="math inline">\(\beta(s)\)</span> <span class="math display">\[
\beta(j\omega_0) = \left( \frac{R^3}{j\frac{1}{(\omega C)^3}-\frac{5R}{(\omega C)^2}-j\frac{6R^2}{\omega C}+R^3}\right) =  \left( \frac{R^3}{j\left(\frac{1}{(\omega C)^3}-\frac{6R^2}{\omega C}\right)-\frac{5R}{(\omega C)^2}+R^3}\right)
\]</span> 则满足下式时 <span class="math inline">\(\beta(s)\)</span> 为实数 <span class="math display">\[
\frac{1}{(\omega C)^3}-\frac{6R^2}{\omega C}=0
\]</span> 解的 <span class="math display">\[
\omega = \frac{1}{\sqrt{6}RC}
\]</span> 求解处的 <span class="math inline">\(\omega\)</span> 的含义是，当我们使用 RC 网络搭建电路时，若振荡器能正常振荡，则振荡频率可以使用这个公式进行计算。</p>
<p>那么如何配置电路从而让电路正常振荡呢？</p>
<p>电路正常振荡需要满足 <span class="math inline">\(T(s)=A(s)\beta(s)=1\)</span>，缺一不可，因此选择完 RC 电路确定频率后，我们将 <span class="math inline">\(\omega = \frac{1}{\sqrt{6}RC}\)</span> 带入到 <span class="math inline">\(\beta(j\omega_0)\)</span> 中，得到 <span class="math display">\[
\beta(j\omega_0) = \left( \frac{R^3}{-\frac{5R}{(\omega C)^2}+R^3}\right) = \frac{1}{1-\frac{5}{\omega^2C^2R^2}} = \frac{1}{1-\frac{5}{\frac{1}{6R^2C^2}R^2C^2}} = \frac{1}{1-30} = -\frac{1}{29}
\]</span> 那么可以求得 <span class="math display">\[
A(j\omega_0) = \frac{T(j\omega_0)}{\beta(j\omega_0)}=\frac{-1}{-\frac{1}{29}}=29
\]</span> 因此反相放大器的增益选择与 RC 网络无关，其值恒等于29.</p>
<p>移相式振荡电路总结： <span class="math display">\[
\begin{gather}\omega = \frac{1}{\sqrt{6}RC}\\
A(j\omega_0) =29\end{gather}
\]</span></p>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>电路基础</title>
    <url>/2022/02/27/16-42-00/</url>
    <content><![CDATA[
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab收集数据绘制箱型图</title>
    <url>/2022/02/25/08-07-35/</url>
    <content><![CDATA[<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%读取实验数据并绘制箱型图</span></span><br><span class="line"><span class="comment">%&#123;</span></span><br><span class="line"><span class="comment">##########################################################</span></span><br><span class="line"><span class="comment">使用手册：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">数据文档：(Data Text) 软件生成的文本文档，例如：qjy_q1-1_20210827181142。</span></span><br><span class="line"><span class="comment">数据文件夹：(Date File) 使用软件时创建的文件夹，例如：20210827；约定：数据文件夹的名称按“年月日”连续数字来命名，不按照约定命名可能导致读取异常。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">设置文件夹：</span></span><br><span class="line"><span class="comment">首先设置matlab的“当前文件夹”为包含“数据文件夹”的文件夹</span></span><br><span class="line"><span class="comment">根据提示输入“数据文件夹”名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##########################################################</span></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line">prompt = <span class="string">&#x27;请输入数据文件夹名称：&#x27;</span>;</span><br><span class="line">str = input(prompt);</span><br><span class="line">DataFileName = sprintf(<span class="string">&#x27;%d&#x27;</span>,str);<span class="comment">%读入“数字”并转化为“文件夹名”</span></span><br><span class="line"></span><br><span class="line">stop_tag = <span class="built_in">length</span>(&#123;DataFileInf.name&#125;);<span class="comment">%先转化成元胞数组，然后统计元胞数量作为截至循环标签</span></span><br><span class="line"></span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> n+<span class="number">2</span>&lt;=stop_tag</span><br><span class="line">	DataText(n).Name=DataFileInf(n+<span class="number">2</span>).name;</span><br><span class="line"></span><br><span class="line">	userpath(DataFileInf(<span class="number">1</span>).folder);<span class="comment">%修改当前文件夹为“数据文件夹”</span></span><br><span class="line"></span><br><span class="line">	fileID = fopen(DataText(n).Name);</span><br><span class="line">	CellMidDatas = textscan(fileID,<span class="string">&#x27;%s %*[^\n]&#x27;</span>);<span class="comment">%以cell形式提取文件的第一列</span></span><br><span class="line">	fclose(fileID);</span><br><span class="line"></span><br><span class="line">	mid = CellMidDatas&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">	C_usfull_data = [mid(<span class="number">3</span>,<span class="number">1</span>),mid(<span class="number">8</span>,<span class="number">1</span>),mid(<span class="number">9</span>,<span class="number">1</span>),mid(<span class="number">10</span>,<span class="number">1</span>)];<span class="comment">%提取有用信息</span></span><br><span class="line"><span class="comment">%&#123;</span></span><br><span class="line"><span class="comment">==================</span></span><br><span class="line"><span class="comment">J_sc=mid(3,1);</span></span><br><span class="line"><span class="comment">V_oc=mid(8,1);</span></span><br><span class="line"><span class="comment">FF=mid(9,1);</span></span><br><span class="line"><span class="comment">Eta = mid(10,1);</span></span><br><span class="line"><span class="comment">===================</span></span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line">	usfull_data_str = cell2mat(C_usfull_data);<span class="comment">%将元胞数组转化为普通数组(单引号字符串的数组形式会自动合并)</span></span><br><span class="line">	C_usfull_data_num = regexp(usfull_data_str,<span class="string">&#x27;\d*\.?\d*&#x27;</span>,<span class="string">&#x27;match&#x27;</span>);<span class="comment">%提取字符串中的数字并以元胞数组形式储存</span></span><br><span class="line">	usfull_data_num=string(C_usfull_data_num);<span class="comment">%将元胞数组转换为普通(双引号字符串)数组</span></span><br><span class="line">	usfull_data = str2double(usfull_data_num);<span class="comment">%将字符串转化为数字</span></span><br><span class="line">	Data(n,:) = usfull_data(<span class="number">1</span>,:);</span><br><span class="line">	n=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">J_sc = Data(:,<span class="number">1</span>);</span><br><span class="line">V_oc = Data(:,<span class="number">2</span>);</span><br><span class="line">FF = Data(:,<span class="number">3</span>);</span><br><span class="line">Eta = Data(:,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;统计数据完成&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%读取实验数据并绘制箱型图</span></span><br><span class="line"><span class="comment">%使用前需在matlab的“当前文件夹”中考入数据文件夹(如20210827)</span></span><br><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"></span><br><span class="line">str = input(<span class="string">&#x27;请输入数据文件夹名称：&#x27;</span>);</span><br><span class="line">DataFileName = sprintf(<span class="string">&#x27;%d&#x27;</span>,str);</span><br><span class="line"></span><br><span class="line">DataFileInf=dir(DataFileName);</span><br><span class="line">stop_tag = <span class="built_in">length</span>(&#123;DataFileInf.name&#125;);<span class="comment">%先转化成元胞数组，然后统计元胞数量作为截至循环标签</span></span><br><span class="line"></span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> n+<span class="number">2</span>&lt;=stop_tag</span><br><span class="line">	DataText(n).Name = DataFileInf(n+<span class="number">2</span>).name;</span><br><span class="line"></span><br><span class="line">	userpath(DataFileInf(<span class="number">1</span>).folder);</span><br><span class="line"></span><br><span class="line">	fileID = fopen(DataText(n).Name);</span><br><span class="line">	CellMidDatas = textscan(fileID,<span class="string">&#x27;%s %*[^\n]&#x27;</span>);</span><br><span class="line">	fclose(fileID);</span><br><span class="line"></span><br><span class="line">	mid = CellMidDatas&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">	C_usfull_data = [mid(<span class="number">3</span>,<span class="number">1</span>),mid(<span class="number">8</span>,<span class="number">1</span>),mid(<span class="number">9</span>,<span class="number">1</span>),mid(<span class="number">10</span>,<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">	usfull_data_str = cell2mat(C_usfull_data);</span><br><span class="line">	C_usfull_data_num = regexp(usfull_data_str,<span class="string">&#x27;\d*\.?\d*&#x27;</span>,<span class="string">&#x27;match&#x27;</span>);<span class="comment">%提取正数</span></span><br><span class="line">	<span class="comment">%C_usfull_data_num = regexp(usfull_data_str, &#x27;-?\d*\.?\d*&#x27;, &#x27;match&#x27;);%可以提取负数</span></span><br><span class="line">	usfull_data_num = string(C_usfull_data_num);</span><br><span class="line">	usfull_data = str2double(usfull_data_num);</span><br><span class="line">	Data(n,:) = usfull_data(<span class="number">1</span>,:);</span><br><span class="line">	</span><br><span class="line">	n=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;统计数据完成&#x27;</span>);</span><br><span class="line">Data</span><br><span class="line">J_sc = Data(:,<span class="number">1</span>);</span><br><span class="line">V_oc = Data(:,<span class="number">2</span>);</span><br><span class="line">FF = Data(:,<span class="number">3</span>);</span><br><span class="line">Eta = Data(:,<span class="number">4</span>);</span><br><span class="line"><span class="comment">%================================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box11_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line"> X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line"> Y=vertcat(y1,y2,y3);</span><br><span class="line"> boxplot(X,Y);</span><br><span class="line"></span><br><span class="line"><span class="comment">%================================================================================</span></span><br><span class="line">judge=input(<span class="string">&#x27;绘图or生成表格:&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> judge == <span class="string">&#x27;绘图&#x27;</span></span><br><span class="line">	<span class="comment">%查询片的数量:</span></span><br><span class="line">	PIECE=input(<span class="string">&#x27;片的数量？\n输入示例:8\n&#x27;</span>);</span><br><span class="line">	CELL=input(<span class="string">&#x27;电池的数量？\n输入示例:[9 9 9 9 9 9 9 9]\n&#x27;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">%定义分类方式:</span></span><br><span class="line">	IpMid=input(<span class="string">&#x27;输入分类方式，将作为箱型图的X轴.\n输入示例:2-3石墨盒 1-2石墨盒\n&#x27;</span>,<span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">	class_way = string(split(IpMid));</span><br><span class="line">	m=<span class="built_in">length</span>(class_way);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">%对应分类方式与片的关系:</span></span><br><span class="line">	<span class="keyword">for</span> n=<span class="number">1</span>:m</span><br><span class="line">		fprintf(<span class="string">&#x27;第%d个条件对应的片的序号\n输入示例:[1 3 5]&#x27;</span>,n);</span><br><span class="line">		Part(n,:) = &#123;input(<span class="string">&#x27;\n&#x27;</span>)&#125;;</span><br><span class="line">		Length(n,:)=<span class="built_in">length</span>(Part&#123;n,:&#125;);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">%画图</span></span><br><span class="line">	<span class="keyword">for</span> m=<span class="number">1</span>:CELL(<span class="number">1</span>)</span><br><span class="line">		load_data_plot(<span class="number">1</span>,m) = J_sc(m);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">for</span> n=<span class="number">2</span>:PIECE</span><br><span class="line">		<span class="keyword">for</span> m=<span class="number">1</span>:CELL(n)</span><br><span class="line">			load_data_plot(n,m) = J_sc((n<span class="number">-1</span>)*CELL(n<span class="number">-1</span>)+m);</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">for</span> n=<span class="number">1</span>:m</span><br><span class="line">		<span class="keyword">for</span> q=<span class="number">1</span>:Length</span><br><span class="line">			data_plot(n,:)=&#123;load_data_plot(Part&#123;n,<span class="number">1</span>&#125;(<span class="number">1</span>,q),:)&#125;</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	Plot_title=input(<span class="string">&#x27;输入图像的名称:&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">	X_name=<span class="string">&#x27;条件&#x27;</span>;</span><br><span class="line">	Y_name=input(<span class="string">&#x27;输入Y轴的名称:&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">	<span class="keyword">switch</span> Y_name</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;J_sc&#x27;</span></span><br><span class="line">			a=<span class="number">1</span>;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;V_oc&#x27;</span></span><br><span class="line">			a=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;FF&#x27;</span></span><br><span class="line">			a=<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;Eta&#x27;</span></span><br><span class="line">			a=<span class="number">4</span>;</span><br><span class="line">		<span class="keyword">otherwise</span></span><br><span class="line">			warning(<span class="string">&#x27;输入错误，请按照要求输入。&#x27;</span>)</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	title(Plot_title);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">elseif</span> judge == <span class="string">&quot;生成表格&quot;</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">disp</span>(<span class="string">&quot;输入错误,请输入“绘图”或者“生成表格”。&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%读取实验数据并绘制箱型图</span></span><br><span class="line"><span class="comment">%使用前需在matlab的“当前文件夹”中考入数据文件夹(如20210827)</span></span><br><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line"></span><br><span class="line">str = input(<span class="string">&#x27;请输入数据文件夹名称：&#x27;</span>);</span><br><span class="line">DataFileName = sprintf(<span class="string">&#x27;%d&#x27;</span>,str);</span><br><span class="line"></span><br><span class="line">DataFileInf=dir(DataFileName);</span><br><span class="line">stop_tag = <span class="built_in">length</span>(&#123;DataFileInf.name&#125;);<span class="comment">%先转化成元胞数组，然后统计元胞数量作为截至循环标签</span></span><br><span class="line"></span><br><span class="line">n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> n+<span class="number">2</span>&lt;=stop_tag</span><br><span class="line">	DataText(n).Name = DataFileInf(n+<span class="number">2</span>).name;</span><br><span class="line"></span><br><span class="line">	userpath(DataFileInf(<span class="number">1</span>).folder);</span><br><span class="line"></span><br><span class="line">	fileID = fopen(DataText(n).Name);</span><br><span class="line">	CellMidDatas = textscan(fileID,<span class="string">&#x27;%s %*[^\n]&#x27;</span>);</span><br><span class="line">	fclose(fileID);</span><br><span class="line"></span><br><span class="line">	mid = CellMidDatas&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">	C_usfull_data = [mid(<span class="number">3</span>,<span class="number">1</span>),mid(<span class="number">8</span>,<span class="number">1</span>),mid(<span class="number">9</span>,<span class="number">1</span>),mid(<span class="number">10</span>,<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">	usfull_data_str = cell2mat(C_usfull_data);</span><br><span class="line">	C_usfull_data_num = regexp(usfull_data_str,<span class="string">&#x27;\d*\.?\d*&#x27;</span>,<span class="string">&#x27;match&#x27;</span>);<span class="comment">%提取正数</span></span><br><span class="line">	<span class="comment">%C_usfull_data_num = regexp(usfull_data_str, &#x27;-?\d*\.?\d*&#x27;, &#x27;match&#x27;);%可以提取负数</span></span><br><span class="line">	usfull_data_num = string(C_usfull_data_num);</span><br><span class="line">	usfull_data = str2double(usfull_data_num);</span><br><span class="line">	Data(n,:) = usfull_data(<span class="number">1</span>,:);</span><br><span class="line">	</span><br><span class="line">	n=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;统计数据完成&#x27;</span>);</span><br><span class="line">Data</span><br><span class="line">J_sc = Data(:,<span class="number">1</span>);</span><br><span class="line">V_oc = Data(:,<span class="number">2</span>);</span><br><span class="line">FF = Data(:,<span class="number">3</span>);</span><br><span class="line">Eta = Data(:,<span class="number">4</span>);</span><br><span class="line"><span class="comment">%================================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = J_sc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box1_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line">X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line">Y=vertcat(y1,y2,y3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Jsc&#x27;</span>);</span><br><span class="line">boxplot(X,Y);</span><br><span class="line">xlabel(<span class="string">&#x27;condition&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Jsc&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;The boxplot of Jsc&#x27;</span>);</span><br><span class="line"><span class="comment">%==============================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = V_oc(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box1_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line">X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line">Y=vertcat(y1,y2,y3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Voc&#x27;</span>);</span><br><span class="line">boxplot(X,Y);</span><br><span class="line">xlabel(<span class="string">&#x27;condition&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Voc&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;The boxplot of Voc&#x27;</span>);</span><br><span class="line"><span class="comment">%==============================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = FF(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box1_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line">X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line">Y=vertcat(y1,y2,y3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;FF&#x27;</span>);</span><br><span class="line">boxplot(X,Y);</span><br><span class="line">xlabel(<span class="string">&#x27;condition&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;FF&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;The boxplot of FF&#x27;</span>);</span><br><span class="line"><span class="comment">%==============================================================================</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">19</span>:<span class="number">32</span></span><br><span class="line">	box2_3(n<span class="number">-18</span>,<span class="number">1</span>)=Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">36</span>:<span class="number">53</span></span><br><span class="line">	box2_3(n<span class="number">-35</span>+<span class="number">14</span>,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">	sqr(n,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">10</span>:<span class="number">18</span></span><br><span class="line">	box1_2(n<span class="number">-9</span>,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">33</span>:<span class="number">35</span></span><br><span class="line">	box1_2(n<span class="number">-32</span>+<span class="number">9</span>,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> n=<span class="number">54</span>:<span class="number">62</span></span><br><span class="line">	box1_2(n<span class="number">-53</span>+<span class="number">9</span>+<span class="number">3</span>,<span class="number">1</span>) = Eta(n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">y1 = <span class="built_in">repmat</span>(<span class="string">&quot;box2_3&quot;</span>,<span class="built_in">length</span>(box2_3),<span class="number">1</span>);</span><br><span class="line">y2 = <span class="built_in">repmat</span>(<span class="string">&quot;box1_2&quot;</span>,<span class="built_in">length</span>(box1_2),<span class="number">1</span>);</span><br><span class="line">y3 = <span class="built_in">repmat</span>(<span class="string">&quot;sqr&quot;</span>,<span class="built_in">length</span>(sqr),<span class="number">1</span>);</span><br><span class="line">X=vertcat(box2_3,box1_2,sqr);</span><br><span class="line">Y=vertcat(y1,y2,y3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Name&#x27;</span>,<span class="string">&#x27;Eta&#x27;</span>);</span><br><span class="line">boxplot(X,Y);</span><br><span class="line">xlabel(<span class="string">&#x27;condition&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Eta&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;The boxplot of Eta&#x27;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>备忘笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯</title>
    <url>/2022/02/25/11-07-35/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h1 id="蓝桥杯">蓝桥杯</h1>
<figure>
<img src="/2022/02/25/11-07-35/image-20220903175753217.png" alt="image-20220903175753217"><figcaption aria-hidden="true">image-20220903175753217</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line">sfr P4 = <span class="number">0xc0</span>;			<span class="comment">// reg52.h 中没有定义 P4 寄存器故自己定义</span></span><br><span class="line">sbit P3_6 = P4^<span class="number">2</span>;	<span class="comment">// 位定义用 P3_6 在程序中替换 P4^2的功能</span></span><br><span class="line">sbit P3_7 = P4^<span class="number">4</span>;	<span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “stc15f2k60s2.h”	<span class="comment">// 该文件已定义 P4 寄存器故无需重复定义</span></span></span><br><span class="line"> </span><br><span class="line">sbit P3_6 = P4^<span class="number">2</span>;	<span class="comment">// 位定义用 P3_6 在程序中替换 P4^2 的功能</span></span><br><span class="line">sbit P3_7 = P4^<span class="number">4</span>;	<span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
<h3 id="基础编程位运算">基础编程——位运算</h3>
<h4 id="基本位运算符">基本位运算符</h4>
<p>取反、按位与、按位或、按位异或</p>
<h4 id="基本位运算">基本位运算</h4>
<h5 id="掩码">掩码</h5>
<p>讲各个位的值初始化为想要的样子，对于74HC138译码器，我们初始化为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//initial value is not sure</span></span><br><span class="line">P2 &amp;= <span class="number">0x1f</span>;</span><br><span class="line"><span class="comment">//P2 = 0001 1111</span></span><br></pre></td></tr></table></figure>
<p>通过掩码 0x1f 我们可以让 38 译码器的 ABC 三个引脚初始化为 000 。</p>
<h5 id="设置位">设置位</h5>
<p>通过或运算符可以设置各个位的值，对于 38 译码器，我们想要使之使能Y4，需要设置 ABC 为 001 ，可以使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//set P2 = 0001 1111</span></span><br><span class="line">P2 |= <span class="number">0x80</span>;</span><br><span class="line"><span class="comment">//get P2 = 1000 1111</span></span><br></pre></td></tr></table></figure>
<h5 id="关闭位">关闭位</h5>
<p>关闭 P2 的</p>
<h3 id="led">LED</h3>
<h4 id="题目要求">题目要求：</h4>
<blockquote>
<p>在CT107D单片机综合训练平台上实现LED的基本控制：</p>
<p>首先让8路LED指示灯闪烁3遍然后熄灭；</p>
<p>接着依次点亮LED指</p>
<p>示灯；</p>
<p>最后依次熄灭指示灯；</p>
<p>程序循环实现上述功能。</p>
</blockquote>
<h4 id="考点">考点：</h4>
<p>74HC138、74HC573和74HC02三个数字IC；C51开发方式——IO口扩展</p>
<h4 id="笔记">笔记：</h4>
<p>​ C51开发的两种方式：IO口扩展和存储器映射扩展</p>
<p>​ 跳线帽<span class="math inline">\(J3\)</span>：WR引脚，存储器映射扩展；接地，IO扩展</p>
<p><img src="/2022/02/25/11-07-35/image-20211030180455602.png" alt="image-20211030180455602" style="zoom: 50%;"></p>
<p>三八译码器：三个输入控制八路互斥的低有效输出——七位高一位低</p>
<p>使用方法：</p>
<ul>
<li>ABC三个输入端控制Y0-Y7八个输出端</li>
<li>输入端输入的三位二进制数的十进制形式对应Y的编号
<ul>
<li>如<span class="math inline">\(CBA=(100)_2=(4)_{10} \Rightarrow Y(4)\)</span></li>
</ul></li>
<li>片选已经完成</li>
</ul>
<p><img src="/2022/02/25/11-07-35/image-20211030180601344.png" alt="image-20211030180601344" style="zoom:50%;"></p>
<p>锁存器：八路三态输出的非反转透明锁存器</p>
<p>使用方法：</p>
<ul>
<li>控制引脚：LE，低电平锁存，高电平导通</li>
<li>导通时D和Q的电平一致</li>
<li>片选已经完成</li>
</ul>
<p><img src="/2022/02/25/11-07-35/image-20211030180521683.png" alt="image-20211030180521683" style="zoom:50%;"></p>
<p>使用方法：</p>
<ul>
<li><p>使用IO扩展，跳线帽设置为为GND</p></li>
<li><p><span class="math inline">\((WR-&gt;GND)J13\)</span></p>
<p><span class="math inline">\(74HC138(Y4)-&gt;(Y4)74HC02(Y4C)-&gt;(LE)M74HC573MIR\)</span></p>
<p><span class="math inline">\(\sf{使用}:WR=0;\,Y4=0\,\sf{ 时},\, Y4C=1\)</span></p></li>
</ul>
<p>左移运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> P0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	P0 = (<span class="number">0xff</span> &lt;&lt;i);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; P0 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：510 1020 2040 4080 8160 16320 32640 65280</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay100ms</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">180</span>;</span><br><span class="line">	j = <span class="number">73</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码：</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit HC138_A = P2^<span class="number">5</span>;</span><br><span class="line">sbit HC138_B = P2^<span class="number">6</span>;</span><br><span class="line">sbit HC138_C = P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(time--);</span><br><span class="line">    <span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LEDrunning</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="comment">//通过配置三八译码器使得锁存器导通，此时单片机P0口电压直接对应LED灯的电压</span></span><br><span class="line">    HC138_C = <span class="number">1</span>;</span><br><span class="line">    HC138_B = <span class="number">0</span>;</span><br><span class="line">    HC138_A = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将P0口全部设为低电平，点亮所有LED灯</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P0 = <span class="number">0x00</span>;</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        P0 = <span class="number">0xff</span>;</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P0 = <span class="number">0xff</span>&lt;&lt;i;</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P0 = ~(<span class="number">0xff</span>&lt;&lt;i);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">        Delay(<span class="number">60000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mian</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LEDrunning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="蜂鸣器和继电器">蜂鸣器和继电器</h3>
<h4 id="题目要求-1">题目要求：</h4>
<blockquote>
<p>在CT107D单片机综合训练平台上实现蜂鸣器与继电器的基本控制：</p>
<p>首先让8路LED指示灯闪烁3遍后熄灭；</p>
<p>接着依次点亮LED指示灯；</p>
<p>继电器吸合一会后断开；</p>
<p>然后依次熄灭LED指示灯；</p>
<p>蜂鸣器鸣叫会后关闭；</p>
<p>程序循环实现上述功能。</p>
</blockquote>
<h4 id="考点-1">考点：</h4>
<p>蜂鸣器和继电器的使用；继续使用上面的三个IC；ULN2003达林顿管——一个驱动管</p>
<h4 id="笔记-1">笔记：</h4>
<p>针脚选择BTN</p>
<h4 id="代码-1">代码：</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectHC138</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> n)</span></span><br><span class="line">&#123;<span class="comment">//通过三八译码器选择正确的锁存器；输入端口，配置相应锁存器</span></span><br><span class="line">    <span class="keyword">switch</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">0</span>;</span><br><span class="line">            HC138_A=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">0</span>;</span><br><span class="line">            HC138_A=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">1</span>;</span><br><span class="line">            HC138_A=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">1</span>;</span><br><span class="line">            HC138_A=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="comment">//switch</span></span><br><span class="line">&#125;<span class="comment">//void</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/02/25/11-07-35/image-20211030203349176.png" alt="image-20211030203349176" style="zoom:50%;"></p>
<h3 id="独立按键">独立按键</h3>
<h4 id="题目要求-2">题目要求：</h4>
<blockquote>

</blockquote>
<h4 id="考点-2">考点：</h4>
<ul>
<li>独立按键；矩阵键盘</li>
<li>读取IO口电平</li>
<li>按键消抖</li>
</ul>
<h4 id="笔记-2">笔记：</h4>
<p>根据原理图可知：</p>
<p><img src="/2022/02/25/11-07-35/image-20211030204322671.png" alt="image-20211030204322671" style="zoom: 67%;"></p>
<p><span class="math inline">\(J5\)</span>接2、3引脚，此时<span class="math inline">\(P30-P33\)</span>四个单片机IO口分别接<span class="math inline">\(S7-S4\)</span>四个独立按键再接<span class="math inline">\(GND\)</span></p>
<h4 id="代码-2">代码：</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DelayKey</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ScanKeys_Alone</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s7 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s7 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s7 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s6 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s6 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s6 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L2 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s5 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s5 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L3 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s5 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L3 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s4 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s4 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L4 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s4 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L4 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit s7 = P3^<span class="number">0</span>;</span><br><span class="line">sbit s6 = P3^<span class="number">1</span>;</span><br><span class="line">sbit s5 = P3^<span class="number">2</span>;</span><br><span class="line">sbit s4 = P3^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">sbit L1 = P0^<span class="number">0</span>;</span><br><span class="line">sbit L2 = P0^<span class="number">1</span>;</span><br><span class="line">sbit L3 = P0^<span class="number">2</span>;</span><br><span class="line">sbit L4 = P0^<span class="number">3</span>;</span><br><span class="line">sbit L5 = P0^<span class="number">4</span>;</span><br><span class="line">sbit L6 = P0^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectHC138</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> n)</span></span><br><span class="line">&#123;<span class="comment">//通过三八译码器选择正确的锁存器；输入端口，配置相应锁存器</span></span><br><span class="line">    <span class="keyword">switch</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">0</span>;</span><br><span class="line">            HC138_A=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">0</span>;</span><br><span class="line">            HC138_A=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">1</span>;</span><br><span class="line">            HC138_A=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            HC138_C=<span class="number">1</span>;</span><br><span class="line">            HC138_B=<span class="number">1</span>;</span><br><span class="line">            HC138_A=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="comment">//switch</span></span><br><span class="line">&#125;<span class="comment">//void</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DelayKey</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ScanKeys_Alone</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s7 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s7 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s7 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s6 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s6 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s6 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L2 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s5 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s5 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L3 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s5 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L3 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    <span class="keyword">if</span>(s4 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DelayKey(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(s4 == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L4 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s4 == <span class="number">0</span>);<span class="comment">//我不理解？？？？？</span></span><br><span class="line">            L4 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//if外层</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SelecHC138(<span class="number">4</span>);<span class="comment">//控制锁存器打开LED灯</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ScanKeys_Alone();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数码管">数码管</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code SegTab[]=&#123;<span class="number">0xc0</span>,<span class="number">0xf9</span>,<span class="number">0xa4</span>,<span class="number">0xb0</span>,<span class="number">0x99</span>,</span><br><span class="line">                             <span class="number">0x92</span>,<span class="number">0x82</span>,<span class="number">0xf8</span>,<span class="number">0x80</span>,<span class="number">0x90</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code SegBuf[]=&#123;<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>,<span class="number">0xff</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>数码管延时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_dtms</span><span class="params">(uchar t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">10</span>;</span><br><span class="line">	j = <span class="number">73</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;<span class="comment">//t=1时刷新频率可以到100Hz，即0.01ms</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_tms</span><span class="params">(uchar t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">180</span>;</span><br><span class="line">	j = <span class="number">73</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;<span class="comment">//t=1时延时大约1ms</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*===============初始化定时器0==================*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_Timer0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        TMOD = <span class="number">0x01</span>;                    <span class="comment">//16位定时模式</span></span><br><span class="line">        TH0 = (<span class="number">65536</span> - <span class="number">50000</span>) / <span class="number">256</span>;      <span class="comment">//定时50ms</span></span><br><span class="line">        TL0 = (<span class="number">65536</span> - <span class="number">50000</span>) % <span class="number">256</span>;</span><br><span class="line">        ET0 = <span class="number">1</span>;                       <span class="comment">//使能定时器T0中断</span></span><br><span class="line">        EA = <span class="number">1</span>;                       <span class="comment">//使能总中断        </span></span><br><span class="line">        TR0 = <span class="number">1</span>;                       <span class="comment">//启动定时器T0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*============定时器0中断服务函数===============*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SeviceTimer0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i=<span class="number">1</span>;</span><br><span class="line">    TH0 = (<span class="number">65536</span> - <span class="number">50000</span>) / <span class="number">256</span>;</span><br><span class="line">    TL0 = (<span class="number">65536</span> - <span class="number">50000</span>) % <span class="number">256</span>;</span><br><span class="line">    P0=<span class="number">0xff</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">40</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        EGplay(i);</span><br><span class="line">    	i++;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时器计算">定时器计算</h3>
<p><span class="math display">\[
10ms=0.01s\\
\sf{计算机器周期数目：}\\x\frac{12}{11059200}=0.01\\
get\:x=9216=0x2400\\
so\:TH0=0x24,TL0=0x00;
\]</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_0_ini</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	TMOD = <span class="number">0x01</span>;</span><br><span class="line">	TH0 = <span class="number">0xfc</span>;</span><br><span class="line">	TL0 = <span class="number">0x67</span>;</span><br><span class="line">	TR0=<span class="number">1</span>;</span><br><span class="line">	TF0=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">timer_0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span><span class="comment">//@ t (ms)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> timer_0_tag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(TF0==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TF0=<span class="number">0</span>;</span><br><span class="line">        TH0 = <span class="number">0xfc</span>;</span><br><span class="line">		TL0 = <span class="number">0x67</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=t)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt=<span class="number">0</span>;</span><br><span class="line">            timer_0_tag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> timer_0_tag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> timer_0_tag;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通信">通信</h3>
<p><img src="/2022/02/25/11-07-35/image-20211116001027941.png" alt="image-20211116001027941"></p>
]]></content>
      <tags>
        <tag>电子设计</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑设计基础</title>
    <url>/2022/03/09/16-14-26/</url>
    <content><![CDATA[<h1 id="logic-design">Logic Design</h1>
<h3 id="数制">数制</h3>
<p>数制是用一组固定符号和统一规则来表示数值的方法，通常包含基数和位权两个基本要素。其中<strong>基数</strong>是指使用数码的个数，例如：二进制的基数为<code>2</code>，十进制的基数为<code>10</code>。<strong>位权</strong>是指数制某位所表示的数值权重的大小，例如：十进制数<code>123</code>，<code>1</code>的位权是<code>100</code>，<code>2</code>的位权是<code>10</code>，<code>3</code>的位权是<code>1</code>。二进制数<code>1011</code>，从左至右<code>1</code>、<code>0</code>、<code>1</code>、<code>1</code>的位权依次是<code>8</code>、<code>4</code>、<code>2</code>、<code>1</code>。常用的数制有<strong>二</strong>、<strong>八</strong>、<strong>十</strong>、<strong>十六</strong>四种进制，书写时可以在相应数值尾部添加字母<strong>B</strong>、<strong>O</strong>、<strong>D</strong>、<strong>H</strong>或者下标<strong>2</strong>、<strong>8</strong>、<strong>10</strong>、<strong>16</strong>进行标识，计算机<strong>传输和保存数据</strong>通常使用的是<strong>二进制</strong>。</p>
<h3 id="码制">码制</h3>
<p>码制是计算机存储、传输数据所使用的编码规则；其中原码、反码、补码是计算机设备保存数值类型数据的编码方式，ASCII 与 Unicode 属于保存字符类型数据的编码格式；而 BCD 编码、格雷码则主要用于设备之间的数据<strong>传输以及转换</strong>。</p>
<blockquote>
<p>BCD 码的优点在于格式转换容易，十进制数值表达精度较高；缺点是增加了电路进行算术运算的复杂度，并且存储效率较低。</p>
</blockquote>
<h3 id="数字系统">数字系统</h3>
<p>数字系统设计大致分为三个方面</p>
<ul>
<li>系统设计
<ul>
<li>系统设计是将一个数字系统划分为多个子系统进行设计。</li>
</ul></li>
<li>逻辑设计
<ul>
<li>逻辑设计是将多个逻辑功能块互联实现特定功能</li>
</ul></li>
<li>电路设计</li>
</ul>
<p>数字系统的中许多子系统以开关电路的形式存在，开关电路具有一个或多个输入端，一个或多个输出端，输入输出端都取离散值的电路。开关电路一般使用门电路来描述，使用布尔代数进行分析。开关电路有两种——组合电路和时序电路。</p>
<p>开关电路分类：</p>
<ul>
<li>组合电路
<ul>
<li>组合电路中输出值仅与当前输入值有关</li>
<li>组合电路的基本构成是逻辑门，逻辑设计就是将逻辑门相互连接起来以便将电路的输入信号转化为预期的输出信号。</li>
</ul></li>
<li>时序电路
<ul>
<li>时序电路中输出值不仅与当前输入值有关，也与之前的输入值有关；可以认为时序电路具有记忆功能</li>
<li>时序电路的基本存储元件（存储之前的值）是触发器，触发器与逻辑门一起组成时序电路——如计数器和寄存器。</li>
</ul></li>
</ul>
<h3 id="布尔代数">布尔代数</h3>
<p>逻辑设计课程中我们使用二值布尔代数来设计开关电路。我们使用布尔变量来表示电路的输入和输出，其中布尔变量代表逻辑电路中的两种不同状态——</p>
<p>普通代数中的<strong>交换律</strong>和<strong>结合律</strong>同样可以在布尔代数中使用。</p>
<p>布尔代数中的交换律表明开关的位置（出现次序）不会影响最终结果，结合律表明开关导通的次序不会影响最终结果。</p>
<p>在布尔代数中，分配律有两种形式：</p>
<ul>
<li><p>一种是普通的分配律：<span class="math inline">\(X(Y+Z)=XY+XZ\)</span></p>
<p>​ 与运算可以分配在或运算上</p>
<p>​ 去和括号内相乘</p></li>
<li><p>另一种被称作第二分配律：<span class="math inline">\(X+(YZ)=(X+Y)(X+Z)\)</span></p>
<p>​ 或运算可以分配在与运算上</p>
<p>​ 去和括号内相加</p></li>
</ul>
<p>很多布尔代数表达式可以使用一个更简单的表达式替换，每个布尔代数表达式</p>
<h2 id="数字电路概念">数字电路概念</h2>
<h3 id="高阻态">高阻态</h3>
<p>高阻抗状态（<em>High impedance</em>）表示电路中的某个节点具有相对电路中其它点更高的阻抗，电路分析时通常将高阻态作为开路理解。即可以将其视为输出/输入电阻极大，极限状态可以认为是悬空（<em>断路</em>）的状态，高阻态通常使用字母<strong>Z</strong>表示。</p>
<h3 id="三态门">三态门</h3>
<p>数字电路中的三态逻辑（<em>Three-state logic</em>）是指其输出既可以是代表<code>0</code>和<code>1</code>的高低电平，也可以是其特有的高阻抗状态（<em>相当于隔断状态，电阻极大，类似于开路</em>）。</p>
<p>具有高电平、低电平、高阻态三种状态的元器件称为三态器件，三态器件都通过一个控制使能端 B 来控制整个三态门电路的通断。当使能端高电平有效时，三态器件可以正常的<code>0</code>或<code>1</code>输出，当使能端低电平无效时，三态电路将会输出高阻态。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">输入端 A</th>
<th style="text-align: left;">使能端 B</th>
<th style="text-align: left;">输出端 C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>0</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>1</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>X</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>Z</code></td>
</tr>
</tbody>
</table>
<h3 id="组合时序逻辑电路">组合/时序逻辑电路</h3>
<ul>
<li><strong>组合逻辑电路</strong>（<em>Combinational Logic Circuit</em>），其任一时刻的稳态输出仅与该时刻输入的变量取值有关，而与该时刻之前输入的变量取值无关。组合电路主要由各种逻辑门（<code>半加器</code>、<code>全加器</code>、<code>半减器</code>、<code>全减器</code>、<code>数据选择器</code>、<code>数据分配器</code>、<code>编码器</code>、<code>译码器</code>）组成，电路中没有记忆元件和反馈线。</li>
<li><strong>时序逻辑电路</strong>（<em>Sequential Logic Circuit</em>）任意时刻的稳态输出不仅取决于当前输入，还与前一时刻输入的状态有关，换而言之，时序逻辑电路必须拥有特定的储存元件来保存前一次的输入状态。因此，时序逻辑电路除包含有组合逻辑电路以外，还必须含拥有存储信息能力的电路（<code>触发器</code>、<code>寄存器</code>、<code>计数器</code>）。</li>
</ul>
<h3 id="gpio">GPIO</h3>
<p><strong>通用输入输出</strong>（<em>General-purpose input/output</em>），功能类似于 8051 单片机的 P0 到 P3 口，引脚输出的高低电平可由开发人员读写相应寄存器进行控制。该接口有时也称为<strong>总线扩展器</strong>，当开发板接口不够用时，可以通过转接板将其扩展为<code>I²C</code>、<code>SPI</code>等其它串行接口。</p>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCv笔记</title>
    <url>/2022/03/30/11-27-50/</url>
    <content><![CDATA[<h1 id="opencv-in-python">OpenCV In Python</h1>
<p>为什么学习 OpenCV？</p>
<p>电子设计中使用OpenCV进行图像处理的仿真</p>
<p>使用工具：</p>
<p>python</p>
<p>安装OpenCV：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure>
<h2 id="例程展示">例程展示</h2>
<p><a href="https://docs.opencv.org/4.x/d6/d00/tutorial_py_root.html">官网链接</a></p>
<h3 id="getting-started-with-images">Getting Started with Images</h3>
<p>图片入门——读取和显示图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#作为第一步，导入OpenCV python库。正确的方法是给它附加赋一个名称cv，下面将使用它来引用这个库。</span></span><br><span class="line"><span class="comment">#（不知道为什么要加别称，但是实践是不加别称也可以使用）</span></span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#调用cv::imread()来读入图片（在官网的示例中使用了绝对路径，在我实践中我的电脑上需要使用绝对路径，具体原因不清楚。）</span></span><br><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>))</span><br><span class="line"><span class="comment">#如果图像打开失败，退出并显示“不能读取图片。”</span></span><br><span class="line"><span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    sys.exit(<span class="string">&quot;不能读取图片。&quot;</span>)</span><br><span class="line"><span class="comment">#使用cv::imshow()显示图片，cv::waitkey()用于维持图片显示：cv::waitKey函数唯一的参数是等待用户输入的时间(以毫秒为单位)。零意味着永远等待。返回值是被按下的键。</span></span><br><span class="line">cv.imshow(<span class="string">&quot;显示窗口&quot;</span>, img)</span><br><span class="line">k = cv.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#如果按下的键是“s”键，图像将被写入一个文件。为此，cv::imwrite()函数被调用，该函数具有文件路径和cv::Mat对象作为参数。</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&quot;s&quot;</span>):</span><br><span class="line">    cv.imwrite(<span class="string">&quot;另存为图片名&quot;</span>, img)</span><br><span class="line">    k = cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>读取图像函数：cv::imread</p>
<p>第一个参数指定的文件路径来加载图像。第二个参数是可选的，它指定图像的格式:</p>
<ul>
<li><p>IMREAD_COLOR 以BGR 8位格式加载图像。这是这里使用的<strong>默认</strong>。</p></li>
<li><p>IMREAD_UNCHANGED 按原样加载图像(包括alpha通道)。</p></li>
<li><p>IMREAD_GRAYSCALE 以灰度值加载图像。</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#具体写法</span></span><br><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>),cv.IMREAD_GRAYSCALE)</span><br></pre></td></tr></table></figure>
<p>备注：</p>
<ul>
<li><p>对于彩色图像，解码后的图像将以B G R顺序存储通道。</p></li>
<li><p>当使用IMREAD_GRAYSCALE时，如果可用，将使用编解码器的内部灰度转换。结果可能与cvtColor()的输出不同</p></li>
</ul></li>
</ol>
<h2 id="capture-video-from-camera">Capture Video from Camera</h2>
<p>视频入门——调用电脑摄像头并获取视频</p>
<p>有时我们需要用摄像头捕获实时流，OpenCV提供了一个非常简单的接口来做到这一点。本次任务使用电脑内置的摄像头捕获视频并且显示。</p>
<p>要捕获视频，您需要创建一个<strong>VideoCapture</strong>对象。它的参数可以是设备索引或视频文件的名称。设备索引只是指定哪个摄像机的数字。通常会连接一个摄像头。所以我只是传递0（或 -1）。你可以通过传递1来选择第二个摄像机，以此类推。之后，您可以逐帧捕捉。但在最后，不要忘记释放<strong>Capture</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cannot open camera&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Capture frame-by-frame</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Our operations on the frame come here</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Display the resulting frame</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># When everything done, release the capture</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">cap = cv.VideoCapture(<span class="string">r&#x27;C:\Users\qjy\Desktop\a.mp4&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="basic-operations-on-images">Basic Operations on Images</h3>
<h1 id="opencv-python教程">OpenCV-Python教程</h1>
<h2 id="opencv中的图像处理">OpenCV中的图像处理</h2>
<h3 id="色彩空间转换">色彩空间转换</h3>
<h4 id="目标">目标</h4>
<ul>
<li><p>在本教程中，您将学习如何将图像从一个颜色空间转换到另一个颜色空间，如 <span class="math inline">\(BGR↔Gray\)</span>，<span class="math inline">\(BGR↔HSV\)</span> 等。</p></li>
<li><p>除此之外，我们将创建一个应用程序来提取视频中的彩色对象</p></li>
<li><p>你将学习以下函数： <strong><a href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab"><code>cv.cvtColor()</code></a></strong>， <strong><a href="https://docs.opencv.org/4.x/d2/de8/group__core__array.html#ga48af0ab51e36436c5d04340e036ce981"><code>cv.inRange()</code></a></strong> 等。</p></li>
</ul>
<h4 id="改变颜色空间">改变颜色空间</h4>
<p><span class="math inline">\(OpenCV\)</span> 中有超过150种颜色空间转换方法。但我们只看两种使用最广泛的一种： <span class="math inline">\(BGR↔Gray\)</span> 和 <span class="math inline">\(BGR↔HSV\)</span> 。</p>
<p>对于颜色转换，我们使用函数 <code>cv.cvtColor(input_image, flag)</code>，其中 <span class="math inline">\(flag\)</span> 决定转换的类型。</p>
<p>对于 <span class="math inline">\(BGR→Gray\)</span> 转换，我们使用标志<a href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea"><code>cv.COLOR_BGR2GRAY</code></a>。类似地，对于 <span class="math inline">\(BGR→HSV\)</span>，我们使用标志<a href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0aa4a7f0ecf2e94150699e48c79139ee12"><code>cv.COLOR_BGR2HSV</code></a>。要获取其他标志，只需在 <span class="math inline">\(Python\)</span> 终端中运行以下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flags = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv) <span class="keyword">if</span> i.startswith(<span class="string">&#x27;COLOR_&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( flags )</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>对于HSV，色相范围为[0,179]，饱和度范围为[0,255]，取值范围为[0,255]。不同的软件使用不同的尺度。所以如果你在比较 <span class="math inline">\(OpenCV\)</span> 值和它们，你需要标准化这些范围。</p>
</blockquote>
<h4 id="跟踪对象">跟踪对象</h4>
<p>现在我们知道了如何将 <span class="math inline">\(BGR\)</span> 图像转换为 <span class="math inline">\(HSV\)</span>，我们可以使用它来提取有颜色的对象。在 $ HSV$ 中，比在 <span class="math inline">\(BGR\)</span> 颜色空间中更容易表示颜色。在我们的应用程序中，我们将尝试提取一个蓝色的对象。方法如下：</p>
<ul>
<li><p>取视频的每一帧。</p></li>
<li><p>从 <span class="math inline">\(BGR\)</span> 转换到 <span class="math inline">\(HSV\)</span> 颜色空间。</p></li>
<li><p>我们阈值的 <span class="math inline">\(HSV\)</span> 图像范围的蓝色。</p></li>
<li><p>现在单独提取蓝色物体，我们可以对图像做任何我们想做的事情。</p></li>
</ul>
<p>下面是详细注释的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># Take each frame</span></span><br><span class="line">    _, frame = cap.read()</span><br><span class="line">    <span class="comment"># Convert BGR to HSV</span></span><br><span class="line">    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)</span><br><span class="line">    <span class="comment"># define range of blue color in HSV</span></span><br><span class="line">    lower_blue = np.array([<span class="number">110</span>,<span class="number">50</span>,<span class="number">50</span>])</span><br><span class="line">    upper_blue = np.array([<span class="number">130</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">    <span class="comment"># Threshold the HSV image to get only blue colors</span></span><br><span class="line">    mask = cv.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line">    <span class="comment"># Bitwise-AND mask and original image</span></span><br><span class="line">    res = cv.bitwise_and(frame,frame, mask= mask)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>,frame)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;mask&#x27;</span>,mask)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;res&#x27;</span>,res)</span><br><span class="line">    k = cv.waitKey(<span class="number">5</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>下图显示了对蓝色物体的跟踪：</p>
<p><img src="/2022/03/30/11-27-50/frame.jpg"></p>
<blockquote>
<p>Note</p>
<p>图像中有一些噪声。我们将在后面的章节中看到如何删除它。</p>
<p>这是目标跟踪中最简单的方法。一旦你学会了轮廓函数，你就可以做很多事情，比如找到物体的质心并使用它来跟踪物体，通过在摄像机前移动你的手来绘制图表，以及其他有趣的事情。</p>
</blockquote>
<h4 id="如何找到hsv值跟踪">如何找到HSV值跟踪？</h4>
<p>这是在 <a href="https://www.stackoverflow.com/">stackoverflow.com</a> 中发现的一个常见问题。它非常简单，你可以使用相同的函数<a href="https://docs.opencv.org/4.x/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab"><code>cv.cvtColor()</code></a>。你只需传递你想要的 <span class="math inline">\(BGR\)</span> 值，而不是传递一个图像。例如，要找到绿色的 <span class="math inline">\(HSV\)</span> 值，请在 $ Python$ 终端中尝试以下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>green = np.uint8([[[<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span> ]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsv_green = cv.cvtColor(green,cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( hsv_green )</span><br><span class="line">[[[ <span class="number">60</span> <span class="number">255</span> <span class="number">255</span>]]]</span><br></pre></td></tr></table></figure>
<p>现在分别取 <span class="math inline">\([H-10, 100,100]\)</span> 和 <span class="math inline">\([H+10, 255,255]\)</span> 为下界和上界。除了这种方法之外，您还可以使用任何图像编辑工具（如 <span class="math inline">\(GIMP\)</span>）或任何在线转换器来查找这些值，但不要忘记调整 <span class="math inline">\(HSV\)</span> 范围。</p>
<h4 id="附加资源">附加资源</h4>
<p>练习：</p>
<p>试着找出一种方法来提取不止一种颜色的对象，例如，同时提取红色、蓝色和绿色的对象。</p>
<h3 id="图像的几何变换">图像的几何变换</h3>
<h3 id="图像阈值化">图像阈值化</h3>
<h4 id="目标-1">目标</h4>
<ul>
<li>在本教程中，您将学习简单的阈值，自适应阈值和 <span class="math inline">\(Otsu\)</span> 的阈值。</li>
<li>你们将学习函数 <strong><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold</code></a></strong> 和 <strong><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3"><code>cv.adaptiveThreshold</code></a></strong>。</li>
</ul>
<h4 id="简单的阈值">简单的阈值</h4>
<p>在这里，事情很简单。对于每个像素，应用相同的阈值。如果像素值小于阈值，则设置为 <span class="math inline">\(0\)</span>，否则设置为最大值。函数的简历。<span class="math inline">\(Threshold\)</span> 用于应用阈值。第一个参数是源图像，它应该是一个灰度图像。第二个参数是用于对像素值进行分类的阈值。第三个参数是分配给超过阈值的像素值的最大值。<span class="math inline">\(OpenCV\)</span> 提供了由第四个参数给出的不同类型的阈值</p>
<ul>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a147222a96556ebc1d948b372bcd7ac59"><code>cv.THRESH_BINARY</code></a></li>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a19120b1a11d8067576cc24f4d2f03754"><code>cv.THRESH_BINARY_INV</code></a></li>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576ac7e89a5e95490116e7d2082b3096b2b8"><code>cv.THRESH_TRUNC</code></a></li>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a0e50a338a4b711a8c48f06a6b105dd98"><code>cv.THRESH_TOZERO</code></a></li>
<li><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a47518a30aae90d799035bdcf0bb39a50"><code>cv.THRESH_TOZERO_INV</code></a></li>
</ul>
<p>请参阅这些类型的文档以了解其区别。</p>
<p>该方法返回两个输出。第一个是所使用的阈值，第二个输出是阈值图像。</p>
<p>这段代码比较了不同的简单阈值类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;gradient.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">ret,thresh1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">ret,thresh2 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TRUNC)</span><br><span class="line">ret,thresh4 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO)</span><br><span class="line">ret,thresh5 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_TOZERO_INV)</span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>,<span class="string">&#x27;BINARY&#x27;</span>,<span class="string">&#x27;BINARY_INV&#x27;</span>,<span class="string">&#x27;TRUNC&#x27;</span>,<span class="string">&#x27;TOZERO&#x27;</span>,<span class="string">&#x27;TOZERO_INV&#x27;</span>]</span><br><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>,vmin=<span class="number">0</span>,vmax=<span class="number">255</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>为了绘制多幅图像，我们使用了 <code>plt.subplot()</code> 函数。详情请查看 <span class="math inline">\(matplotlib\)</span> 文档。</p>
</blockquote>
<p>代码产生如下结果：</p>
<p><img src="/2022/03/30/11-27-50/threshold.jpg"></p>
<h4 id="自适应阈值">自适应阈值</h4>
<p>在前一节中，我们使用一个全局值作为阈值。但这并不是在所有情况下都是好的，例如，如果一个图像在不同的区域有不同的光照条件。在这种情况下，自适应阈值可以有所帮助。在这里，算法根据像素周围的小区域确定阈值。因此，我们对同一幅图像的不同区域采用不同的阈值，对不同光照条件下的图像有较好的处理效果。</p>
<p>除上述参数外，方法 <a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3"><code>cv.adaptiveThreshold</code></a> 接受三个输入参数：</p>
<p><code>adaptivmethod</code>决定如何计算阈值:</p>
<p><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa42a3e6ef26247da787bf34030ed772cad0c5199ae8637a6b195062fea4789fa9"><code>cv.ADAPTIVE_THRESH_MEAN_C</code></a>：阈值是邻近区域的平均值减去常数C。</p>
<p><a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa42a3e6ef26247da787bf34030ed772caf262a01e7a3f112bbab4e8d8e28182dd"><code>cv.ADAPTIVE_THRESH_GAUSSIAN_C</code></a>：阈值是邻域值减去常数C的高斯加权和。</p>
<p><code>blockSize</code> 决定了邻域区域的大小，<span class="math inline">\(C\)</span> 是一个常数，从邻域像素的平均值或加权和中减去。</p>
<p>下面的代码比较了全局阈值和自适应阈值对不同光照的图像的影响：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\11.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">img = cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line">ret,th1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line">th2 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_MEAN_C,cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">th3 = cv.adaptiveThreshold(img,<span class="number">255</span>,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">titles = [<span class="string">&#x27;Original Image&#x27;</span>, <span class="string">&#x27;Global Thresholding (v = 127)&#x27;</span>,<span class="string">&#x27;Adaptive Mean Thresholding&#x27;</span>, <span class="string">&#x27;Adaptive Gaussian Thresholding&#x27;</span>]</span><br><span class="line">images = [img, th1, th2, th3]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/ada_threshold.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">img = cv.imread(r&#x27;C:\Users\qjy\Desktop\65ce8a75cfc0dc33feddd6d4632ab1a.jpg&#x27;,0)</span><br><span class="line">kernel = np.ones((2,1),np.uint8)</span><br><span class="line">closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span><br><span class="line">#erosion = cv.erode(img,kernel,iterations = 1)</span><br><span class="line">cv.imshow(&#x27;res&#x27;,closing)</span><br><span class="line">k = cv.waitKey(0)</span><br></pre></td></tr></table></figure>
<h4 id="otsu-二值法">Otsu 二值法</h4>
<p>在全局阈值中，我们使用任意选择的值作为阈值。相比之下，<span class="math inline">\(Otsu\)</span> 的方法避免了必须选择一个值，并自动确定它。</p>
<p>考虑一个只有两个不同图像值的图像(双峰图像)，其中直方图只包含两个峰。一个合适的阈值应该在这两个值之间。类似地，<span class="math inline">\(Otsu\)</span> 的方法从图像直方图中确定一个最优的全局阈值。</p>
<p>为此，我们使用了 <a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold()</code></a> 函数，其中 <a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57"><code>cv.threshold()</code></a> 是 <a href="https://docs.opencv.org/4.x/d7/d1b/group__imgproc__misc.html#ggaa9e58d2860d4afa658ef70a9b1115576a95251923e8e22f368ffa86ba8bce87ff"><code>cv.THRESH_OTSU</code></a> 被作为一个额外的标志传递。阈值可以任意选择。</p>
<p>看看下面的例子。输入图像是一个有噪声的图像。在第一种情况下，应用值为 <span class="math inline">\(127\)</span> 的全局阈值。在第二种情况下，直接应用 <span class="math inline">\(Otsu\)</span> 的阈值。在第三种情况下，首先用 <span class="math inline">\(5x5\)</span> 高斯核滤波去除噪声，然后应用 <span class="math inline">\(Otsu\)</span> 阈值。看看噪声滤波是如何改善结果的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;noisy2.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># global thresholding</span></span><br><span class="line">ret1,th1 = cv.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv.THRESH_BINARY)</span><br><span class="line"><span class="comment"># Otsu&#x27;s thresholding</span></span><br><span class="line">ret2,th2 = cv.threshold(img,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="comment"># Otsu&#x27;s thresholding after Gaussian filtering</span></span><br><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line">ret3,th3 = cv.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="comment"># plot all the images and their histograms</span></span><br><span class="line">images = [img, <span class="number">0</span>, th1,</span><br><span class="line">          img, <span class="number">0</span>, th2,</span><br><span class="line">          blur, <span class="number">0</span>, th3]</span><br><span class="line">titles = [<span class="string">&#x27;Original Noisy Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&#x27;Global Thresholding (v=127)&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Original Noisy Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>,</span><br><span class="line">          <span class="string">&#x27;Gaussian filtered Image&#x27;</span>,<span class="string">&#x27;Histogram&#x27;</span>,<span class="string">&quot;Otsu&#x27;s Thresholding&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">1</span>),plt.imshow(images[i*<span class="number">3</span>],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">2</span>),plt.hist(images[i*<span class="number">3</span>].ravel(),<span class="number">256</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">1</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">3</span>),plt.imshow(images[i*<span class="number">3</span>+<span class="number">2</span>],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i*<span class="number">3</span>+<span class="number">2</span>]), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/otsu.jpg"></p>
<h3 id="otsu-二值化是如何工作的">Otsu 二值化是如何工作的？</h3>
<p>本节演示了 <span class="math inline">\(Otsu\)</span> 二值化的 <span class="math inline">\(Python\)</span> 实现，以展示它实际上是如何工作的。如果你不感兴趣，你可以跳过这个。</p>
<p>由于我们使用的是双峰图像，<span class="math inline">\(Otsu\)</span> 的算法试图找到一个阈值<span class="math inline">\((t)\)</span>，使由关系给出的<strong>weighted within-class variance</strong>最小化： <span class="math display">\[
\sigma_w^2(t) = q_1(t)\sigma_1^2(t)+q_2(t)\sigma_2^2(t)
\]</span> 其中： <span class="math display">\[
\begin{gather*}
\mu_1(t) = \sum_{i=1}^{t} \frac{iP(i)}{q_1(t)} \quad \&amp; \quad \mu_2(t) = \sum_{i=t+1}^{I} \frac{iP(i)}{q_2(t)}\\
\mu_1(t) = \sum_{i=1}^{t} \frac{iP(i)}{q_1(t)} \quad \&amp; \quad \mu_2(t) = \sum_{i=t+1}^{I} \frac{iP(i)}{q_2(t)}\\
\sigma_1^2(t) = \sum_{i=1}^{t} [i-\mu_1(t)]^2 \frac{P(i)}{q_1(t)} \quad \&amp; \quad \sigma_2^2(t) = \sum_{i=t+1}^{I} [i-\mu_2(t)]^2 \frac{P(i)}{q_2(t)}
\end{gather*}
\]</span> 它实际上找到了一个 <span class="math inline">\(t\)</span> 的值，它位于两个峰值之间，使得这两个类的方差都是最小的。它可以简单地在 <span class="math inline">\(Python\)</span> 中实现如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&#x27;noisy2.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br><span class="line"><span class="comment"># find normalized_histogram, and its cumulative distribution function</span></span><br><span class="line">hist = cv.calcHist([blur],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">hist_norm = hist.ravel()/hist.<span class="built_in">sum</span>()</span><br><span class="line">Q = hist_norm.cumsum()</span><br><span class="line">bins = np.arange(<span class="number">256</span>)</span><br><span class="line">fn_min = np.inf</span><br><span class="line">thresh = -<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">    p1,p2 = np.hsplit(hist_norm,[i]) <span class="comment"># probabilities</span></span><br><span class="line">    q1,q2 = Q[i],Q[<span class="number">255</span>]-Q[i] <span class="comment"># cum sum of classes</span></span><br><span class="line">    <span class="keyword">if</span> q1 &lt; <span class="number">1.e-6</span> <span class="keyword">or</span> q2 &lt; <span class="number">1.e-6</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    b1,b2 = np.hsplit(bins,[i]) <span class="comment"># weights</span></span><br><span class="line">    <span class="comment"># finding means and variances</span></span><br><span class="line">    m1,m2 = np.<span class="built_in">sum</span>(p1*b1)/q1, np.<span class="built_in">sum</span>(p2*b2)/q2</span><br><span class="line">    v1,v2 = np.<span class="built_in">sum</span>(((b1-m1)**<span class="number">2</span>)*p1)/q1,np.<span class="built_in">sum</span>(((b2-m2)**<span class="number">2</span>)*p2)/q2</span><br><span class="line">    <span class="comment"># calculates the minimization function</span></span><br><span class="line">    fn = v1*q1 + v2*q2</span><br><span class="line">    <span class="keyword">if</span> fn &lt; fn_min:</span><br><span class="line">        fn_min = fn</span><br><span class="line">        thresh = i</span><br><span class="line"><span class="comment"># find otsu&#x27;s threshold value with OpenCV function</span></span><br><span class="line">ret, otsu = cv.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv.THRESH_BINARY+cv.THRESH_OTSU)</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(thresh,ret) )</span><br></pre></td></tr></table></figure>
<h4 id="附加资源-1">附加资源</h4>
<ol type="1">
<li>Digital Image Processing, Rafael C. Gonzalez</li>
</ol>
<h4 id="exercises">Exercises</h4>
<ol type="1">
<li>There are some optimizations available for Otsu's binarization. You can search and implement it.</li>
</ol>
<h3 id="平滑图像">平滑图像</h3>
<h4 id="目标-2">目标</h4>
<p>学习：</p>
<ul>
<li><p>用各种低通滤波器模糊图像</p></li>
<li><p>为图像应用定制滤镜(2D卷积)</p></li>
</ul>
<h4 id="二维卷积图像滤波">二维卷积（图像滤波）</h4>
<p>和一维信号一样，图像也可以用各种低通滤波器（<span class="math inline">\(LPF\)</span>）、高通滤波器（<span class="math inline">\(HPF\)</span>）等进行滤波。<span class="math inline">\(LPF\)</span> 有助于去除噪声、模糊图像等。高频滤波器有助于在图像中找到边缘。</p>
<p>$OpenCV $ 提供了一个函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga27c049795ce870216ddfb366086b5a04"><code>cv.filter2D()</code></a></strong> 来将内核与图像进行卷积。例如，我们将尝试在图像上使用平均滤镜。一个 <span class="math inline">\(5x5\)</span> 平均的过滤器内核看起来如下所示： <span class="math display">\[
K = \frac{1}{25} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \end{bmatrix}
\]</span> 操作是这样的：将该内核保持在一个像素之上，将该内核之下的所有25个像素相加，取平均值，并用新的平均值替换中心像素。对图像中的所有像素继续执行此操作。尝试以下代码并检查结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv_logo.png&#x27;</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.float32)/<span class="number">25</span></span><br><span class="line">dst = cv.filter2D(img,-<span class="number">1</span>,kernel)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">&#x27;Averaging&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/filter.jpg"></p>
<h4 id="图像模糊图像平滑">图像模糊（图像平滑）</h4>
<p>图像模糊是通过卷积图像与低通滤波核。它对消除噪声很有用。它实际上从图像中去除高频内容（如噪声和边缘）。所以在这个操作中，边缘会模糊一些（也有一些模糊技术不会模糊边缘）<span class="math inline">\(OpenCV\)</span> 提供了四种主要的模糊技术。</p>
<ol type="1">
<li><p>平均值</p>
<p>这是通过卷积图像与一个标准化的盒子过滤器。它只是取内核区域下所有像素的平均值，然后替换中心元素。这是由函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37"><code>cv.blur()</code></a></strong> 或 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3"><code>cv.boxFilter()</code></a></strong> 完成的。查看文档了解更多关于内核的细节。我们应该指定内核的宽度和高度。一个 <span class="math inline">\(3x3\)</span> 标准化的框状滤波器看起来如下所示： <span class="math display">\[
K = \frac{1}{9} \begin{bmatrix} 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \end{bmatrix}
\]</span></p>
<blockquote>
<p>Note</p>
<p>如果您不想使用规范化的框过滤器，请使用 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3"><code>cv.boxFilter()</code></a></strong>。传递一个参数 <code>normalize=False</code> 给函数。</p>
</blockquote>
<p>查看下面一个 <span class="math inline">\(5x5\)</span> 内核大小的示例演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv.imread(<span class="string">&#x27;opencv-logo-white.png&#x27;</span>)</span><br><span class="line">blur = cv.blur(img,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blur),plt.title(<span class="string">&#x27;Blurred&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/blur.jpg"></p></li>
<li><p>高斯模糊</p>
<p>在此方法中，使用高斯核代替盒形滤波器。这是通过函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1"><code>cv.GaussianBlur()</code></a></strong> 完成的。我们应该指定内核的宽度和高度，它们应该是正的和奇数的。我们还应该指定X和Y方向的标准差，分别是 $ sigmaX$ 和 <span class="math inline">\(sigmaY\)</span>。如果只指定了 <span class="math inline">\(sigmaX\)</span>，则 <span class="math inline">\(sigmaY\)</span> 与 $ sigmaX$ 取相同的值。如果两者都是 <span class="math inline">\(0\)</span>，则从内核大小计算。高斯模糊是去除图像高斯噪声的一种有效方法。</p>
<p>如果你愿意，你可以用函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa"><code>cv.getGaussianKernel()</code></a></strong> 创建一个高斯核。</p>
<p>以上代码可以修改为高斯模糊：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blur = cv.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/gaussian.jpg"></p></li>
<li><p>模糊中值</p>
<p>在这里，函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9"><code>cv.medianBlur()</code></a></strong> 取内核区域下所有像素的中值，并将中心元素替换为这个中值。这对于图像中的椒盐噪声是非常有效的。有趣的是，在上面的过滤器中，中心元素是一个新计算的值，它可能是图像中的像素值，也可能是一个新值。但在中值模糊中，中心元素往往被图像中的某个像素值所替代。有效地降低了噪声。它的内核大小应该是一个正奇数。2</p>
<p>在这个演示中，我给原始图像添加了 <span class="math inline">\(50%\)</span> 的噪声，并应用了中间值模糊。检查结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">median = cv.medianBlur(img,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/median.jpg"></p></li>
<li><p>双边滤波</p>
<p><strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed"><code>cv.bilateralFilter()</code></a></strong> 在去除噪声的同时保持边缘锋利是非常有效的。但与其他滤波器相比，其运算速度较慢。我们已经知道高斯滤波器取像素周围的邻域并求其高斯加权平均值。该高斯滤波器是一个单独的空间函数，即在滤波时考虑附近的像素。它不考虑像素是否有几乎相同的强度。它不考虑一个像素是否是边缘像素。它也会模糊边缘，这是我们不想做的。</p>
<p>双边滤波也在空间中采用高斯滤波器，但多了一个高斯滤波器，它是像素差的函数。空间高斯函数保证了只考虑附近像素进行模糊处理，而强度差高斯函数保证了只考虑那些与中心像素强度相似的像素进行模糊处理。所以它保留了边缘，因为边缘上的像素会有很大的强度变化。</p>
<p>下面的示例展示了双边过滤器的使用(关于参数的详细信息，请访问docs)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blur = cv.bilateralFilter(img,<span class="number">9</span>,<span class="number">75</span>,<span class="number">75</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/bilateral.jpg"></p>
<p>看，表面的纹理消失了，但边缘还保留着。</p></li>
</ol>
<h4 id="附加资源-2">附加资源</h4>
<ol type="1">
<li>Details about the <a href="https://people.csail.mit.edu/sparis/bf_course/">bilateral filtering</a></li>
</ol>
<h4 id="exercises-1">Exercises</h4>
<h3 id="形态学变换">形态学变换</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\65ce8a75cfc0dc33feddd6d4632ab1a.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">2</span>,<span class="number">2</span>),np.uint8)</span><br><span class="line"><span class="comment">#closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span></span><br><span class="line"><span class="comment">#erosion = cv.erode(img,kernel,iterations = 1)</span></span><br><span class="line"><span class="comment">#dilation = cv.dilate(img,kernel,iterations = 1)</span></span><br><span class="line">opening = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)</span><br><span class="line">cv.imshow(<span class="string">&#x27;res&#x27;</span>,opening)</span><br><span class="line">k = cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="目标-3">目标</h4>
<p>在这一章</p>
<ul>
<li><p>我们将学习不同的形态操作，如腐蚀，膨胀，开操作，闭操作等等。</p></li>
<li><p>我们将看到不同的函数： <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb"><code>cv.erode()</code></a></strong>, <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c"><code>cv.dilate()</code></a></strong>, <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f"><code>cv.morphologyEx()</code></a></strong> 等等。</p></li>
</ul>
<h4 id="理论">理论</h4>
<p>形态变换是一种基于图像形状的简单操作。它通常在二值图像上执行。它需要两个输入，一个是原始图像，另一个是决定运算性质的结构元素或核。两个基本的形态运算符是腐蚀和膨胀。然后它的变体形式，如开操作，闭操作和梯度等也会发挥作用。我们将在下图的帮助下一个一个地看到它们：</p>
<p><img src="/2022/03/30/11-27-50/j-16487088974263.png"></p>
<ol type="1">
<li><p><strong>腐蚀</strong></p>
<p>腐蚀的基本概念就像土壤腐蚀一样，它腐蚀了前景对象的边界（尽量保持前景为白色）。那么它有什么作用呢？核在图像中滑动（就像在二维卷积中一样）。只有当核下的所有像素都是 <span class="math inline">\(1\)</span> 时，原始图像中的一个像素（<span class="math inline">\(1\)</span> 或 $ 0$）才会被认为是 <span class="math inline">\(1\)</span>，否则它会被腐蚀（变成 <span class="math inline">\(0\)</span>）。</p>
<p>所以进行腐蚀操作时发生的是，边界附近的所有像素都会被丢弃，这取决于内核的大小。因此前景物体的厚度或尺寸减小，或者图像中的白色区域减小。它可以用来去除小的白色噪音（正如我们在色彩空间章节中看到的），分离两个连接的物体等等。</p>
<p>在这里，作为一个例子，我将使用一个充满1的5x5内核。让我们看看它是如何工作的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img = cv.imread(<span class="string">&#x27;j.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">erosion = cv.erode(img,kernel,iterations = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/erosion-16487092156135.png"></p></li>
<li><p><strong>膨胀</strong></p>
<p>膨胀与腐蚀正好相反，在膨胀操作中，如果核下至少有一个像素为“1”，则像素元素为“1”。因此，它增加了图像中的白色区域，或增加了前景对象的大小。通常情况下，在去除噪音的情况下，腐蚀之后是膨胀。因为侵蚀去除了白噪音，但也缩小了我们的目标。所以我们把它放大。因为噪音消失了，它们不会回来，但是我们的物体面积增加了。它在连接物体的破碎部分时也很有用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dilation = cv.dilate(img,kernel,iterations = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/dilation-16487093069197.png"></p></li>
<li><p><strong>开操作</strong></p>
<p>开操作只是腐蚀和膨胀的另一个名称。它在去除噪音方面很有用，正如我们上面解释的那样。这里我们使用函数<strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f"><code>cv.morphologyEx()</code></a></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opening = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure>
<img src="/2022/03/30/11-27-50/opening-16487093835949.png" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure></li>
<li><p><strong>闭操作</strong></p>
<p>闭操作是开操作的反向，即先膨胀后腐蚀。它在删除前景物体内部的小洞或物体上的小黑点时很有用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/closing-164870944983811.png"></p></li>
<li><p><strong>形态学梯度</strong></p>
<p>它是图像膨胀和侵蚀的区别，梯度的结果将看起来像对象的轮廓。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gradient = cv.morphologyEx(img, cv.MORPH_GRADIENT, kernel)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="/2022/03/30/11-27-50/gradient.png"></p></li>
<li><p><strong>Top Hat</strong></p>
<p>它是输入图像和开操作处理后的输出图像之间的区别。下面的例子是针对9x9内核的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tophat = cv.morphologyEx(img, cv.MORPH_TOPHAT, kernel)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/30/11-27-50/tophat-164870959228714.png"></p></li>
<li><p><strong>Black Hat</strong></p>
<p>它是输入图像的闭操作与输入图像之间的区别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blackhat = cv.morphologyEx(img, cv.MORPH_BLACKHAT, kernel)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/30/11-27-50/blackhat.png"></p></li>
</ol>
<h4 id="结构元素">结构元素</h4>
<p>在前面的例子中，我们在 <span class="math inline">\(Numpy\)</span> 的帮助下手工创建了一个结构化元素。它是长方形的。但在某些情况下，您可能需要椭圆形/圆形的核。为此，<span class="math inline">\(OpenCV\)</span> 有一个函数 <strong><a href="https://docs.opencv.org/4.x/d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc"><code>cv.getStructuringElement()</code></a></strong>。你只需要传递内核的形状和大小，就可以得到想要的内核。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Rectangular Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_RECT,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># Elliptical Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_ELLIPSE,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br><span class="line"><span class="comment"># Cross-shaped Kernel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv.getStructuringElement(cv.MORPH_CROSS,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span><br></pre></td></tr></table></figure>
<h4 id="额外的资源">额外的资源</h4>
<ol type="1">
<li><a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm">Morphological Operations</a> at HIPR2</li>
</ol>
<h4 id="练习">练习</h4>
<h3 id="图像的梯度">图像的梯度</h3>
<h3 id="canny-边缘检测">Canny 边缘检测</h3>
<h3 id="图像金字塔">图像金字塔</h3>
<h3 id="opencv-的轮廓">OpenCV 的轮廓</h3>
<h3 id="opencv-的直方图">OpenCV 的直方图</h3>
<h3 id="opencv-中的图像变换">OpenCV 中的图像变换</h3>
<h3 id="模板匹配">模板匹配</h3>
<h3 id="hough-直线检测">Hough 直线检测</h3>
<h3 id="基于分水岭算法的图像分割">基于分水岭算法的图像分割</h3>
<h3 id="基于-grabcut-算法的交互式前景提取">基于 GrabCut 算法的交互式前景提取</h3>
]]></content>
      <tags>
        <tag>电子设计</tag>
      </tags>
  </entry>
  <entry>
    <title>微机原理与接口技术</title>
    <url>/2022/03/05/16-32-26/</url>
    <content><![CDATA[<h1 id="微机原理与接口技术">微机原理与接口技术</h1>
<h2 id="基本概念">基本概念</h2>
<p>微型计算机简称微机，是微机原理这门课程的主要研究范围。</p>
<p>首先我们先对微型计算机有一个初步的认识。</p>
<h4 id="电脑微型计算机系统">电脑——微型计算机系统</h4>
<p>电脑是我们熟悉的事物，我们家用的台式电脑和笔记本电脑都是属于<strong>个人电脑（Personal Computer）</strong>，简称为PC。个人电脑PC是一个<strong>通用微型计算机系统（）</strong>。其中，“通用”暗示了“专用”计算机系统的存在，而“微型”暗示了“大型”计算机系统的存在。其中还有值得注意的是计算机系统中的“系统”二字，因为这暗示了在计算机之上还存在一个更加宏观的概念。</p>
<p>计算机根据规格和能力区分的话可以粗略分作超级计算机，大型计算机，小型计算机和微型计算机。其中超算和微机可能是我们日常生活中常常能听到的词语，前者出现在新闻里面，比如天河二号；后者出现在我们们的日常生活中，也就是我们的电脑（主机）。</p>
<p>经典的电脑硬件配置包括鼠标，键盘，显示器和电脑主机，虽然笔记本发展后大多数笔记本都配备有触控板作为鼠标的代替，但是鼠标依旧是更受欢迎的计算机<strong>外设（Peripherals）</strong>。除了鼠标，键盘和显示器也是最经典的外设，但是对于完全不了解电脑构造却经常使用电脑的人来说，或许会认为显示器是计算机，尤其是一体机的存在使得这个错误更容易犯下。但是，计算机，顾名思义是计算的机器，它的功能并不会包括“显示”。根据输入，计算机会得到输出，但是这个输出不是我们可以直接看到的“显示”，“显示”的功能来自一个密布发光单元的显示器，显示器可以将计算机的输出变成屏幕上的文字或者图片为我们“显示”出来。</p>
<p>外设不是计算机，真正的计算机是我们通常称为“电脑主机”的的部分，在台式机中，它是显示器旁边的长方体的箱子；在笔记本中，它一般在你的键盘的下面。</p>
<p>计算机（个人计算机）和外设，配合上电源，便组成了微型计算机系统的硬件部分。完整的微型计算机系统不仅包括硬件，还包括软件。后者不是我们在微机原理课程中重点的关注的内容，但是理解软件部分是微型计算机系统不可缺少的部分却很重要。</p>
<p>微型计算机系统的软件部分包括<strong>系统软件</strong>和<strong>应用软件</strong>，系统软件中我们最熟悉的就是操作系统，如Windows和MacOS；而像Office或者浏览器等软件则是应用程序即应用软件。</p>
<p>==总结：家用电脑整体称作<strong>微型计算机系统（）</strong>，这个系统分为硬件和软件两大部分，其中软件部分包括系统软件和应用软件；硬件部分包括电源、外设和最重要的微型计算机（电脑主机）。接下来我们重点介绍微型计算机的内部结构。==</p>
<h4 id="微型计算机">微型计算机</h4>
<p><strong>微型计算机（）</strong>内部结构可概括为四部分：</p>
<ul>
<li>CPU（这个肯定耳熟了，稍后会进一步介绍）</li>
<li>存储器（比较复杂，稍后重点介绍）</li>
<li>总线（bus）：总线就是连接计算机内部部件的导线</li>
<li>输入输出接口电路：与外设连接的导线</li>
</ul>
<p>相信即便是最不了解电脑的小白也听说过CPU的大名。CPU中的字母C表示Center，是中心的意思，表明CPU是计算机的中心。计算机中的一切一切都是围绕着CPU转圈的。这样重要且复杂的部件，我们肯定要单独拿出来讲：下一节微处理器，就是对CPU的详细介绍。</p>
<p>计算机的本质是计算，无论是使用计算机显示文本或是图形，播放音乐或是视频，计算机本身都只是在快速做着最简单的运算。我们从很小的时候便学习开始做运算了，我们知道，做运算首先我们需要纸笔记录下数字，然后可能还需要将结果记录在另一张纸上（比如你的试卷）。计算机中也存在大量的数字，我们称作数据（data），它们存在计算机的存储器中。除数据外，计算中我们需要知道算数的方法，比如老师对我们说，将两个数字相乘，我们就做乘法。计算机也存在类似的东西，称作指令（code）。众所周知，计算机使用二进制，也就是计算机中不存在文字，甚至不存在数字2，我们在计算机中只有0和1。因此计算机中指令和数据都是由0和1进行表示的。在计算机经典结构——冯·诺伊曼结构中，指令和数字不加区分的放在存储器中；而在另一种改进过的计算机结构——哈佛结构中，指令放在指令存储器中而数据放在数据存储器中。这种分开存放的优势在于可以使数据和指令的存取同时进行，我们将在后面进一步看到这样做的重要意义。</p>
<p>目前我们已经知道了，存储器存储着数据和指令。处理数据是计算机无时无刻都在做的事情，而指令则告诉计算机该怎样处理数据。那么接下来的问题是：我们需要一个什么样的存储器呢？</p>
<p>简单来说，我们需要一个好的存储器。一般来说，我们关注存储器的如下3个特点</p>
<ol type="1">
<li>存储器是一个存储结构，既要存，还要取
<ul>
<li>存——要求能存住，机器断电（掉电）后能不能一直保存</li>
<li>取——主要看速度，取出来自然是越快越好</li>
</ul></li>
<li>最后就是作为商品，我们还是要考虑成本的，成本太高买不起就不行了。</li>
</ol>
<p>综上，我们需要一个价格便宜，能掉电存储且读取速度快的存储器。</p>
<p>可惜的是，现实中没有那么完美的存储器（至少目前），虽然根据不同的原理人们制作出的低成本且掉电存储的快闪存储器Flash（就是很多人U盘用的那个），但是它传输速度慢；另一方面人们制作出了静态随机存储器SRAM，虽然便宜还传输快，但是掉电不保存。虽然除了上述两种还有一些类型的存储器，但是也都有其缺点。为了协调速度、容量和成本三个方面，人们设计出了三级存储结构：<strong>高速缓存存储器</strong>、<strong>内存储器（主存）</strong>和<strong>外存储器（辅存）</strong>。</p>
<p>高速缓存存储器存在于主存与CPU之间的一级存储器，容量小但是速度很快，接近于CPU的速度。</p>
<p>内存储器是CPU读取数据和指令的地方，如果数据在外存储器中，CPU将先把数据从外存储器移至内存储器中然后再处理数据。</p>
<p>外存储器就是我们平时说的电脑的固态硬盘，手里拿的U盘和已经淘汰了的光盘。</p>
<p>三级存储结构帮助我们再速度、容量和成本三个方面达到一个平衡。但是未来如果有更好的存储手段，能同时满足上述三点，或许我们就将创造全新的存储器结构，主存和辅存也将会像光盘一样被淘汰掉。</p>
<hr>
<p>微型计算机的分类——按微型计算机的结构形式分类。</p>
<ul>
<li>单片机</li>
<li>单板机</li>
<li>多板机</li>
</ul>
<p>对于数码爱好者，尤其是那些对于台式机组装机器充满兴趣的人都不会对多板机这个概念感到困惑。在台式机中存在一个叫主板或是叫母板的东西。典型的主板能提供一系列接合点，供我们非常熟悉名字的例如处理器、显卡、硬盘驱动器、存储器、对外设备等设备的接合。</p>
<p>多板机是在一块主板上提供了多个扩展插槽，并使用总线将各个部分进行连接，最终将一切封装在一个机箱里面。在组装的开始，我们有一堆板子，在组装完成后，我们有一台电脑。</p>
<p>单板机的思路与多板机不同，单板机将一台电脑用到的所用功能集成在一块电路板上，在购买单板机时我们直接买到的就是一台电脑，而不需要再进行组装。当然，鉴于单板机性能弱一般用于实验室和简单的控制场所，所以单板机所在的电路板可能会进一步连接在其他的电路板上。但是，无论外部还会连接什么，重点是，在一小块电路板上我们有了一台基础功能完备的电脑。这里值得一提的是，对于电子设计爱好者，很可能听说过Arduino和树莓派的大名，这里要说明，Arduino和树莓派都属于单板机。</p>
<p>单片机也被称作微控制器，这个名字基本对单片机定了性质。单片机通常是用来做控制的，常常用于工业，在实验室也经常见到它的身影。单片机将CPU和存储器……其实就是上面提到的微型计算机中该有的那些东西，集成在了一个芯片上面。通常来讲，你对商店老板说来来些单片机，那你将收到的是一些黑色塑料外壳包着的下方有许多金属引脚的小东西。与Arduino和树莓派，一个芯片既不能直接连接一个LED控制它的亮灭，也不能直接烧录程序。单片机正常执行控制需要建立一个最小工作系统，然后才能进行控制。如果想了解更具体些，<a href>这里</a>会有你想知道的。</p>
<p>==总结一下：微型计算机由CPU和存储器组成，内部有总线连接，向外有输入输出电路进行扩展。计算机的本职工作是做计算，计算需要指令和数据，根据指令数据的存储方式的不同可以将微型计算机分为冯·诺伊曼结构和哈佛结构。计算机可以分为单片机、单板机和多板机。将计算机放在一个芯片上是单片机，放在一个电路板上是单板机，多个板子各司其职组装在一起形成电脑叫多板机。==</p>
<h4 id="微处理器">微处理器</h4>
<p>微处理器（microprocessor）也称中央处理单元（central processing unit），是微型计算机的核心部件。</p>
<p>前面我们已将提过，计算机的本职工作是做计算。计算需要两方面内容——数据和指令。前者就相当于给你数字2和3，后者就相当于告诉你对2和3做乘法。对于CPU来说不止但肯定有下述三个功能：</p>
<ul>
<li>进行基本的算数和逻辑运算（如果想要知道电路是如何做运算的，<a href>这里</a>会找到答案的）</li>
<li>暂存少量数据（这是好理解的，毕竟我们计算式也要先把数字写在草稿纸上）</li>
<li>执行指令（值得注意的是指令是需要译码的）</li>
</ul>
<h3 id="嵌入式系统">嵌入式系统</h3>
<p>上文我们以通用计算机系统为例，沿着“微型计算机系统-&gt;微型计算机-&gt;微（型）处理器”三个层次描述了微机的基本概念。最后我们注意微机的另一大类，即平行于通用计算机系统的，名为嵌入式系统的专用计算机系统。</p>
<p>嵌入式系统也是微型计算机系统，上面描述的通用计算机系统包含的内容，在嵌入式系统中也同样有所体现。但是嵌入式系统的关键词在于“专用”。专用意味着嵌入式系统为某一具体的应用问题而生，不需要具备通用计算机系统的全部内容。例如，嵌入式系统中可能不会连接鼠标键盘等外设，而且不会具备完整的系统软件。</p>
<h2 id="arm微处理器">ARM微处理器</h2>
<p>ARM微处理器最重要的特性是其英文名称</p>
<h4 id="arm-微处理器的工作状态">ARM 微处理器的工作状态</h4>
<ul>
<li>ARM 状态：处理器执行32位的 ARM 指令集，即执行字方式的 ARM 指令</li>
<li>Thumb 状态：处理器执行16位的 Thumb 指令集，即执行半字方式的 ARM 指令</li>
</ul>
<p>ARM 微处理器在两种工作模式下都有切换处理器工作状态的指令，但是在 ARM 处理器开始执行代码时处理器应处于 ARM 状态。</p>
<h4 id="arm-微处理器的工作模式">ARM 微处理器的工作模式</h4>
<ul>
<li>用户模式</li>
<li>特权模式
<ul>
<li>系统模式</li>
<li>异常模式
<ul>
<li>管理模式</li>
<li>快速中断模式</li>
<li>外部中断模式</li>
<li>数据访问中止模式</li>
<li>未定义指令中止模式</li>
</ul></li>
</ul></li>
</ul>
<p>工作模式可以通过软件改变，也可以通过外部中断和处理器异常来改变。并且每一种模式下可以使用的寄存器是不同的。</p>
<h4 id="arm-处理器支持的数据类型和存储格式">ARM 处理器支持的数据类型和存储格式</h4>
<h5 id="数据类型">数据类型</h5>
<p>在处理器中数据类型是这样分类的，分成下面三种类型：</p>
<ul>
<li>字节类型</li>
<li>半字类型</li>
<li>字类型</li>
</ul>
<p>数据操作都是以字为单位的（这里课本写：ARM 指令是一个字长而 Thumb 指令是半字长；但不是说操作都是以字为单位并且都是一样长吗？？？），而从存储器读写的数据则可以按上述三种不同的数据类型进行读写。</p>
<p>对存储器按字或者半字类型进行读取时，需要进行对齐操作；对数据进行字节传输时不需要对齐。</p>
<blockquote>
<p>一条指令（指的是机器码）由操作码（opcode）和操作数（operand）构成。操作数可以是1个，也可以是多个，甚至可以没有。操作码则是每一条指令都必须有。操作码表示该指令要做什么动作，例如跳转，加减等等。操作数则表示操作对象，操作数可能还会分为目的操作数和源操作数。操作数当然是一个数字，该操作数可以由多种来源，例如寄存器，存储器或者立即数。本节介绍的处理器的寻址方式就是讨论指令中操作数的来源问题。</p>
</blockquote>
<h5 id="存储格式">存储格式</h5>
<blockquote>
<p>指令编码中，用来说明操作数来源和操作数构成存储器地址的方法，叫做寻址方式，英文为Addressing Mode。寻址方式是由处理器的指令编码直接决定的，是处理器体系架构的一部分，所以我们一般叫做xxx处理器寻址方式，例如8086寻址方式，MIPS寻址方式。寻址方式是学习任何一种汇编语言的起点。</p>
</blockquote>
<p>ARM 存储器的最大寻址空间为4 GB。</p>
<p>存储器可以看作是一个从零开始线性递增的一个容器，容器的基本单位为字节。</p>
<p>数据以字为单位存储在存储器中，这意味着一个（字）数据将存放在存储器的四个基本单位中。</p>
<p>数据在存储器中的存储方式有两种，区分两种存储方式的关键在于一个字的四个字节在存储器中哪一个存在高位哪一个存在低位：</p>
<ul>
<li>大端格式：数据的高字节位存储在存储器的低地址中</li>
<li>小端格式：数据的低字节位存储在存储器的低地址中</li>
</ul>
<p>大小端的存储方式可以通过外部引脚和内部寄存器的配置来进行选择，选择要在使用前进行配置，开始使用后只能选择一种存储器数据存储方式。</p>
<h4 id="arm-处理器的寄存器">ARM 处理器的寄存器</h4>
<p>ARM 寄存器：</p>
<ul>
<li>定义：寄存器是 CPU 内部用来暂时存放参与运算的数据和运算结果的小型存储区域</li>
<li>特征：传输数据的速度非常快</li>
<li>分类：
<ul>
<li>通用寄存器：保存数据和地址</li>
<li>状态寄存器：标识 CPU 的工作状态及程序的运行状态</li>
</ul></li>
<li>经典 ARM 寄存器在物理上共有37个32位寄存器组成
<ul>
<li>31个通用寄存器</li>
<li>6个状态寄存器</li>
</ul></li>
</ul>
<h4 id="arm-处理器的io组织">ARM 处理器的I/O组织</h4>
<p>I/O 是 CPU 与外部设备之间通信的桥梁</p>
<p>对 I/O 端口物理地址进行编址的方式有两种：</p>
<ul>
<li><p>独立编址方式：I/O映射方式，x86采用</p>
<p>I/O 端口地址与内存单元地址分开独立编址，I/O 端口地址不占用内存空间的地址范围，需要专门的I/O 指令和控制逻辑</p></li>
<li><p>统一编址方式：内存映射方式，ARM采用</p>
<p>I/O 端口地址与内存单元地址混在一起：将内存的一部分划分出来作为I/O 地址空间。</p></li>
</ul>
<h2 id="cortex-m4-微处理器">Cortex-M4 微处理器</h2>
<h4 id="cortex-m4-微处理器的工作状态">Cortex-M4 微处理器的工作状态</h4>
<h4 id="cortex-m4-微处理器的工作模式">Cortex-M4 微处理器的工作模式</h4>
<h4 id="cortex-m4-微处理器的寄存器组织">Cortex-M4 微处理器的寄存器组织</h4>
<ul>
<li>存在于：寄存器存在于处理器的内核之中</li>
<li>作用：执行数据处理和控制</li>
<li>分类：16个32位寄存器
<ul>
<li>通用寄存器组</li>
<li>特殊功能寄存器</li>
</ul></li>
<li>与经典的 ARM 微处理器对比：Cortex-M4 微处理器的寄存器较少</li>
<li>通用寄存器详解：
<ol type="1">
<li><span class="math inline">\(R0-R7\)</span>：
<ul>
<li>统称：低组寄存器</li>
<li>访问指令：32位指令和大多数16位指令</li>
<li>初始化：复位后初始化为未定义</li>
</ul></li>
<li><span class="math inline">\(R8-R12\)</span>：
<ul>
<li>统称：高组寄存器</li>
<li>访问指令：32位指令和少量16位指令</li>
<li>初始化：复位后初始化为未定义</li>
</ul></li>
<li><span class="math inline">\(R13\)</span>：
<ul>
<li>统称：堆栈指针寄存器</li>
<li>系统可以同时支持两个堆栈，</li>
</ul></li>
</ol></li>
</ul>
<h4 id="cortex-m4-微处理器的存储组织">Cortex-M4 微处理器的存储组织</h4>
<h1 id="摘抄">摘抄：</h1>
<p>RISC使用的是load-store结构。load-store结构的本质，在于RISC技术的CPU只处理（指逻辑，算术运算处理）寄存器中的数据。相反，X86却能够直接处理存储器中的数据。</p>
<p><a href="https://nieyong.github.io/wiki_cpu/index.html">index (nieyong.github.io)</a></p>
<h1 id="stm32启动程序分析">STM32启动程序分析</h1>
<p><strong>1.程序的内存分配</strong></p>
<p>一个由C/C 编译的程序占用的内存分为以下几个部分：</p>
<p><strong>栈区（stack）：</strong>由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p>
<p><strong>堆区（heap）：</strong>一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式类似于链表。</p>
<p><strong>全局区（静态区）（static）：</strong>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</p>
<p><strong>文字常量区：</strong>常量字符串就是放在这里的，程序结束后由系统释放。</p>
<p><strong>程序代码区：</strong>存放函数体的二进制代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>; <span class="comment">//全局初始化区</span></span><br><span class="line"><span class="type">char</span> *p1; <span class="comment">//全局未初始化区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> b; <span class="comment">//栈 </span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>; <span class="comment">//栈 </span></span><br><span class="line">    <span class="type">char</span> *p2; <span class="comment">//栈 </span></span><br><span class="line">    <span class="type">char</span> *p3 = <span class="string">&quot;123456&quot;</span>; <span class="comment">//123456\0在常量区，p3在栈上。 </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">0</span>;<span class="comment">//全局（静态）初始化区 </span></span><br><span class="line">    p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); </span><br><span class="line">    p2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">//分配得来得10和20字节的区域就在堆区。 </span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">&quot;123456&quot;</span>); <span class="comment">//123456\0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里要强调一点：传递指针只占4字节，如果传递的是结构体，就会占用结构大小空间。</span></span><br><span class="line"><span class="comment">//提示：在函数嵌套,递归时，系统仍会占用栈空间。</span></span><br><span class="line"><span class="comment">//虽然堆上的数据只要程序员不释放空间就可以一直访问，但是，如果忘记了释放堆内存，那么将会造成内存泄漏，甚至致命的潜在错误。</span></span><br></pre></td></tr></table></figure>
<p>Q&amp;A</p>
<p>Q:为什么驱动文件是汇编语言写而不是C语言? A:汇编语言处理一些更加底层的工作，如设置堆栈空间等，这一点C这个"高级语言"无法做到。</p>
<p>Q:启动程序阶段，CPU对启动文件是从上向下足以读取吗？ A:编译之前的是源程序，编译之后的指令的机器码以地址进行排列。实际上按地址逐一进行读取，要看源码的组织结构。</p>
<p>Q:用户通过Keil软件配置堆栈空间和自己定义堆栈有什么区别？ A:</p>
<p>时钟系统就是CPU的脉搏，像人的心跳一样，重要性不言而喻。由于STM32本身十分复杂，外设非常多，但并不是所有的外设都需要系统时钟那么高的频率，比如看门狗以及RTC只需要几十k的时钟即可。并且，同一个电路，时钟越快功耗越快，同时抗电磁干扰能力也就越弱，所以较为复杂的MCU都是采用多时钟源的方法来解决这些问题。</p>
<p>startup_stm32f10x_cl.s（启动文件） → SystemInit() → SetSysClock () → SetSysClockTo72()</p>
<p>查看MDK的文档，会发现有这么一句说明：It is automatically created by the linker when it sees a definition of main()。简单点来说，当编译器发现定义了main函数，那么就会自动创建__main。</p>
<p>程序经过汇编启动代码，执行到__main()，之后会执行两个大的函数：</p>
<p>__scatterload()：负责把RW/RO输出段从装载域地址复制到运行域地址，并完成了ZI运行域的初始化工作。</p>
<p>__rt_entry():负责初始化堆栈，完成库函数的初始化，<strong>最后自动跳转向main()函数</strong>。</p>
<p>注意：有些应用中会要求在进入main函数之前先初始化一些外设或者变量区，如：初始化时钟、初始化SDRAM。在初始化他们的时候一定不要使用全局变量，部分库函数，HAL库。因为在__main之前，全局变量还没有初始化，使用会异常，甚至发生内存错误。<strong>因此建议使用寄存器来初始化。</strong></p>
<p>https://blog.csdn.net/shenghuaDay/article/details/71643767</p>
<p>r0-r3 用作传入函数参数，传出函数返回值。在子程序调用之间，可以将 r0-r3 用于任何用途。被调用函数在返回之前不必恢复 r0-r3。如果调用函数需要再次使用 r0-r3 的内容，则它必须保留这些内容。</p>
<p>r4-r11 被用来存放函数的局部变量。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。</p>
<p>r12 是内部调用暂时寄存器 ip。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色.在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。</p>
<p>r13 是栈指针 sp。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。</p>
<p>r14 是链接寄存器 lr。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复</p>
<p>r15 是程序计数器 PC。它不能用于任何其它用途。</p>
<p>注意：在中断程序中，所有的寄存器都必须保护，编译器会自动保护R4～R11</p>
<p>所谓启动，一般来说就是指我们下好程序后，重启芯片时，SYSCLK的第4个上升沿，BOOT引脚的值将被锁存。用户可以通过设置BOOT1和BOOT0引脚的状态，来选择在复位后的启动模式。</p>
<p>STM32上电或者复位后，代码区始终从0x00000000开始，三种启动模式其实就是将各自存储空间的地址映射到0x00000000中。</p>
<p>（1）从Flash启动，将主Flash地址0x08000000映射到0x00000000，这样代码启动之后就相当于从0x08000000开始。</p>
<p>（2）从RAM启动，将RAM地址0x20000000映射到0x00000000,这样代码启动之后就相当于从0x20000000开始。</p>
<p>（3）从系统存储器启动。首先控制BOOT0 BOOT1管脚，复位后，STM32与上述两种方式类似，从系统存储器地址0x1FFF F000开始执行代码。系统存储器存储的其实就是STM32自带的bootloader代码，在bootloader中提供了UART1的接口，通过此接口可以将用户所需的程序代码下载到主Flash中，下载完毕后，此时程序代码已经存储在主Flash当中，这时切换启动模式（从主Flash启动），复位后所执行的就是刚刚下载到Flash中的代码了。</p>
<p>在STM32中，一般都会有一个片上的Flash和SRAM。Flash用于烧录我们编译后生成的目标代码，SRAM则用于栈空间和保存全局变量， 它们分别对应图1中地址空间的Code段和SRAM段。此外STM32中的Flash一般都映射在0x0800 0000的地址上的， 因此为了保证向量表写在0x0800 0000的位置上，我们必须保证生成的目标代码中一开始就是向量表的内容</p>
<figure>
<img src="/2022/03/05/16-32-26/image-20220502134455259-16514702975521.png" alt="image-20220502134455259"><figcaption aria-hidden="true">image-20220502134455259</figcaption>
</figure>
<figure>
<img src="/2022/03/05/16-32-26/image-20220502134540053-16514703414583.png" alt="image-20220502134540053"><figcaption aria-hidden="true">image-20220502134540053</figcaption>
</figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">--cpu Cortex-M4.fp.sp *.o </span><br><span class="line">--strict --scatter &quot;.\Objects\project.sct&quot; </span><br><span class="line">--summary_stderr --info summarysizes --map --xref --callgraph --symbols </span><br><span class="line">--info sizes --info totals --info unused --info veneers </span><br><span class="line"> --list &quot;.\Listings\project.map&quot; </span><br><span class="line">-o .\Objects\project.axf </span><br></pre></td></tr></table></figure>
<h3 id="arm寻址方式">ARM寻址方式：</h3>
<h4 id="寄存器间接寻址">寄存器间接寻址：</h4>
<p>把寄存器当作存储器的指针。</p>
<p><img src="/2022/03/05/16-32-26/image-20220507083936948-16518839785891.png" alt="image-20220507083936948" style="zoom:50%;"></p>
<h1 id="体系结构架构">体系结构——架构</h1>
<p>架构由指令集和操作空间（寄存器和存储器）组成</p>
<p>计算机中使用的单词叫指令，计算机使用的词汇表叫指令集</p>
<p>指令包含操作码和操作数，操作数来自于存储器，寄存器和指令本身</p>
<p>ARM架构将每条指令表示为一个32位的字，微处理器是一个可以读入并执行机器语言的指令的数字电路系统</p>
<p>ARM设计的四个准则：</p>
<ul>
<li>规范性支持简单设计</li>
<li>加快常见功能</li>
<li>越小设计越快</li>
<li>好的设计需要折中方法</li>
</ul>
<h1 id="微机原理复习">微机原理复习</h1>
<h3 id="微型计算机系统">微型计算机系统</h3>
<p>微处理器（MP）也称为中央处理单元（CPU），由运算器和控制器两部分组成。</p>
<p>CPU 功能及其组成</p>
<table>
<thead>
<tr class="header">
<th>功能</th>
<th>对应</th>
<th>组成</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>算数运算、逻辑运算</td>
<td>&lt;---&gt;</td>
<td>算数逻辑单元（ALU）</td>
</tr>
<tr class="even">
<td>暂存少量数据</td>
<td>&lt;---&gt;</td>
<td>寄存器组</td>
</tr>
<tr class="odd">
<td>1. 指令译码、执行指令<br>2. 提供定时和控制信号<br>3. 响应中断</td>
<td>&lt;---&gt;</td>
<td>控制单元（CU）</td>
</tr>
<tr class="even">
<td>与存储器和外设通信</td>
<td>&lt;---&gt;</td>
<td>内部总线</td>
</tr>
</tbody>
</table>
<p>细节介绍</p>
<ul>
<li><p>程序计数器（PC）：存储下一条要被执行的指令的地址</p></li>
<li><p>累加器（AC）：保存参与计算的数据和运算的中间结果</p></li>
<li><p>堆栈指针（SP）：存放栈顶地址</p></li>
<li><p>标志寄存器：存放指令执行结果和处理器状态</p></li>
<li><p>指令译码器（ID）：对指令译码</p></li>
<li><p>指令寄存器（IR）</p></li>
<li><p>地址寄存器（MAR）</p></li>
</ul>
<p>CPU 执行指令的过程</p>
<p>前提：程序已经存放在内存中，上电后PC中存放第一条指令地址</p>
<ol type="1">
<li>读PC： 控制器将PC中的地址送至MAR，并且发出读命令</li>
<li>取指令： 存储器依据PC中的地址取指令，经数据总线送入IR</li>
<li>译码指令： ID对IR中的指令译码</li>
<li>执行指令： 译码后的 “指令“ 使得 ”控制逻辑阵列“ 向 “存储器或运算器” 发出操作命令</li>
<li>改PC： 修改PC，准备读取下一条指令</li>
</ol>
<p>计算机运行过程是不断取指令然后执行指令的过程，早期计算机采用 ”取指令“ 后才 ”执行指令“ 的串行执行方式</p>
<p>但是现代微处理器普遍采用指令流水线技术，即指令执行中步骤并行进行：</p>
<ul>
<li><p>两级流水线：8086：取指令、执行</p></li>
<li><p>三级流水线：ARM7：取指令、译码、执行</p></li>
<li><p>六级流水线：？？？：取指令、译码、计算操作数地址、取操作数、执行指令、写操作数</p></li>
</ul>
<p>微型计算机</p>
<p>微型计算机组成：CPU、存储器、输入输出接口和总线</p>
<p>硬件结构分类：冯诺依曼结构 &amp; 哈佛结构</p>
<table>
<thead>
<tr class="header">
<th>冯诺依曼结构</th>
<th>哈佛结构</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1. 运算器<br>2. 存储器<br>3. 控制器<br>4. 输入输出设备<br></td>
<td>1. 运算器<br>2. 控制器<br>3. 输入输出接口<br>4. 指令存储器<br>5. 数据存储器</td>
</tr>
<tr class="even">
<td>数据和指令存在一个存储器中不区分</td>
<td>数据和指令分别存在两个存储器中</td>
</tr>
<tr class="odd">
<td>一套总线</td>
<td>两套总线：分数据和地址</td>
</tr>
</tbody>
</table>
<p>按CPU的指令集分类：精简指令集计算机（RISC）和复杂指令集计算机（CISC）</p>
<p>RISC：</p>
<ul>
<li>优点
<ul>
<li>简化指令功能</li>
<li>大量使用寄存器</li>
</ul></li>
<li>缺点
<ul>
<li>增加开发难度</li>
<li>性能依赖编译器</li>
</ul></li>
</ul>
<p>CISC：</p>
<ul>
<li>优点：
<ul>
<li>程序运行速度块</li>
<li>降低软件成本</li>
</ul></li>
<li>缺点：
<ul>
<li>增加硬件设计难度</li>
<li>常用指令集少</li>
</ul></li>
</ul>
<p>总线</p>
<p>总线的组成：总线控制器、总线发送器、总线接收器和一组导线</p>
<p>将微型计算机中的总线按位置和使用场景分为三种：</p>
<ul>
<li>片内总线</li>
<li>片外总线（局部总线）</li>
<li>内总线（系统总线）
<ul>
<li>数据总线（DB）：
<ul>
<li>双向总线</li>
<li>数据总线位数与微机的位数对应，是微机的一个重要指标</li>
</ul></li>
<li>地址总线（AB）：
<ul>
<li>CPU送出的单向总线</li>
<li>决定了CPU可以直接寻址的内存空间：<span class="math inline">\(N\)</span>位地址线管理<span class="math inline">\(2^N\)</span>字节地址空间，如32位AB可以访问<span class="math inline">\(4GB\)</span>物理地址空间</li>
</ul></li>
<li>控制总线（CB）
<ul>
<li>双向传输控制信号</li>
</ul></li>
</ul></li>
<li>外总线（通信总线）</li>
</ul>
<p>微型计算机的存储器分为内存储器和外存储器，目前采用了存储器三级存储结构</p>
<p>CPU与外设的通信依托于IO接口</p>
<p>微型计算机分类：</p>
<ul>
<li>单片机：CPU+存储器+IO口+时钟</li>
<li>单板机：一片PCB，包括了显示器和键盘等外设，实验室用</li>
<li>多板机：将多个模块组装在一个主板上，就是我们的电脑主机</li>
</ul>
<h4 id="微型计算机系统-1">微型计算机系统</h4>
<p>包括硬件和软件两部分</p>
<p>衡量指标：</p>
<ol type="1">
<li>字长：字长指计算机能直接处理的二进制数据的位数，32位计算机就是指字长为32的计算机。字长取决于数据总线的位数</li>
<li>主存：主存储器能存储的最大信息为主存容量
<ul>
<li>可以用 字节数 表示主存大小</li>
<li>可以用 单元数×字长 表示主存大小</li>
</ul></li>
<li>主频：计算机中主时钟信号的频率</li>
<li>运算速度、性价比</li>
</ol>
<h4 id="嵌入式系统-1">嵌入式系统</h4>
<p>嵌入式系统是指嵌入到应用对象的计算机系统</p>
<p>ARM体系结构分类：</p>
<p>ARM有7个版本，各个版本之间主要的区分在于体系结构（架构）的变化</p>
<p>ARMv4版本：增加了Thumb指令集，可以在16位/32位指令集之间切换</p>
<p>ARMv6版本：增加了STMD指令集和Thumb2指令集</p>
<p>ARMv7版本：</p>
<ul>
<li>ARMv7-A：高运算性能</li>
<li>ARMv7-R：实时处理</li>
<li>ARMv7-M：廉价，不支持STMD</li>
</ul>
<p>增强型体系结构：如T增强版本指增加了Thumb指令集</p>
<p>ARM微处理器分类</p>
<p>ARM处理器包括经典的ARM处理器和Cortex处理器：</p>
<ul>
<li>ARM11之前叫ARM处理器，如ARM7、ARM9、ARM10E</li>
<li>ARM11之后改用Cortex命名并分为A、R、M三类</li>
</ul>
<h4 id="计算机中的数字">计算机中的数字</h4>
<p>数制转化</p>
<p>十进制转二进制：整数部分做除法，小数部分做乘法</p>
<p>二进制转十进制：按权展开求和</p>
<p>二进制、八进制、十六进制转化直接转，八进制三个三个划分、十六进制四个四个划分</p>
<p>计算机中数的表示：</p>
<p>计算机中只存在0/1，没有负号或者小数点。</p>
<ul>
<li><p>为了解决使用计算机中的0/1解决符号的问题，我们引入了：</p>
<ul>
<li><p>机器数：-10b -&gt; 110b</p></li>
<li><p>真值：101b -&gt; -2d</p></li>
<li><p>原码：就是最基本的机器数：+用0表示，-用1表示</p>
<ul>
<li>反码：反码使用原码得到：
<ul>
<li>正数反码与原码相同</li>
<li>负数反码符号位不变，数值位是原码依次取反</li>
</ul></li>
</ul></li>
<li><p>补码：</p>
<ul>
<li>正数补码与原码相同</li>
<li>负数X：<span class="math inline">\([X]_补 = [X]_反 + 1\)</span></li>
</ul></li>
</ul></li>
<li><p>为了解决使用计算机中小数的表示问题，我们引入了：</p>
<ul>
<li>定点数：小数点在数中的位置是不变的</li>
<li>浮点数：</li>
</ul></li>
</ul>
<p>计算机中的编码：</p>
<ul>
<li>BCD码</li>
<li>ASCII码</li>
<li>汉字编码：GB2312-80（国标码）
<ul>
<li>汉字输入码（外码）：某一汉字的一组键盘符号</li>
<li>内码：计算机存储用的编码，内码是将国标码的最高两位置1得到的</li>
<li>汉字输出码</li>
</ul></li>
</ul>
<h3 id="arm处理器">ARM处理器</h3>
<h4 id="特点及功能">特点及功能</h4>
<p>ARM是32位的RISC微处理器架构，ARM微处理器是ARM架构下的微处理器</p>
<p>ARM微处理器特点：</p>
<ol type="1">
<li>ARM7采用冯诺依曼结构、ARM9-ARM11包括Cortex系列采用的是哈佛结构</li>
<li>属于RISC处理器结构</li>
<li>有两种工作状态，并且定义了多种工作模式</li>
<li>大量使用寄存器</li>
</ol>
<p>ARM指令集特点：</p>
<ol type="1">
<li>采用固定长度指令集</li>
<li>内存的访问使用LOAD/STORE模式（LOAD/STORE伪指令可以操作内存，其他都是操作寄存器）</li>
</ol>
<p>Cortex-M3/4的特点：</p>
<ol type="1">
<li>哈佛结构</li>
<li>三级流水线</li>
<li>32位寻址，4GB存储器空间</li>
<li>采用Thumb2指令集</li>
</ol>
<p>Cortex-M4中的总线：</p>
<ul>
<li>I-CODE：获取指令</li>
<li>D-CODE：读取立即数</li>
<li>系统总线：访问外设</li>
<li>私有外设总线（PPB）：也是访问外设</li>
</ul>
<h4 id="arm微处理器编程模型">ARM微处理器编程模型</h4>
<p>工作状态：</p>
<ul>
<li>ARM状态：执行32位的ARM指令集，字方式的ARM指令</li>
<li>Thumb状态：执行16位的Thumb指令集，执行半字方式的ARM指令</li>
</ul>
<p>ARM处理器在运行中可以在两种方式间切换，但是开始时只能从ARM状态开始；</p>
<p>ARM指令集效率高，支持所有功能；Thumb指令集具有良好的代码密度</p>
<p>工作模式：</p>
<ul>
<li>用户模式</li>
<li>特权模式
<ul>
<li>系统模式</li>
<li>异常模式
<ul>
<li>管理模式</li>
<li>快速中断模式</li>
<li>外部中断模式</li>
<li>数据访问中止模式</li>
<li>未定义指令中止模式</li>
</ul></li>
</ul></li>
</ul>
<p>模式可以通过编程来改变，每种模式能够使用的寄存器不同</p>
<h4 id="arm微处理器支持的数据类型和存储格式">ARM微处理器支持的数据类型和存储格式</h4>
<h5 id="arm汇编的数据类型">ARM汇编的数据类型：</h5>
<p>3种数据类型：字、半字、字节</p>
<p>4字节对齐（字对齐）：对存储器按字读写时，要求数据地址的低两位是00</p>
<p>2字节对齐（半字对齐）：对存储器按字读写时，要求数据地址的最低为是0</p>
<p>使用字节进行读写时，对数据地址没有要求</p>
<p>数据：</p>
<p>数据可以是有符号数：<span class="math inline">\(0到2^n-1\)</span>，也可以是无符号数：<span class="math inline">\(-2^{n-1}到2^{n-1}-1\)</span></p>
<p>ARM指令是一个字长，Thumb指令是半个字长；</p>
<p>数据操作指令是以字为单位的，对存储器进行读写的指令，有字节、半字和字为单位</p>
<h5 id="数据存储方式">数据存储方式：</h5>
<ul>
<li>大端格式：字数据的高字节存放在存储器的低地址</li>
<li>小端格式：字数据的低字节存放在存储器的高地址</li>
</ul>
<h5 id="arm的寄存器">ARM的寄存器：</h5>
<p>CPU内，暂时存放，参与运算的数据，和运算结果的，小型存储区域</p>
<ul>
<li>通用寄存器：保存数据和地址</li>
<li>状态寄存器：标识CPU工作状态和程序运行状态</li>
</ul>
<p>经典ARM处理器有37个寄存器，31个通用寄存器，6个状态寄存器</p>
<ul>
<li>31个通用寄存器：
<ul>
<li>未分组寄存器 R0 ~ R7，共8个</li>
<li>分组寄存器 R8 ~ R12，R13 ~ R14
<ul>
<li>R8 ~ R12：其中FIQ模式下有单独的一组 R8 ~ R12，共5个；另外6中模式共用一组R8 ~ R12，共5个；总共10个</li>
<li>R13 ~ R14：其中USR和SYS模式（表格的第一列）共用一组R13 ~ R14共2个，另外5中模式下各有独自的一组R13 ~ R14共10个；总共12个</li>
</ul></li>
<li>程序计数器（PC） 即R15，共1个</li>
</ul></li>
<li>6个状态寄存器
<ul>
<li>状态寄存器 CPSR，和5个备份状态寄存器SPSR，共6个</li>
</ul></li>
</ul>
<h5 id="arm处理器的io组织">ARM处理器的I/O组织：</h5>
<p>对I/O端口进行编址的方式有两种：独立和统一，这里的独立和统一针对的都是内存单元</p>
<ul>
<li>独立编址方式（IO映射方式）
<ul>
<li>x86体系结构</li>
<li>IO端口的地址和内存的地址是分开，IO有自己的端口，对应相应的寄存器和指令</li>
</ul></li>
<li>统一编址方式
<ul>
<li>ARM体系结构</li>
<li>IO端口和内存是同等地位的</li>
</ul></li>
</ul>
<h4 id="cortex-m4微处理器">Cortex-M4微处理器</h4>
<h5 id="cortex-m4微处理器工作状态">Cortex-M4微处理器工作状态：</h5>
<ul>
<li>调试状态：进入调试状态意味着处理器被暂停，原因可能是调试时间或者触发断点
<ul>
<li>用于调试操作</li>
<li>进入方法：调试器发起暂停请求；处理器产生调试事件</li>
<li>可以修改寄存器</li>
</ul></li>
<li>Thumb状态：处理器正常执行代码时就是处于Thumb状态
<ul>
<li>在Thumb状态下有两个工作模式
<ul>
<li>线程模式：复位时执行代码就是处于线程模式；”异常“ 返回时也进入线程模式；特权级或者非特权级</li>
<li>处理模式：处理模式就是执行”异常“，例如中断；特权级</li>
</ul></li>
</ul></li>
</ul>
<h5 id="cortex-m4微处理器寄存器组织">Cortex-M4微处理器寄存器组织：</h5>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 37%">
<col style="width: 12%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>通用寄存器</th>
<th>功能</th>
<th>特殊功能寄存器</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>R0-R7</td>
<td>低寄存器<br>32位指令和大多数16位指令可以访问</td>
<td>xPSR</td>
<td>APSR：应用程序状态寄存器，保存当前指令运算结果的状态<br>IPSR：中断状态寄存器，保存当前中断的向量号<br>EPSR：执行状态寄存器，进入异常时保护现场</td>
</tr>
<tr class="even">
<td>R8-R12</td>
<td>高寄存器<br>32位指令和少量16位指令可以访问</td>
<td>中断屏蔽寄存器</td>
<td>PROMASK：片上外设中断总开关，仅一位<br>FAULTMASK：异常屏蔽寄存器，异常的总开关<br>BASEPRI：定义屏蔽优先级的阈值</td>
</tr>
<tr class="odd">
<td>R13（堆栈指针寄存器）</td>
<td>一个堆栈指针对应两个物理寄存器<br>主堆栈指针（MSP）：内核及系统异常中断<br>进程堆栈指针（PSP）：用户任务</td>
<td>控制寄存器（CONTROL）</td>
<td>定义线程模式的访问级别<br>选择堆栈指针</td>
</tr>
<tr class="even">
<td>R14（连接寄存器 LR）</td>
<td>子程序或函数调用时保存返回地址<br>异常返回时保存返回后的状态<br>异常返回的地址由硬件电路保存在PC</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>R15（程序计数器 PC）</td>
<td>指向 ”正在取指“ 的操作<br>读操作：返回当前指令地址加4<br>写操作：引起程序跳转操作</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="cortex-m4微处理器的存储组织">Cortex-M4微处理器的存储组织</h5>
<p><strong>存储系统特征：</strong></p>
<ul>
<li>32位寻址访问4GB的存储器空间</li>
<li>预定义的存储器映射</li>
<li>可以自己配置大端或者小端模式</li>
<li>可选位段访问</li>
<li>具有存储器保护单元（MPU）</li>
<li>支持非对其传输</li>
</ul>
<p><strong>存储器映射：</strong></p>
<p><strong>存储区划分：</strong></p>
<ul>
<li>程序代码访问（code区）
<ul>
<li>存放指令或者数据</li>
<li>ICode总线读写指令；DCode总线读写数据</li>
<li>用于存代码，用于异常向量表</li>
</ul></li>
<li>数据访问（SRAM区）
<ul>
<li>片上SRAM
<ul>
<li>存放指令或者数据</li>
<li>通过系统总线读写数据</li>
<li>用于数据存储</li>
</ul></li>
<li>片外SRAM
<ul>
<li>通过系统总线读写数据</li>
<li>用于扩展外部存储器</li>
</ul></li>
<li>该区域可以位寻址</li>
</ul></li>
<li>外设（外设区）
<ul>
<li>片上外设
<ul>
<li>通过系统总线访问</li>
<li>用于作为片上外设的输入输出接口</li>
</ul></li>
<li>片外外设
<ul>
<li>通过系统总线访问</li>
<li>用于扩展片外外设的输入输出接口</li>
</ul></li>
</ul></li>
<li>处理器的内部控制和调试组件（私有外设总线）
<ul>
<li>分配给
<ul>
<li>中断控制器（NVIC）</li>
<li>调试部件</li>
</ul></li>
</ul></li>
<li>系统区域是给芯片厂家使用的</li>
</ul>
<p><strong>堆栈内存操作：</strong></p>
<p>LIFO（Last In First Out）后入先出</p>
<p>处理器中采用堆栈机制来临时存放数据和变量</p>
<p>Cortex-M4将系统主存储器用于堆栈空间，用PUSH指令存数据，POP指令取数据，执行指令时堆栈指针会自动调整</p>
<p>Cortex-M4使用的是 ”满递减“ 栈，PUSH指令执行时，指针地址数值减小；有于寄存器是32位的，每一次执行PUSH或POP指令时至少都会传输一个字。而且地址总是对齐到4字节的边界上，SP的最低两位也总为0</p>
<h4 id="cortex-m4-微处理器的异常和中断">Cortex-M4 微处理器的异常和中断</h4>
<p><strong>异常和中断的异同：</strong></p>
<ul>
<li>异：
<ul>
<li>中断信号来自内核外</li>
<li>异常是内核产生的</li>
</ul></li>
<li>同：都需要保存当前状态，跳到处理程序，处理完成后再回到原来状态</li>
</ul>
<p><strong>嵌套向量中断控制器（NVIC）及向量表：</strong></p>
<p>Cortex-M4提供了一个用于处理异常的嵌套向量中断控制器，其中包括了中断</p>
<p>NVIC</p>
<ul>
<li>处理异常</li>
<li>中断配置、优先级和中断屏蔽</li>
</ul>
<p>在异常发生时，内核要跳转到异常处理程序；实现跳转需要知道异常处理程序的地址。为了解决这个问题，我们在内存中为每个异常类型设置一个固定的地址，将这个地址存在系统的RAM或者ROM中，这样统一存放的地址被称作异常向量表。</p>
<p>我们在stm32的启动代码中可以看到这个异常向量表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br></pre></td></tr></table></figure>
<p>上面的汇编代码与下图中的向量是一一对应的：</p>
<p><img src="/2022/03/05/16-32-26/image-20220801094303542.png" alt="image-20220801094303542" style="zoom: 50%;"></p>
<p><strong>复位和复位流程</strong></p>
<p>对于Cortex-M4来说，复位有三种方式：</p>
<ul>
<li>上电复位：复位所有部分——处理器、外设、调试支持部件</li>
<li>系统复位：复位——处理器、外设</li>
<li>处理器复位：复位——处理器</li>
</ul>
<p>复位过程：</p>
<p>复位后，程序开始执行之前，处理器会从存储器中读出头两个字，第一个字表示主栈指针的初始值（下方代码的第七行）第二个字表示复位处理起始地址的复位向量（下方代码的第八行），如下方代码的第15行所示，程序进入main函数就是先通过复位向量Reset_Handler跳转到15行来实现的。处理器读出前两个字后就会将这些数值赋给MSP和PC，来获得第一条指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                </span><br><span class="line">........</span><br><span class="line"></span><br><span class="line">; Reset handler</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">        IMPORT  SystemInit</span><br><span class="line">        IMPORT  __main</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br></pre></td></tr></table></figure>
<p>结合启动代码和 ”图2-3-8 Cortex-M4微处理器异常类型“ 可以理解下图：</p>
<figure>
<img src="/2022/03/05/16-32-26/image-20220801095422185.png" alt="image-20220801095422185"><figcaption aria-hidden="true">image-20220801095422185</figcaption>
</figure>
<h3 id="arm指令系统">ARM指令系统</h3>
<h4 id="arm指令系统简介">ARM指令系统简介</h4>
<p><strong>体系架构与指令系统</strong></p>
<table>
<thead>
<tr class="header">
<th>ARMv4</th>
<th>ARMv4T</th>
<th>ARMv5TE</th>
<th>ARMv6</th>
<th>ARMv7</th>
<th>ARMv8</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ARM8</td>
<td>ARM7TDMI</td>
<td>ARM7EJ</td>
<td>ARM1156T2</td>
<td>Cortex-M4</td>
<td>Cortex-A8</td>
</tr>
<tr class="even">
<td>ARM指令集</td>
<td>引入Thumb指令集</td>
<td>增加了增强型DSP指令</td>
<td>开始引入Thumb2</td>
<td>增强SIMD</td>
<td>引入A64指令集</td>
</tr>
</tbody>
</table>
<p>统一汇编语言：</p>
<p>不同指令集语法不同，因此ARM开发工具支持了统一汇编语言（UAL）</p>
<p>UAL统一了ARM指令集和Thumb指令集的语法，16位指令和32位指令可以无缝出现在代码中</p>
<p>Thumb2指令不需要分析这条指令是32位还是16位，编译器会按最简原则完成汇编；但是在UAL中可以用后缀 “.N</p>
<p>” 和 “.W” 来指定指令长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD R1,R2			;自动汇编成16位代码</span><br><span class="line">ADD R1,R2,0x8000	;有大于8位数范围立即数的指令汇编成32位代码</span><br><span class="line">ADD R1,R1,R2		;自动汇编成16位代码</span><br><span class="line">ADD.W R1,R1,R2		;原来是16位代码，指定汇编为32位代码</span><br></pre></td></tr></table></figure>
<p><strong>指令格式</strong></p>
<p>指令一般由操作码和操作数两部分组成</p>
<p>指令基本格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;opcode&gt;&#123;&lt;cond&gt;&#125;&#123;S&#125; &lt;Rd&gt;,&lt;Rn&gt;&#123;,&lt;shifter_operand&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>指令的二进制编码基本格式：</p>
<figure>
<img src="/2022/03/05/16-32-26/image-20220801105302596.png" alt="image-20220801105302596"><figcaption aria-hidden="true">image-20220801105302596</figcaption>
</figure>
<p>其中：</p>
<ul>
<li>opcode是指操作码</li>
<li>cond位于二进制编码中的最高四位，只有APSR中的条件码对应标志位满足指定条件时，带条件码的指令才被执行；cond指令内容见课本P53（PDF-P69）</li>
<li>APSR标志位的值可以被带有{S}的指令改变</li>
<li>Rn为第一源操作数，Rd为目的操作数</li>
<li>shifter_operand为第二源操作数</li>
</ul>
<p>ARM指令中没有条件转移指令，该效果的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADDEQ	R1,R2,R3	;ADD加法指令+cond：“EQ”</span><br><span class="line">					;若之前的操作是相等状态，则执行该ADD指令</span><br><span class="line">BGE	L1				;B跳转指令+GE后缀</span><br><span class="line">					;若之前的比较结果是有符号数大于或等于，即（N==V），则跳转至L1</span><br></pre></td></tr></table></figure>
<p><strong>shifter_operand 第二源操作数</strong></p>
<ul>
<li><p>立即数（#immed）</p>
<ul>
<li>立即数是一个32位无符号数，但不是所有32位无符号数都是立即数；因为我们在指令中只有12位来表示一个32位的立即数</li>
<li>立即数组成：8位立即数（immed_8）和4位循环移位（rotate_imm）
<ul>
<li>32位立即数 = immed_8 循环右移（2 × rotate_imm）位</li>
</ul></li>
</ul></li>
<li><p>寄存器方式（Rm）</p>
<ul>
<li><p>第二源操作数 shifter_operand 直接用ARM寄存器</p></li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD	R2,R3,R4</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>寄存器移位方式</p>
<ul>
<li><p>第一源操作数是寄存器Rm后，第二个操作数可以指定第一源操作数的移位方式和移位的位数</p></li>
<li><p>移位的位数可以是立即数#shift_imm或者寄存器Rs的数值，移位方式有九种</p></li>
<li><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV	R0,R2,LSL#3	;R2逻辑左移3位（相当于乘8）后，赋值给R0寄存器</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="arm指令的寻址方式">ARM指令的寻址方式</h4>
<p><strong>ARM指令有7种寻址方式</strong></p>
<ul>
<li>数据处理类指令：立即寻址、寄存器直接寻址、基址变址寻址</li>
<li>内存访问指令：寄存器间接寻址、基址寻址、多寄存器直接寻址</li>
<li>执行堆栈操作：堆栈寻址方式</li>
</ul>
<ol type="1">
<li><p>立即寻址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV	R0,	#0	;P0&lt;-9</span><br><span class="line">			;32位指令，immed_12格式立即数0传送到寄存器R0中</span><br></pre></td></tr></table></figure></li>
<li><p>寄存器直接寻址：寻址用的操作数位于CPU内部的寄存器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV	R1, R2	;R1&lt;-R2，寄存器R2的内容传到寄存器R1中</span><br></pre></td></tr></table></figure></li>
<li><p>寄存器移位寻址：寻址用的操作数由寄存器中的数值经过移位得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV	R0,	R1	ASR R2	;R0&lt;-（R1算数右移R2规定的位数）</span><br></pre></td></tr></table></figure></li>
<li><p>寄存器间接寻址：寄存器中存放的内容为操作数的内存地址而不是操作数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STR	R0, [R1]	;R0中的值传送到以R1的值作为地址的存储器中</span><br><span class="line">				;指令执行完成后R1中的值不变</span><br><span class="line">LDR R0, [R1]	;R1中的值作为地址，将内存中该地址单元的数据传送到R0</span><br><span class="line">				;指令执行完成后R1的值不变</span><br></pre></td></tr></table></figure></li>
<li><p>基址变址寻址：寄存器提供基准地址，这个基准地址与指令称为 “地址偏移量” 的数据相加形成操作数的有效地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR	R0,[R1,#4]		;R0&lt;-[R1+4],立即数前索引变址寻址</span><br><span class="line">LDR R0,[R1,#4]!		;R0&lt;-[R1+4],R1&lt;-R1+4，立即数前索引变址寻址，带更新</span><br><span class="line">LDR R0,[R1].#4		;R0&lt;-[R1],R1&lt;-R1+4，立即数后索引变址寻址，带更新</span><br><span class="line">LDR R0,[R1,R2]		;R0&lt;-[R1+R2]，寄存器前索引变址寻址</span><br></pre></td></tr></table></figure></li>
<li><p>多寄存器直接寻址：ARM架构中LDM（加载多个寄存器）和STM（存储多个寄存器）指令可以读写存储器中的多个连续数据传送到处理器的多个寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDMIA R0!,&#123;R1,R3-R5&#125;	;R1&lt;-[R0],R3&lt;-[R0+4],R4&lt;-[R0+8],R5&lt;-[R0+12],</span><br></pre></td></tr></table></figure>
<p>IA：每次读写后地址加4 DB：每次读写前地址减4</p></li>
</ol>
<h3 id="总线技术">总线技术</h3>
<h4 id="总线概述">总线概述</h4>
<p>早期总线是并行的多分枝共享式的结构，现代计算机采用的多是串行、点对点、交换式的结构</p>
<p>总线上的设备可以分为主设备和从设备：</p>
<ul>
<li>具有发起总线操作能力的设备成为总线的主设备（CPU、DMA）</li>
<li>不能发起总线操作，只能服从总线命令的称为从设备（存储器、IO设备）</li>
</ul>
<p>CPU操作总线进行读写操作，其流程为</p>
<ol type="1">
<li>CPU向地址线发送 ”从设备“ 的地址</li>
<li>CPU向控制线发送 ”读/写“ 的命令
<ul>
<li>读操作：CPU等待，然后从数据线上获取数据</li>
<li>写操作：CPU将数据放在数据线上，等待，从设备判断地址，然后根据控制线从数据线接收数据</li>
</ul></li>
</ol>
<p>主动发起总线操作的设备称为发起者，接收总线命令的设备称为操作对象</p>
<p>总线的性能指标</p>
<ol type="1">
<li>总线单位时间内最大的数据传输能力，称为总线的带宽（bandwidth）或者吞吐量（throughput）
<ul>
<li>总线吞吐量计算：总线数据宽度为<span class="math inline">\(\omega(B)\)</span>，时钟周期为<span class="math inline">\(T(s)\)</span>，则吞吐量最大的可能值为<span class="math inline">\(\omega/T(B/s)\)</span>。</li>
</ul></li>
<li>总线的灵活性和扩展性：越宽的总线越快的时钟越受限，扩展性越差；为了连接更多设备应使用桥接（bridge）</li>
</ol>
<p>总线的分类</p>
<table>
<thead>
<tr class="header">
<th>分类依据</th>
<th>类型</th>
<th>类型</th>
<th>类型</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>通信介质的共享方式</td>
<td>共享式总线</td>
<td>交换式总线</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>信息传递方式</td>
<td>并行总线</td>
<td>串行总线</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>操作时序</td>
<td>同步总线</td>
<td>半同步总线</td>
<td>异步总线</td>
<td></td>
</tr>
<tr class="even">
<td>应用的目的和范围</td>
<td>系统总线</td>
<td>局部总线</td>
<td>扩展总线</td>
<td>片内总线</td>
</tr>
</tbody>
</table>
<h4 id="总线时序和仲裁">总线时序和仲裁</h4>
<p>总线时序：</p>
<p>根据操作时序可以将总线分为：同步总线 半同步总线 异步总线</p>
<ol type="1">
<li>同步总线：
<ul>
<li>总线系统使用一个统一的时钟和固定的操作周期进行总线操作</li>
<li>优点：简单</li>
<li>缺点：高速设备可以跟上的时钟，低速设备可能跟不上</li>
</ul></li>
<li>半同步总线：
<ul>
<li>总线按照统一的时钟工作，但是总线周期并不完全固定，可以插入一个或多个称为等待周期的时钟周期</li>
<li>优点：高性能设别按照最快总线周期工作，低性能设别可以适当延长总线周期</li>
<li>实际使用中并行总线如ISA、PCI、AHB等都是半同步总线</li>
</ul></li>
<li>异步总线：</li>
</ol>
<ul>
<li>异步总线中没有统一的时钟，需要（如READY或ACK）等信号来控制总线操作</li>
</ul>
<p>总线可以分为共享式总线和交换式总线，其中共享式总线在使用中需要保证一个时刻只有一个主设备操作总线。</p>
<p>当冲突出现时，我们需要使用总线仲裁器：</p>
<ul>
<li>集中仲裁器：
<ul>
<li>总线主设备在操作总线前，需要先向总线仲裁器提出申请（request），并在收到许可（grant）后使用总线。</li>
<li>集中仲裁器收到多个申请时，按照某种优先级规则，选择一个申请者并向其发送许可</li>
</ul></li>
<li>分布式仲裁：
<ul>
<li>分布式仲裁要求每个主设备附带一个实现仲裁功能的组件</li>
<li>需要使用总线是由各仲裁组件交互信息，决定总线使用权</li>
</ul></li>
</ul>
<p>共享式总线4个阶段：申请、裁决、传送和结束</p>
<h4 id="串行总线">串行总线</h4>
<p>计算机性能的提升要求总线带宽或者说吞吐量的提升，这要求增加数据线的宽度OR总线的时钟频率。但是，当宽度提升到64位，时钟频率达到几百MHz时，提升空间就比较有限。</p>
<p>串行总线使用差分信号线传送信号，将各种信息逐个bit的在一对差分线上传输。</p>
<p>为了保证信号完整性，串行通信只能 “点对点” 的连接设备，当多个设备进行串口通信时，需要使用集线器（hub）或交换器（switch）芯片。</p>
<p>总线拓扑呈现以多个集线器为中心的星型结构的互联状态</p>
<p>串行通信通过并行使用多对差分线进行扩展，提高其带宽（吞吐量），总线信息的各字节被分配到不同的差分线，每对线之间不需要bit级别的时间对齐，因此扩展难度比并行总线低。</p>
<p>一种高速串行总线标准：PCIe</p>
<h4 id="总线标准化">总线标准化</h4>
<ul>
<li>IBM公司制定了免费的ISA总线标准</li>
<li>IBM制定的付费的MCA标准和Campaq制定的开放的EISA标准</li>
<li>Intel制定的PCI</li>
<li>后续就是USB、PCIe</li>
</ul>
<h4 id="扩展总线">扩展总线</h4>
<p>当越来越多的设备接入总线时，单一的总线开始难以满足计算机内部高性能和多样性的要求。</p>
<p>因此出现了总线的层次结构，靠近CPU的总线性能更强，性能要求较低的外围设备采用低性能总线接入设备</p>
<p>不同技术的总线之间采用桥接（bridge）芯片连接并转发总线操作</p>
<p>外设可以通过外部总线（external bus）或扩展总线（extended bus）进而通过总线桥路接入到高性能的系统总线</p>
<p>嵌入式系统中的扩展总线，以stm32f407为例</p>
<ul>
<li>FSMC是并行总线，类似于XT总线，面向一些SRAM或者Flash使用</li>
<li>串行总线包括SPI、I2C和CAN</li>
</ul>
<p>总线中的地址的概念</p>
<ul>
<li>扩展总线的 “地址”：设备编号</li>
<li>系统总线的 ”地址“：识别存储单元或者IO设备中的寄存器</li>
</ul>
<p>SPI/I2C、USB、SCSI、CAN等总线协议的介绍</p>
<h4 id="arm总线">ARM总线</h4>
<p>SoC上的总线：</p>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>双轮自平衡小车制作指南</title>
    <url>/2022/02/25/19-20-54/</url>
    <content><![CDATA[<h1 id="双轮自平衡小车制作指南">双轮自平衡小车制作指南</h1>
<h3 id="整体介绍">整体介绍</h3>
<p>这将会是我制作自平衡小车的一个开始，本文的目标在于设计一个简单的自平衡小车，实现自平衡站立和行进。作品将依托于开源硬件平台Arduino，使用C语言进行程序开发。</p>
<p>双轮小车与四轮小车不同，双轮小车本身是一个欠稳定系统。将一个双轮小车直立着放在地面上时，小车难以站立，而是会向前或者向后倾倒。若要使小车维持稳定站立，我们需要引入一个控制系统。当小车将要向前倾倒时，控制电机带动轮胎向前移动，便阻止了小车前倾；同理可知小车后倾时可以向后移动阻止后倾，从而实现小车的平衡。</p>
<p>为了实现上述的控制，首先我们需要实时获取小车的“姿态”，即小车向前倾倒还是向后倾倒，以及倾倒的程度（一般使用角度来表示这个倾倒的程度）。“姿态”的获取需要使用可以测量加速度和角加速度的传感器，这种传感器被称作惯性测量单元 (IMU)，惯性测量单元获取的数据可以帮助我们获取小车“姿态”。</p>
<p>第二步是依据小车的“姿态”，控制电机活动，具体的控制内容包括电机的转速和转向。</p>
<h3 id="材料准备">材料准备</h3>
<p>实现一个最基础的平衡小车需要以下组件：</p>
<ul>
<li>微控制器：Arduino Nano 开发板</li>
<li>惯性测量单元 (IMU) ：MPU6050模块</li>
<li>电机：
<ul>
<li>N20减速直流电机（带霍尔编码器，详细参数见后文）</li>
<li>双母头电机端子线（型号：ZH1.5MM）</li>
<li>端子线贴片插座（型号：ZH1.5MM）</li>
</ul></li>
<li>电源：
<ul>
<li>7.4V锂电池</li>
<li>AMS1117降压电源模块（5V）</li>
<li>USB-Typec母头（带PCB板）</li>
</ul></li>
<li>外壳：3D打印外壳</li>
<li>电路板：立创EDA设计原理图和PCB板</li>
<li>其他：
<ul>
<li>N20减速直流电机配套固定架和D字轴轮胎</li>
<li>螺丝螺母</li>
<li>面包板和杜邦线（学习和测试时使用，实际小车中不使用）</li>
<li></li>
</ul></li>
</ul>
<h3 id="arduino-nano-介绍">Arduino Nano 介绍</h3>
<h4 id="初始arduino">初始Arduino</h4>
<p>Arduino是一款开源的嵌入式硬件开发平台，不仅包括了众多型号的开发板，而且包括了一个集成开发环境（IDE）辅助开发者编程，烧录和通信。Arduino本身提供了许多标准库，这些库的封装程度高，因此用户不必去关心寄存器配置而是可以通过库函数的调用来实现各种功能。Arduino作为一个受欢迎的开源平台，在互联网上可以找到大量的资料和例程进行学习。除了上文提到的标准库之外，Arduino还有各种用户针对不同外设写的库，可以在Arduino中轻松的获取和使用。Arduino本身还提供有图形化编程选项，即便是不会编程的非专业人士也可以快速上手。Arduino帮助我们从嵌入式硬件开发底层的细节中挣脱出来，把注意力放在控制本身这件事上。而且，鉴于本文的希望依托于一个可靠的开源平台且尽可能构造一个简单的自平衡小车，因此Arduino平台成为了我的首选。</p>
<p>进行电子设计时，我们首先要确定控制核心的选择。在这里我们选择了Arduino里面的Nano开发板进行开发。下图是Nano的模型图/引脚图。</p>
<p><img src="/2022/02/25/19-20-54/image-20220226162323982.png" alt="image-20220226162323982" style="zoom:67%;"></p>
<p>第一次接触硬件设计的人可能看到这张图会感到很复杂且不知所措。因此接下来我们将会通过一些实验来认识Nano。在结束这一章时再次回来看这张图片，或许你就会感到亲切了。</p>
<h4 id="实验1控制">实验1——控制</h4>
<p>Ardino是一块开源的嵌入式硬件平台，这句话对于初学者来说可能会是一个巨大的困扰，因为嵌入式是何意义，向初学者“正确”的解释清楚这件事并不容易。但是，不理解这段话并不影响我们去使用Arduino Nano来进行一些小开发。我们只需要牢牢记住一件事，那就是Nano是一个微控制器，微就是微小的意思，Nano就是个小型的控制器。控制器就是用来做控制的。接下来我们先从一个简单的实验入手，使用这个控制器去做一些控制。</p>
<p>首先我们先理解控制的概念，我们会希望控制什么呢？可能有人说，控制机器人！或者是控制一个遥控飞机飞行！是的，这些是控制，但是这种难度的控制并不适合一个初学者去学习。其实，控制无处不在，比如，我们按下开关，就可以打开灯，开关就是一个控制器，控制着灯的亮灭。现在，让我们把开关换成Nano，用它来控制一个LED小灯的亮灭。</p>
<p>实验需要准备：</p>
<ul>
<li>Arduino Nano开发板（焊接好排针），Arduino IDE，Micro USB接口的数据线</li>
<li>面包板和杜邦线（双公头）</li>
<li>LED灯和电阻</li>
</ul>
<p>首先，按照下图的方法连接电路。</p>
<p>然后打开Arduino IDE：用数据线将Nano与电脑相连接，选择相应的型号的开发板和端口，在编辑器中写入代码，然后点击编译并烧录，具体操作如下图：</p>
<p>图中代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LED = <span class="number">7</span>;               <span class="comment">// 给D7引脚重命名为LED</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  pinMode(LED, OUTPUT);        <span class="comment">// 将名为LED的引脚设置为（数字）输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  digitalWrite(LED, HIGH);       <span class="comment">// 向LED引脚进行写入“高”，表示输出高电平</span></span><br><span class="line">  delay(<span class="number">1000</span>);                       <span class="comment">// 延时1000ms即1秒</span></span><br><span class="line">  digitalWrite(LED, LOW);        <span class="comment">// 向LED引脚进行写入“低”，表示输出低电平</span></span><br><span class="line">  delay(<span class="number">1000</span>);                       <span class="comment">// 延时1000ms即1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成上述操作后，就能看到LED亮一秒，灭一秒了。</p>
<p>使用模拟量（analogWrite(Pin,Value)函数的本质是PWM驱动）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> byte GND = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> byte LED = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  pinMode(GND, OUTPUT);</span><br><span class="line">  pinMode(LED, OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  analogWrite(GND, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">250</span>; i = i + <span class="number">50</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    analogWrite(LED, i);</span><br><span class="line">    delay(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  analogWrite(LED, <span class="number">0</span>);</span><br><span class="line">  delay(<span class="number">1500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实验2通信">实验2——通信</h4>
<h4 id="实验3">实验3——</h4>
<h3 id="电机基础">电机基础</h3>
<h4 id="了解直流电机">了解直流电机</h4>
<p>学习和使用电机之前，我们首先要对电机的基本原理有一定的认识。最基础的电机的是我们在中学阶段就学习过的直流电机。直流电机是一个放在磁场中的导线转子，当有直流电流过导线转子时，转子便受力旋转。直流电机通入直流后转子转速很快，但是其扭矩——或者说转动的力度，很小。但是为了能带动轮胎转动实现小车行进，我们需要转子拥有较大的扭矩。于是我们有了减速直流电机。减速直流电机相比于直流电机多了一个减速箱。减速箱内部有许多齿轮，转子转动带动减速箱内部的齿轮转动，这一过程将导致转轴转速降低而扭矩提高，因此我们称其为减速电机。减速电机中最重要的参数是减速比。减速比的大小等于减速箱外的转轴转一圈时直流电机转子转过的圈数。我们使用的N20电机就是一个减速直流电机。</p>
<p>驱动直流电机的方法非常简单，只需要在电机的两个端子上接上正负电压，电机便开始转动。若是交换两端子上的电压，则电机会沿于之前相反的方向转动。对于装有编码器的N20电机来说，标注为M1和M2的端子为直流电机的端子。</p>
<p>为了更全面的理解电机，我们应该了解另一种常见的电机类型——步进电机，以便在其他时候遇到的话不至于与现在所学的电机相混淆。步进电机是一种可以顾名思义的东西，只不过大多数人在最开始想到的含义可以不太正确。步进电机不是专指用来前进或者行进的电机，毕竟很显然的是，只要外界轮子，直流电机也可以前进。步进电机这个名字来源于电机的内部构造，转子在脉冲信号输入下发生一步一步的转动，这种一步一步的转动的效果有点像钟表的秒针，每一秒在表盘上走一小步，一步一步的旋转，最终一分钟后旋转了一圈。如果我们加快这一过程，这样电机就不再是做一顿一顿的运动了，而是一个连续不断的快速的旋转。</p>
<p>步进电机只是转子旋转的原理和直流电机不同，但是依然可以在步进电机外接入减速箱。这两个电机的定语是两种平行的分类方式，这点不要混淆。</p>
<p>我们回到上文的直流电机，如果想要了解更多关于步进电机的知识，可以在搜索引擎上搜索“步进电机”，在这里我只是做简单的介绍。</p>
<p>直流电机有两个端子，施加正负电压即可驱动马达转动，交换正负电压就可以改变马达转向。前者非常简单，只需要提供一个外接直流电源，或者使用Nano的5V引脚和GND引脚就可以驱动电机转动，手动改变电流源极性或者使用微控制器调整输出电压信号都可以改变马达转向。但是如开篇我们所说的，我们需要同时控制电机转速和转向。为此，我们需要学习使用一种要脉冲宽度调制（Pulse-width modulation）的技术来控制电机的转速。下面我们就来详细地了解一下PWM技术，并且使用Nano来控制电机的转速和转向。</p>
<h4 id="脉冲宽度调制pwm">脉冲宽度调制（PWM）</h4>
<h5 id="pwm简介">PWM简介*</h5>
<p>TODO</p>
<h5 id="在arduino中使用pwm">在Arduino中使用PWM</h5>
<p>TODO</p>
<h4 id="编码器">编码器</h4>
<p>TODO</p>
<h3 id="mpu6050">MPU6050</h3>
<h4 id="原始数据">原始数据</h4>
<p>双轮自平衡小车使用的惯性测量单元 (IMU) 是MPU6050，包含一个三轴的加速度传感器和一个三轴的陀螺仪。加速度传感器可以获取运动的物体在三个坐标轴方向上的加速度，陀螺仪可以获取绕坐标轴旋转的物体的角加速度。</p>
<p>对于双轮自平衡小车，我们需要其在一个坐标轴方向上的角度信息。从小车侧面看，仅有可能向左右两个方向倾倒，而不会向前后倾倒，并且小车的静止和行进都是在地面这个水平面进行，因此不需要关心Z轴上的变化。因此，设计一个自平衡小车，我们只需要关注其绕X轴或是绕Y轴的角度（取决于模块的放置方式）问题即可。</p>
<p>在本次设计中，我将按照下图的方式放置MPU6050，因此我们关注的是绕X轴的角度变化。</p>
<figure>
<img src="/2022/02/25/19-20-54/照片预览_2022-02-27-16459370460521.svg" alt="照片预览_2022-02-27"><figcaption aria-hidden="true">照片预览_2022-02-27</figcaption>
</figure>
<p>为了实时获取小车的角度信息，我们需要同时使用加速度传感器和陀螺仪。单独测试MPU6050模块时，可以将将MPU6050模块的VCC引脚接Nano的5V引脚，MPU6050模块的GND引脚接Nano的GND引脚。接入电源后模块便能实时产生六个数据（实际数据比六个多，还包括温度数据，这里不进行介绍），我们使用<span class="math inline">\(I^2C\)</span>通信方式进行MPU6050模块和Nano之间的通信。进行<span class="math inline">\(I^2C\)</span>通信时，首先要将MPU6050模块的SCL引脚与Nano的SCL引脚相连，MPU6050模块的SDA引脚与Nano的SDA引脚相连。但是，这里存在一个问题是，在Nano的PCB板上我们找不到名为SCL与SDA的引脚。这时候我们就要回到文章开头的那张Nano引脚图了。</p>
<p><img src="/2022/02/25/19-20-54/image-20220226162741791.png" alt="image-20220226162741791" style="zoom: 50%;"></p>
<p>在图中我们可以看到Nano的A4引脚外面写着SDA，A5引脚外写着SCL，其实这是表示引脚的公用，即A4引脚既能做一个单纯的模拟引脚使用，也可以作为SDA引脚使用。因此，为了将MPU6050中产生的数据导入到Nano中，我们MPU6050模块的SDA引脚与Nano的A4引脚相连，SCL与A5相连。连接好之后，我们就可以通过代码来进行程序读取了。</p>
<p>使用Arduino进行<span class="math inline">\(I^2C\)</span>通信一般需要用到“Wire.h”这个标准库，使用“Wire.h”我们首先要将它包含进来。使用时，首先要进行初始化，与串口通信相似。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Wire.begin();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想要读取MPU6050中的数据，我们需要知道其地址，然后进行数据传输，具体的代码操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>; <span class="comment">// MPU6050 I2C 地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Wire.begin();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//配置MPU6050的加速度计模块</span></span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x1C</span>);</span><br><span class="line">  Wire.write(<span class="number">0x00</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们本阶段的目标在于读取MPU6050中的原始数据，包括三个坐标方向上的加速度信息和三个方向上的角加速度信息。为了存储这些读取来的数据，我们设置了6个浮点数类型的变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> AccX, AccY, AccZ;</span><br><span class="line"><span class="type">float</span> GyroX, GyroY, GyroZ;</span><br></pre></td></tr></table></figure>
<p>来存储数据，之所以是变量数据类型而不是数组，因为这6个信息是实时测量值，在loop()这个函数中每一列都会获取当下的这六个数据，并立即进行处理，通过数学运算获取实时的角度信息，而下一刻的角度信息则有下一刻的六个数据计算得来。loop()函数中实时获取六个数据的方法如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//读取加速度的值：</span></span><br><span class="line">  <span class="comment">//开启加速度计模块</span></span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x3B</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//从MPU6050中读取加速度数据并转化为g为单位的通用数据</span></span><br><span class="line">  AccX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br><span class="line">  AccY = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br><span class="line">  AccZ = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//读取角加速度的值：</span></span><br><span class="line">  <span class="comment">//开启角加速度模块</span></span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x43</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//从MPU6050中读取角加速度数据并转化为g为单位的通用数据</span></span><br><span class="line">  GyroX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">131.0</span>;</span><br><span class="line">  GyroY = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">131.0</span>;</span><br><span class="line">  GyroZ = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">131.0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>代码中，以</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AccX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br></pre></td></tr></table></figure>
<p>为例，在MPU6050中直接读取的数据为<span class="math inline">\(AccX*16384.0\)</span>，之所以这里要将<span class="math inline">\(16384.0\)</span>这个数字除掉，其实是在进行单位转换，将加速度的单位转化为<span class="math inline">\(g\)</span>，这里的<span class="math inline">\(g=9.8\)</span>其实就是重力加速度。这里之所以将加速度的单位统一为重力加速度，是因为从原理上看，加速度计测量加速度原理就是以重力加速度为参考求出来的，所以一般将加速度的单位设为重力加速度。</p>
<p>使用上述代码</p>
<h4 id="数字滤波器">数字滤波器</h4>
<p>TODO</p>
<p>一阶互补滤波器（仅roll值）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>; <span class="comment">// MPU6050 I2C address</span></span><br><span class="line"><span class="type">float</span> AccX, AccY, AccZ;</span><br><span class="line"><span class="type">float</span> GyroX;</span><br><span class="line"><span class="type">float</span> accAngleX, gyroAngleX;</span><br><span class="line"><span class="type">float</span> roll;</span><br><span class="line"><span class="type">float</span> elapsedTime, currentTime, previousTime;</span><br><span class="line"><span class="type">float</span> AccErrorX = <span class="number">-1.5</span>,GyroErrorX = <span class="number">-0.25</span>,rollError = <span class="number">-3.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">19200</span>);</span><br><span class="line">  Wire.begin();                      <span class="comment">// Initialize comunication</span></span><br><span class="line">  Wire.beginTransmission(MPU);       <span class="comment">// Start communication with MPU6050 // MPU=0x68</span></span><br><span class="line">  Wire.write(<span class="number">0x6B</span>);                  <span class="comment">// Talk to the register 6B</span></span><br><span class="line">  Wire.write(<span class="number">0x00</span>);                  <span class="comment">// Make reset - place a 0 into the 6B register</span></span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);        <span class="comment">//end the transmission</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// === Read acceleromter data === //</span></span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x3B</span>); </span><br><span class="line">  Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>); </span><br><span class="line">    </span><br><span class="line">  AccX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br><span class="line">  AccY = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>; <span class="comment">// Y-axis value</span></span><br><span class="line">  AccZ = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>; <span class="comment">// Z-axis value</span></span><br><span class="line">  accAngleX = (<span class="built_in">atan</span>(AccY / <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(AccX, <span class="number">2</span>) + <span class="built_in">pow</span>(AccZ, <span class="number">2</span>))) * <span class="number">180</span> / PI) - AccErrorX;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// === Read gyroscope data === //</span></span><br><span class="line">  previousTime = currentTime;</span><br><span class="line">  currentTime = millis();</span><br><span class="line">  elapsedTime = (currentTime - previousTime) / <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x43</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>); </span><br><span class="line">    </span><br><span class="line">  GyroX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">131.0</span>;</span><br><span class="line">  GyroX = GyroX - GyroErrorX;</span><br><span class="line">  gyroAngleX = gyroAngleX + GyroX * elapsedTime;</span><br><span class="line">  </span><br><span class="line">  roll = <span class="number">0.96</span> * gyroAngleX + <span class="number">0.04</span> * accAngleX -rollError;</span><br><span class="line">  Serial.println(roll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>卡尔曼滤波器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">kalman</span><span class="params">(<span class="type">float</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> p = <span class="number">5</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> q = <span class="number">0.2</span>; <span class="comment">//important</span></span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> r = <span class="number">1</span>;   <span class="comment">//important</span></span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> kg;</span><br><span class="line"></span><br><span class="line">    p = p + q;</span><br><span class="line">    kg = p / (p + r);</span><br><span class="line">    x = x + kg * (y - x);</span><br><span class="line">    p = (<span class="number">1</span> - kg) * p;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******卡尔曼参数************</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> Q_angle = <span class="number">0.001</span>;<span class="comment">//角度数据置信度</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> Q_gyro  = <span class="number">0.005</span>;<span class="comment">//角速度数据置信度</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> R_angle = <span class="number">0.5</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> dt  = <span class="number">0.004</span>;    <span class="comment">//dt为kalman滤波器采样时间;</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>  C_0 = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> Q_bias, Angle_err;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> PCt_0, PCt_1, E;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> K_0, K_1, t_0, t_1;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> Pdot[<span class="number">4</span>]  = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> PP[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Angle;</span><br><span class="line"><span class="type">float</span> Gyro_y;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>; <span class="comment">// MPU6050 I2C address</span></span><br><span class="line"><span class="type">float</span> AccX, AccY, AccZ;</span><br><span class="line"><span class="type">float</span> GyroX, GyroY, GyroZ;</span><br><span class="line"><span class="type">float</span> accAngleX, accAngleY, gyroAngleX, gyroAngleY, gyroAngleZ;</span><br><span class="line"><span class="type">float</span> roll, pitch, yaw;</span><br><span class="line"><span class="type">float</span> AccErrorX, AccErrorY, GyroErrorX, GyroErrorY, GyroErrorZ;</span><br><span class="line"><span class="type">float</span> elapsedTime, currentTime, previousTime;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> atan_coeff  = <span class="number">57.3f</span>;   <span class="comment">//arctan转换角度系数</span></span><br><span class="line"><span class="type">float</span> angle_a,angle_g;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> gro_zero  = <span class="number">24.05f</span>;    <span class="comment">//角速度为0时的校准值</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> gro_coeff = <span class="number">-0.0645f</span>;  <span class="comment">//角速度对应角度变化系数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">float</span> Angle, Gyro_y;         <span class="comment">//kalman融合后得出的最优角度和角速度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ave_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Kalman_Filter</span><span class="params">(<span class="type">float</span> Accel, <span class="type">float</span> Gyro)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_IMU_error</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">19200</span>);</span><br><span class="line">  Wire.begin();                      <span class="comment">// Initialize comunication</span></span><br><span class="line">  Wire.beginTransmission(MPU);       <span class="comment">// Start communication with MPU6050 // MPU=0x68</span></span><br><span class="line">  Wire.write(<span class="number">0x6B</span>);                  <span class="comment">// Talk to the register 6B</span></span><br><span class="line">  Wire.write(<span class="number">0x00</span>);                  <span class="comment">// Make reset - place a 0 into the 6B register</span></span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);        <span class="comment">//end the transmission</span></span><br><span class="line">  calculate_IMU_error();</span><br><span class="line">  delay(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// === Read acceleromter data === //</span></span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x3B</span>); </span><br><span class="line">  Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>); </span><br><span class="line">    </span><br><span class="line">  AccX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>;</span><br><span class="line">  AccY = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>; <span class="comment">// Y-axis value</span></span><br><span class="line">  AccZ = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span>; <span class="comment">// Z-axis value</span></span><br><span class="line">  accAngleX = (<span class="built_in">atan</span>(AccY / <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(AccX, <span class="number">2</span>) + <span class="built_in">pow</span>(AccZ, <span class="number">2</span>))) * <span class="number">180</span> / PI) - AccErrorX;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// === Read gyroscope data === //</span></span><br><span class="line">  previousTime = currentTime;</span><br><span class="line">  currentTime = millis();</span><br><span class="line">  elapsedTime = (currentTime - previousTime) / <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x43</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>); </span><br><span class="line">    </span><br><span class="line">  GyroX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">131.0</span>;</span><br><span class="line">  GyroX = GyroX - GyroErrorX;</span><br><span class="line">  gyroAngleX = gyroAngleX + GyroX * elapsedTime;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//angle_a = (float)atan((float)AccX/AccZ)*atan_coeff;</span></span><br><span class="line">  angle_a = accAngleX; </span><br><span class="line">  angle_g = gyroAngleX;</span><br><span class="line">  Kalman_Filter(angle_a, angle_g);</span><br><span class="line">  Serial.println(Angle);</span><br><span class="line">  <span class="comment">//Serial.println(Gyro_y);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">calculate_IMU_error</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// We can call this funtion in the setup section to calculate the accelerometer and gyro data error. From here we will get the error values used in the above equations printed on the Serial Monitor.</span></span><br><span class="line">  <span class="comment">// Note that we should place the IMU flat in order to get the proper values, so that we then can the correct values</span></span><br><span class="line">  <span class="comment">// Read accelerometer values 200 times</span></span><br><span class="line">  <span class="keyword">while</span> (ave_num &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    Wire.beginTransmission(MPU);</span><br><span class="line">    Wire.write(<span class="number">0x3B</span>);</span><br><span class="line">    Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">    Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>);</span><br><span class="line">    AccX = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span> ;</span><br><span class="line">    AccY = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span> ;</span><br><span class="line">    AccZ = (Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read()) / <span class="number">16384.0</span> ;</span><br><span class="line">    <span class="comment">// Sum all readings</span></span><br><span class="line">    AccErrorX = AccErrorX + ((<span class="built_in">atan</span>((AccY) / <span class="built_in">sqrt</span>(<span class="built_in">pow</span>((AccX), <span class="number">2</span>) + <span class="built_in">pow</span>((AccZ), <span class="number">2</span>))) * <span class="number">180</span> / PI));</span><br><span class="line">    AccErrorY = AccErrorY + ((<span class="built_in">atan</span>(<span class="number">-1</span> * (AccX) / <span class="built_in">sqrt</span>(<span class="built_in">pow</span>((AccY), <span class="number">2</span>) + <span class="built_in">pow</span>((AccZ), <span class="number">2</span>))) * <span class="number">180</span> / PI));</span><br><span class="line">    ave_num++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Divide the sum by 200 to get the error value</span></span><br><span class="line">  AccErrorX = AccErrorX / <span class="number">200</span>;</span><br><span class="line">  AccErrorY = AccErrorY / <span class="number">200</span>;</span><br><span class="line">  ave_num = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Read gyro values 200 times</span></span><br><span class="line">  <span class="keyword">while</span> (ave_num &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    Wire.beginTransmission(MPU);</span><br><span class="line">    Wire.write(<span class="number">0x43</span>);</span><br><span class="line">    Wire.endTransmission(<span class="literal">false</span>);</span><br><span class="line">    Wire.requestFrom(MPU, <span class="number">6</span>, <span class="literal">true</span>);</span><br><span class="line">    GyroX = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();</span><br><span class="line">    GyroY = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();</span><br><span class="line">    GyroZ = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();</span><br><span class="line">    <span class="comment">// Sum all readings</span></span><br><span class="line">    GyroErrorX = GyroErrorX + (GyroX / <span class="number">131.0</span>);</span><br><span class="line">    GyroErrorY = GyroErrorY + (GyroY / <span class="number">131.0</span>);</span><br><span class="line">    GyroErrorZ = GyroErrorZ + (GyroZ / <span class="number">131.0</span>);</span><br><span class="line">    ave_num++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Divide the sum by 200 to get the error value</span></span><br><span class="line">  GyroErrorX = GyroErrorX / <span class="number">200</span>;</span><br><span class="line">  GyroErrorY = GyroErrorY / <span class="number">200</span>;</span><br><span class="line">  GyroErrorZ = GyroErrorZ / <span class="number">200</span>;</span><br><span class="line">  <span class="comment">// Print the error values on the Serial Monitor</span></span><br><span class="line"><span class="comment">//  Serial.print(&quot;AccErrorX: &quot;);</span></span><br><span class="line"><span class="comment">//  Serial.println(AccErrorX);</span></span><br><span class="line"><span class="comment">//  Serial.print(&quot;AccErrorY: &quot;);</span></span><br><span class="line"><span class="comment">//  Serial.println(AccErrorY);</span></span><br><span class="line"><span class="comment">//  Serial.print(&quot;GyroErrorX: &quot;);</span></span><br><span class="line"><span class="comment">//  Serial.println(GyroErrorX);</span></span><br><span class="line"><span class="comment">//  Serial.print(&quot;GyroErrorY: &quot;);</span></span><br><span class="line"><span class="comment">//  Serial.println(GyroErrorY);</span></span><br><span class="line"><span class="comment">//  Serial.print(&quot;GyroErrorZ: &quot;);</span></span><br><span class="line"><span class="comment">//  Serial.println(GyroErrorZ);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Kalman_Filter</span><span class="params">(<span class="type">float</span> Accel, <span class="type">float</span> Gyro)</span></span><br><span class="line">&#123;</span><br><span class="line">    Angle += (Gyro - Q_bias) * dt; <span class="comment">//先验估计</span></span><br><span class="line">    Angle_err = Accel - Angle;     <span class="comment">//zk-先验估计</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pk-先验估计误差协方差的微分</span></span><br><span class="line">    Pdot[<span class="number">0</span>] = Q_angle - PP[<span class="number">0</span>][<span class="number">1</span>] - PP[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    Pdot[<span class="number">1</span>] = -PP[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    Pdot[<span class="number">2</span>] = -PP[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    Pdot[<span class="number">3</span>] =  Q_gyro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pk-先验估计误差协方差微分的积分=先验估计误差协方差</span></span><br><span class="line">    PP[<span class="number">0</span>][<span class="number">0</span>] += Pdot[<span class="number">0</span>] * dt;</span><br><span class="line">    PP[<span class="number">0</span>][<span class="number">1</span>] += Pdot[<span class="number">1</span>] * dt;</span><br><span class="line">    PP[<span class="number">1</span>][<span class="number">0</span>] += Pdot[<span class="number">2</span>] * dt;</span><br><span class="line">    PP[<span class="number">1</span>][<span class="number">1</span>] += Pdot[<span class="number">3</span>] * dt;</span><br><span class="line"></span><br><span class="line">    PCt_0 = C_0 * PP[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    PCt_1 = C_0 * PP[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    E = R_angle + C_0 * PCt_0;</span><br><span class="line"></span><br><span class="line">    K_0 = PCt_0 / E;</span><br><span class="line">    K_1 = PCt_1 / E;</span><br><span class="line"></span><br><span class="line">    t_0 = PCt_0;</span><br><span class="line">    t_1 = C_0 * PP[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后验估计误差协方差</span></span><br><span class="line">    PP[<span class="number">0</span>][<span class="number">0</span>] -= K_0 * t_0;</span><br><span class="line">    PP[<span class="number">0</span>][<span class="number">1</span>] -= K_0 * t_1;</span><br><span class="line">    PP[<span class="number">1</span>][<span class="number">0</span>] -= K_1 * t_0;</span><br><span class="line">    PP[<span class="number">1</span>][<span class="number">1</span>] -= K_1 * t_1;</span><br><span class="line"></span><br><span class="line">    Angle    += K_0 * Angle_err;   <span class="comment">//后验估计  (最优角度)</span></span><br><span class="line">    Q_bias   += K_1 * Angle_err;   <span class="comment">//后验估计</span></span><br><span class="line">    Gyro_y   =  Gyro - Q_bias;     <span class="comment">//输出值(后验估计)的微分=角速度  (最优角速度)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="pid控制">PID控制</h3>
<p>TODO</p>
<h3 id="d建模制作小车外壳">3D建模——制作小车外壳</h3>
<p>TODO</p>
<h3 id="pcb设计制作小车电路板">PCB设计——制作小车电路板</h3>
<p>与使用面包板进行测试不同，绘制PCB板时使用的连线在打印PCB后就会固定下来，因此我们必须在编程时调用相应的引脚，这样才不会出错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HC06</span></span><br><span class="line"><span class="comment">//TX-&gt;Nano_Rx</span></span><br><span class="line"><span class="comment">//RX-&gt;Nano_TX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//左电机——6个引脚</span></span><br><span class="line"><span class="type">const</span> byte L1_M1 = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//L2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte L3_C1 = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> byte L4_C2 = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//L5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte L6_M2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右电机——6个引脚</span></span><br><span class="line"><span class="type">const</span> byte R1_M1 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//R2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte R3_C1 = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> byte R4_C2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//R5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte R6_M2 = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MPU6050</span></span><br><span class="line"><span class="comment">//SCL-&gt;Nano_A5</span></span><br><span class="line"><span class="comment">//SDA-&gt;Nano_A4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>; <span class="comment">// MPU6050 I2C 地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MPU6050 仅计算Roll时需要的变量如下</span></span><br><span class="line"><span class="type">float</span> AccX, AccY, AccZ;</span><br><span class="line"><span class="type">float</span> GyroX;</span><br><span class="line"><span class="type">float</span> accAngleX, gyroAngleX;</span><br><span class="line"><span class="type">float</span> roll;</span><br><span class="line"><span class="type">float</span> elapsedTime, currentTime, previousTime;</span><br><span class="line"><span class="type">float</span> AccErrorX,GyroErrorX,rollError;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> byte L1_M1 = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//L2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte L3_C1 = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> byte L4_C2 = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//L5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte L6_M2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> byte R1_M1 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//R2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte R3_C1 = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> byte R4_C2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//R5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte R6_M2 = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span>&#123;</span><br><span class="line">  pinMode(L1_M1,OUTPUT);</span><br><span class="line">  pinMode(L6_M2,OUTPUT);</span><br><span class="line"></span><br><span class="line">  pinMode(R1_M1,OUTPUT);</span><br><span class="line">  pinMode(R6_M2,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//小车直行代码</span></span><br><span class="line">  analogWrite(L1_M1,<span class="number">255</span>);</span><br><span class="line">  analogWrite(L6_M2,<span class="number">0</span>);</span><br><span class="line">  analogWrite(R1_M1,<span class="number">0</span>);</span><br><span class="line">  analogWrite(R6_M2,<span class="number">255</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记录一个可以使用的卡尔曼滤波器，直接使用下面的代码可以使用串口绘图器绘制出Roll的角度变化，打开绘图器时Roll的值记作0，然后表现为相对偏移，这个滤波器效果还不错，至少比那个一阶互补滤波器强，但是感觉相应速度不是很快。</p>
<p>主函数：</p>
<p>Kalman Filter</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连线方法</span></span><br><span class="line"><span class="comment">// MPU-&gt;UNO</span></span><br><span class="line"><span class="comment">// VCC-&gt;VCC</span></span><br><span class="line"><span class="comment">// GND-&gt;GND</span></span><br><span class="line"><span class="comment">// SCL-&gt;A5</span></span><br><span class="line"><span class="comment">// SDA-&gt;A4</span></span><br><span class="line"><span class="comment">// INT-&gt;2 (Optional)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kalman.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> fRad2Deg = <span class="number">57.295779513f</span>; <span class="comment">//将弧度转为角度的乘数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>;           <span class="comment">// MPU-6050的I2C地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nValCnt = <span class="number">7</span>;          <span class="comment">//一次读取寄存器的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nCalibTimes = <span class="number">1000</span>; <span class="comment">//校准时读数的次数</span></span><br><span class="line"><span class="type">int</span> calibData[nValCnt];       <span class="comment">//校准数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nLastTime = <span class="number">0</span>; <span class="comment">//上一次读数的时间</span></span><br><span class="line"><span class="type">float</span> fLastRoll = <span class="number">0.0f</span>;      <span class="comment">//上一次滤波得到的Roll角</span></span><br><span class="line">Kalman kalmanRoll;           <span class="comment">// Roll角滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);   <span class="comment">//初始化串口，指定波特率</span></span><br><span class="line">  Wire.begin();         <span class="comment">//初始化Wire库</span></span><br><span class="line">  WriteMPUReg(<span class="number">0x6B</span>, <span class="number">0</span>); <span class="comment">//启动MPU6050设备</span></span><br><span class="line"></span><br><span class="line">  Calibration();        <span class="comment">//执行校准</span></span><br><span class="line">  nLastTime = micros(); <span class="comment">//记录当前时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//向串口打印输出Roll角和Pitch角，运行时在Arduino的串口监视器中查看</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Roll:&quot;</span>);</span><br><span class="line">  Serial.println(GetValue());</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> readouts[nValCnt];</span><br><span class="line">  ReadAccGyr(readouts); <span class="comment">//读出测量值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> realVals[<span class="number">7</span>];</span><br><span class="line">  Rectify(readouts, realVals); <span class="comment">//根据校准的偏移量进行纠正</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算加速度向量的模长，均以g为单位</span></span><br><span class="line">  <span class="type">float</span> fNorm = <span class="built_in">sqrt</span>(realVals[<span class="number">0</span>] * realVals[<span class="number">0</span>] + realVals[<span class="number">1</span>] * realVals[<span class="number">1</span>] + realVals[<span class="number">2</span>] * realVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fRoll = GetRoll(realVals, fNorm); <span class="comment">//计算Roll角</span></span><br><span class="line">  <span class="keyword">if</span> (realVals[<span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">  	fRoll = -fRoll;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算两次测量的时间间隔dt，以秒为单位</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nCurTime = micros();</span><br><span class="line">  <span class="type">float</span> dt = (<span class="type">double</span>)(nCurTime - nLastTime) / <span class="number">1000000.0</span>;</span><br><span class="line">  <span class="comment">//对Roll角和Pitch角进行卡尔曼滤波</span></span><br><span class="line">  <span class="type">float</span> fNewRoll = kalmanRoll.getAngle(fRoll, realVals[<span class="number">4</span>], dt);</span><br><span class="line">  <span class="comment">//跟据滤波值计算角度速</span></span><br><span class="line">  <span class="type">float</span> fRollRate = (fNewRoll - fLastRoll) / dt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新Roll角和Pitch角</span></span><br><span class="line">  fLastRoll = fNewRoll;</span><br><span class="line">  <span class="comment">//更新本次测的时间</span></span><br><span class="line">  nLastTime = nCurTime;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> fNewRoll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向MPU6050写入一个字节的数据</span></span><br><span class="line"><span class="comment">//指定寄存器地址与一个字节的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteMPUReg</span><span class="params">(<span class="type">int</span> nReg, <span class="type">unsigned</span> <span class="type">char</span> nVal)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(nReg);</span><br><span class="line">  Wire.write(nVal);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从MPU6050读出一个字节的数据</span></span><br><span class="line"><span class="comment">//指定寄存器地址，返回读出的值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ReadMPUReg</span><span class="params">(<span class="type">int</span> nReg)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(nReg);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Wire.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从MPU6050读出加速度计三个分量、温度和三个角速度计</span></span><br><span class="line"><span class="comment">//保存在指定的数组中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadAccGyr</span><span class="params">(<span class="type">int</span> *pVals)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x3B</span>);</span><br><span class="line">  Wire.requestFrom(MPU, nValCnt * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; nValCnt; ++i)</span><br><span class="line">    pVals[i] = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对大量读数进行统计，校准平均偏移量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Calibration</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> valSums[<span class="number">7</span>] = &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0</span>&#125;; <span class="comment">//先求和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nCalibTimes; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> mpuVals[nValCnt];</span><br><span class="line">    ReadAccGyr(mpuVals);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nValCnt; ++j)</span><br><span class="line">      valSums[j] += mpuVals[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//再求平均</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nValCnt; ++i)</span><br><span class="line">    calibData[i] = <span class="type">int</span>(valSums[i] / nCalibTimes);</span><br><span class="line">  calibData[<span class="number">2</span>] += <span class="number">16384</span>; <span class="comment">//设芯片Z轴竖直向下，设定静态工作点。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算得Roll角。算法见文档。</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetRoll</span><span class="params">(<span class="type">float</span> *pRealVals, <span class="type">float</span> fNorm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> fNormXZ = <span class="built_in">sqrt</span>(pRealVals[<span class="number">0</span>] * pRealVals[<span class="number">0</span>] + pRealVals[<span class="number">2</span>] * pRealVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fCos = fNormXZ / fNorm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">acos</span>(fCos) * fRad2Deg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对读数进行纠正，消除偏移，并转换为物理量。公式见文档。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Rectify</span><span class="params">(<span class="type">int</span> *pReadout, <span class="type">float</span> *pRealVals)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    pRealVals[i] = (<span class="type">float</span>)(pReadout[i] - calibData[i]) / <span class="number">16384.0f</span>;</span><br><span class="line"></span><br><span class="line">  pRealVals[<span class="number">3</span>] = pReadout[<span class="number">3</span>] / <span class="number">340.0f</span> + <span class="number">36.53</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    pRealVals[i] = (<span class="type">float</span>)(pReadout[i] - calibData[i]) / <span class="number">131.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建标签："Kalman.cpp"</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kalman.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Kalman::Kalman() </span><br><span class="line">&#123;</span><br><span class="line">  Q_angle = <span class="number">0.001f</span>;</span><br><span class="line">  Q_bias = <span class="number">0.003f</span>;</span><br><span class="line">  R_measure = <span class="number">0.03f</span>;</span><br><span class="line"></span><br><span class="line">  angle = <span class="number">0.0f</span>;</span><br><span class="line">  bias = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">  P[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;</span><br><span class="line">  P[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0.0f</span>;</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0.0f</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getAngle</span><span class="params">(<span class="type">float</span> newAngle, <span class="type">float</span> newRate, <span class="type">float</span> dt)</span> </span><br><span class="line">&#123;</span><br><span class="line">  rate = newRate - bias;</span><br><span class="line">  angle += dt * rate;</span><br><span class="line">  P[<span class="number">0</span>][<span class="number">0</span>] += dt * (dt * P[<span class="number">1</span>][<span class="number">1</span>] - P[<span class="number">0</span>][<span class="number">1</span>] - P[<span class="number">1</span>][<span class="number">0</span>] + Q_angle);</span><br><span class="line">  P[<span class="number">0</span>][<span class="number">1</span>] -= dt * P[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">0</span>] -= dt * P[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">1</span>] += Q_bias * dt;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> S = P[<span class="number">0</span>][<span class="number">0</span>] + R_measure;</span><br><span class="line">  <span class="type">float</span> K[<span class="number">2</span>];</span><br><span class="line">  K[<span class="number">0</span>] = P[<span class="number">0</span>][<span class="number">0</span>] / S;</span><br><span class="line">  K[<span class="number">1</span>] = P[<span class="number">1</span>][<span class="number">0</span>] / S;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> y = newAngle - angle;</span><br><span class="line">  angle += K[<span class="number">0</span>] * y;</span><br><span class="line">  bias += K[<span class="number">1</span>] * y;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> P00_temp = P[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="type">float</span> P01_temp = P[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  P[<span class="number">0</span>][<span class="number">0</span>] -= K[<span class="number">0</span>] * P00_temp;</span><br><span class="line">  P[<span class="number">0</span>][<span class="number">1</span>] -= K[<span class="number">0</span>] * P01_temp;</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">0</span>] -= K[<span class="number">1</span>] * P00_temp;</span><br><span class="line">  P[<span class="number">1</span>][<span class="number">1</span>] -= K[<span class="number">1</span>] * P01_temp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> angle;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kalman::setAngle</span><span class="params">(<span class="type">float</span> angle)</span> </span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;angle = angle;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getRate</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this-&gt;rate;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kalman::setQangle</span><span class="params">(<span class="type">float</span> Q_angle)</span> </span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;Q_angle = Q_angle;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kalman::setQbias</span><span class="params">(<span class="type">float</span> Q_bias)</span> </span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;Q_bias = Q_bias;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Kalman::setRmeasure</span><span class="params">(<span class="type">float</span> R_measure)</span> </span><br><span class="line">&#123;</span><br><span class="line">  this-&gt;R_measure = R_measure;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getQangle</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this-&gt;Q_angle;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getQbias</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this-&gt;Q_bias;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> <span class="title function_">Kalman::getRmeasure</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this-&gt;R_measure;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>新建标签"Kalman.h"</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Kalman_h_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Kalman_h_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kalman</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  public:</span><br><span class="line">    Kalman();</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="title function_">getAngle</span><span class="params">(<span class="type">float</span> newAngle, <span class="type">float</span> newRate, <span class="type">float</span> dt)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setAngle</span><span class="params">(<span class="type">float</span> angle)</span>;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">getRate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setQangle</span><span class="params">(<span class="type">float</span> Q_angle)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">setQbias</span><span class="params">(<span class="type">float</span> Q_bias)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">setRmeasure</span><span class="params">(<span class="type">float</span> R_measure)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="title function_">getQangle</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">getQbias</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">getRmeasure</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    <span class="type">float</span> Q_angle;</span><br><span class="line">    <span class="type">float</span> Q_bias;</span><br><span class="line">    <span class="type">float</span> R_measure;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> angle;</span><br><span class="line">    <span class="type">float</span> bias;</span><br><span class="line">    <span class="type">float</span> rate;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> P[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Kalman_Filter(Adxl_angle, Gyro_sensor); <span class="comment">//卡尔曼融合获取angle</span></span><br><span class="line">Input = angle;</span><br><span class="line">myPID.Compute();  <span class="comment">//PID计算获取 Output</span></span><br><span class="line">Drive(Output);   <span class="comment">//根据Output驱动电机</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连线方法</span></span><br><span class="line"><span class="comment">// MPU-&gt;UNO</span></span><br><span class="line"><span class="comment">// VCC-&gt;VCC</span></span><br><span class="line"><span class="comment">// GND-&gt;GND</span></span><br><span class="line"><span class="comment">// SCL-&gt;A5</span></span><br><span class="line"><span class="comment">// SDA-&gt;A4</span></span><br><span class="line"><span class="comment">// INT-&gt;2 (Optional)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;PID_v1.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kalman.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> Setpoint, Input, Output;</span><br><span class="line"><span class="type">float</span> fRad2Deg = <span class="number">57.295779513f</span>; <span class="comment">//将弧度转为角度的乘数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MPU = <span class="number">0x68</span>;           <span class="comment">// MPU-6050的I2C地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nValCnt = <span class="number">7</span>;          <span class="comment">//一次读取寄存器的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> nCalibTimes = <span class="number">1000</span>; <span class="comment">//校准时读数的次数</span></span><br><span class="line"><span class="type">int</span> calibData[nValCnt];       <span class="comment">//校准数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nLastTime = <span class="number">0</span>; <span class="comment">//上一次读数的时间</span></span><br><span class="line"><span class="type">float</span> fLastRoll = <span class="number">0.0f</span>;      <span class="comment">//上一次滤波得到的Roll角</span></span><br><span class="line">Kalman kalmanRoll;           <span class="comment">// Roll角滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//左电机——6个引脚</span></span><br><span class="line"><span class="type">const</span> byte L1_M1 = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//L2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte L3_C1 = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> byte L4_C2 = <span class="number">11</span>;</span><br><span class="line"><span class="comment">//L5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte L6_M2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右电机——6个引脚</span></span><br><span class="line"><span class="type">const</span> byte R1_M1 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//R2_GND-&gt;Nano_GND</span></span><br><span class="line"><span class="type">const</span> byte R3_C1 = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> byte R4_C2 = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//R5_VCC-&gt;Nano_5V</span></span><br><span class="line"><span class="type">const</span> byte R6_M2 = <span class="number">6</span>;</span><br><span class="line">  PID <span class="title function_">myPID</span><span class="params">(&amp;Input, &amp;Output, &amp;Setpoint,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>, DIRECT)</span>; <span class="comment">//PID对象声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">9600</span>);   <span class="comment">//初始化串口，指定波特率</span></span><br><span class="line">  Wire.begin();         <span class="comment">//初始化Wire库</span></span><br><span class="line">  WriteMPUReg(<span class="number">0x6B</span>, <span class="number">0</span>); <span class="comment">//启动MPU6050设备</span></span><br><span class="line"></span><br><span class="line">  Calibration();        <span class="comment">//执行校准</span></span><br><span class="line">  nLastTime = micros(); <span class="comment">//记录当前时间</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  setupPID();  <span class="comment">//PID初始化</span></span><br><span class="line">    </span><br><span class="line">  pinMode(L1_M1,OUTPUT);</span><br><span class="line">  pinMode(L6_M2,OUTPUT);</span><br><span class="line"></span><br><span class="line">  pinMode(R1_M1,OUTPUT);</span><br><span class="line">  pinMode(R6_M2,OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//向串口打印输出Roll角和Pitch角，运行时在Arduino的串口监视器中查看</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Roll:&quot;</span>);</span><br><span class="line">  Serial.println();</span><br><span class="line">  </span><br><span class="line">  Input = GetValue();</span><br><span class="line">  myPID.Compute();  <span class="comment">//PID计算获取 Output</span></span><br><span class="line">  Drive(Output);   <span class="comment">//根据Output驱动电机</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Drive</span><span class="params">(<span class="type">float</span> Output)</span></span><br><span class="line">&#123;    </span><br><span class="line">  analogWrite(L1_M1,Output);</span><br><span class="line">  analogWrite(L6_M2,<span class="number">0</span>);</span><br><span class="line">  analogWrite(R1_M1,<span class="number">0</span>);</span><br><span class="line">  analogWrite(R6_M2,Output);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setupPID</span><span class="params">()</span>&#123;</span><br><span class="line">  Input = <span class="number">0</span>;</span><br><span class="line">  Setpoint = <span class="number">17</span>;  <span class="comment">//我的小车自平衡角度为17</span></span><br><span class="line">  myPID.SetSampleTime(<span class="number">100</span>);  <span class="comment">//控制器的采样时间100ms</span></span><br><span class="line">  <span class="comment">//myPID.SetOutputLimits(0, 2000); </span></span><br><span class="line">  myPID.SetMode(AUTOMATIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetValue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> readouts[nValCnt];</span><br><span class="line">  ReadAccGyr(readouts); <span class="comment">//读出测量值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> realVals[<span class="number">7</span>];</span><br><span class="line">  Rectify(readouts, realVals); <span class="comment">//根据校准的偏移量进行纠正</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算加速度向量的模长，均以g为单位</span></span><br><span class="line">  <span class="type">float</span> fNorm = <span class="built_in">sqrt</span>(realVals[<span class="number">0</span>] * realVals[<span class="number">0</span>] + realVals[<span class="number">1</span>] * realVals[<span class="number">1</span>] + realVals[<span class="number">2</span>] * realVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fRoll = GetRoll(realVals, fNorm); <span class="comment">//计算Roll角</span></span><br><span class="line">  <span class="keyword">if</span> (realVals[<span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    fRoll = -fRoll;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算两次测量的时间间隔dt，以秒为单位</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> nCurTime = micros();</span><br><span class="line">  <span class="type">float</span> dt = (<span class="type">double</span>)(nCurTime - nLastTime) / <span class="number">1000000.0</span>;</span><br><span class="line">  <span class="comment">//对Roll角和Pitch角进行卡尔曼滤波</span></span><br><span class="line">  <span class="type">float</span> fNewRoll = kalmanRoll.getAngle(fRoll, realVals[<span class="number">4</span>], dt);</span><br><span class="line">  <span class="comment">//跟据滤波值计算角度速</span></span><br><span class="line">  <span class="type">float</span> fRollRate = (fNewRoll - fLastRoll) / dt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//更新Roll角和Pitch角</span></span><br><span class="line">  fLastRoll = fNewRoll;</span><br><span class="line">  <span class="comment">//更新本次测的时间</span></span><br><span class="line">  nLastTime = nCurTime;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> fNewRoll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向MPU6050写入一个字节的数据</span></span><br><span class="line"><span class="comment">//指定寄存器地址与一个字节的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WriteMPUReg</span><span class="params">(<span class="type">int</span> nReg, <span class="type">unsigned</span> <span class="type">char</span> nVal)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(nReg);</span><br><span class="line">  Wire.write(nVal);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从MPU6050读出一个字节的数据</span></span><br><span class="line"><span class="comment">//指定寄存器地址，返回读出的值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ReadMPUReg</span><span class="params">(<span class="type">int</span> nReg)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(nReg);</span><br><span class="line">  Wire.requestFrom(MPU, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Wire.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从MPU6050读出加速度计三个分量、温度和三个角速度计</span></span><br><span class="line"><span class="comment">//保存在指定的数组中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReadAccGyr</span><span class="params">(<span class="type">int</span> *pVals)</span></span><br><span class="line">&#123;</span><br><span class="line">  Wire.beginTransmission(MPU);</span><br><span class="line">  Wire.write(<span class="number">0x3B</span>);</span><br><span class="line">  Wire.requestFrom(MPU, nValCnt * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  Wire.endTransmission(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; nValCnt; ++i)</span><br><span class="line">    pVals[i] = Wire.read() &lt;&lt; <span class="number">8</span> | Wire.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对大量读数进行统计，校准平均偏移量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Calibration</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> valSums[<span class="number">7</span>] = &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0</span>&#125;; <span class="comment">//先求和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nCalibTimes; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> mpuVals[nValCnt];</span><br><span class="line">    ReadAccGyr(mpuVals);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nValCnt; ++j)</span><br><span class="line">      valSums[j] += mpuVals[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//再求平均</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nValCnt; ++i)</span><br><span class="line">    calibData[i] = <span class="type">int</span>(valSums[i] / nCalibTimes);</span><br><span class="line">  calibData[<span class="number">2</span>] += <span class="number">16384</span>; <span class="comment">//设芯片Z轴竖直向下，设定静态工作点。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算得Roll角。算法见文档。</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">GetRoll</span><span class="params">(<span class="type">float</span> *pRealVals, <span class="type">float</span> fNorm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> fNormXZ = <span class="built_in">sqrt</span>(pRealVals[<span class="number">0</span>] * pRealVals[<span class="number">0</span>] + pRealVals[<span class="number">2</span>] * pRealVals[<span class="number">2</span>]);</span><br><span class="line">  <span class="type">float</span> fCos = fNormXZ / fNorm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">acos</span>(fCos) * fRad2Deg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对读数进行纠正，消除偏移，并转换为物理量。公式见文档。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Rectify</span><span class="params">(<span class="type">int</span> *pReadout, <span class="type">float</span> *pRealVals)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    pRealVals[i] = (<span class="type">float</span>)(pReadout[i] - calibData[i]) / <span class="number">16384.0f</span>;</span><br><span class="line"></span><br><span class="line">  pRealVals[<span class="number">3</span>] = pReadout[<span class="number">3</span>] / <span class="number">340.0f</span> + <span class="number">36.53</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">4</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    pRealVals[i] = (<span class="type">float</span>)(pReadout[i] - calibData[i]) / <span class="number">131.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>电子设计</tag>
      </tags>
  </entry>
  <entry>
    <title>记录</title>
    <url>/2022/03/15/15-32-05/</url>
    <content><![CDATA[<h1 id="fpga">FPGA</h1>
<h3 id="时序约束">时序约束</h3>
<ol type="1">
<li>如通信实验，时钟频率比较高的实验，需要进行时序约束</li>
<li>当占用芯片的逻辑资源多的时候，需要使用时序约束：因为FPGA在布线时会优先考虑面积</li>
</ol>
<p>时钟约束用来描述设计人员对于时序的要求，包括时钟频率和输入输出延时</p>
<p>D触发器</p>
<p>arduino 机械臂</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Servo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Servo myservo_1;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line">Servo myservo_2;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line">Servo myservo_3;  <span class="comment">// 定义Servo对象来控制</span></span><br><span class="line"><span class="type">int</span> pos_1 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"><span class="type">int</span> pos_2 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"><span class="type">int</span> pos_3 = <span class="number">0</span>;    <span class="comment">// 角度存储变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  myservo_1.attach(<span class="number">12</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">    myservo_2.attach(<span class="number">11</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">      myservo_3.attach(<span class="number">10</span>);  <span class="comment">// 控制线连接数字9</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  myservo_1.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">myservo_2.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">myservo_3.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">for</span> (pos_1 = <span class="number">0</span>; pos_1 &lt;= <span class="number">10</span>; pos_1 ++) &#123; <span class="comment">// 0°到180°</span></span><br><span class="line">    <span class="comment">// in steps of 1 degree</span></span><br><span class="line">    myservo_1.write(pos_1);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">      <span class="keyword">for</span> (pos_2 = <span class="number">0</span>; pos_2 &lt;= <span class="number">60</span>; pos_2 ++) &#123; <span class="comment">// 从180°到0°</span></span><br><span class="line">    myservo_2.write(pos_2);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (pos_3 = <span class="number">0</span>; pos_3 &lt;= <span class="number">30</span>; pos_3 ++) &#123; <span class="comment">// 从180°到0°</span></span><br><span class="line">    myservo_3.write(pos_3);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">    delay(<span class="number">5</span>);                       <span class="comment">// 等待转动到指定角度</span></span><br><span class="line">  &#125;</span><br><span class="line">  delay(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">myservo_3.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">1000</span>);</span><br><span class="line">myservo_2.write(<span class="number">0</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line">delay(<span class="number">1000</span>);</span><br><span class="line">myservo_1.write(<span class="number">-5</span>);              <span class="comment">// 舵机角度写入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////  for (pos_1 = 0; pos_1 &lt;= 120; pos_1 ++) &#123; // 0°到g180°</span></span><br><span class="line"><span class="comment">////    // in steps of 1 degree</span></span><br><span class="line"><span class="comment">////    myservo_1.write(pos_1);              // 舵机角度写入</span></span><br><span class="line"><span class="comment">////    delay(5);                       // 等待转动到指定角度</span></span><br><span class="line"><span class="comment">////  &#125;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数字电路中的逻辑值">数字电路中的逻辑值：</h3>
<ul>
<li>逻辑 0：表示低电平，相当于电路 GND。</li>
<li>逻辑 1：表示高电平，相当于电路 VCC。</li>
<li>逻辑 X：表示未知，高或低。</li>
<li>逻辑 Z：表示高阻态，悬空状态</li>
</ul>
<h3 id="verilog-中的数字表示">Verilog 中的数字表示：</h3>
<p>“（数字的二进制）位宽 + 进制（缩写） + 数值”来表示一个数字。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二进制0101的表示</span></span><br><span class="line"><span class="number">4&#x27;b0101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//十进制2的表示，数字2的二进制表示为0010占4位</span></span><br><span class="line"><span class="number">4&#x27;d2</span></span><br></pre></td></tr></table></figure>
<p>Verilog 的默认二进制位宽为32位，默认的进制为十进制。</p>
<p>当二进制数字位数多的时候可以使用下划线增加可读性，编译时下划线会被去掉。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">16&#x27;b1001_1010_1010_1001</span></span><br></pre></td></tr></table></figure>
<h4 id="标识符">标识符：</h4>
<p>Verilog 的标识符可以用于定义模块名、端口名和信号名。</p>
<p>Verilog 的命名规则与 C 语言变量名的命名规则基本相同：只有一点，可以在命名中包含$符号。</p>
<p>标识符规则：</p>
<ul>
<li></li>
</ul>
<p>标识符推荐写法：</p>
<ul>
<li>不建议大小写混合</li>
<li>普通内部信号全部小写</li>
<li>信号命名体现含义</li>
<li>使用下划线区分词</li>
<li>采用前后缀：比如时钟可以采用：clk_50，clk_cpu</li>
</ul>
<h3 id="数据类型">数据类型</h3>
<p>三种数据类型：</p>
<ul>
<li><p>寄存器数据类型：实际电路物理模型</p>
<ul>
<li><p>抽象数据存储单元，可以通过赋值语句改变寄存器储存的值</p></li>
<li><p>关键字：reg，默认初始值为 X 不确定</p></li>
<li><p>```verilog // reg + [位宽：31:0 指32位位宽，高位在前] + 标识符名称（寄存器名称） reg [31:0] delay_cnt; //延时计数使用的寄存器 reg key_reg; //没给位宽时默认位宽为1 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  + reg 类型的数据只能在 always 语句和 initial 语句中被赋值</span><br><span class="line"></span><br><span class="line">  + 如果 always 中带有时钟信号即过程语句描述的是时序逻辑，则寄存器对应为触发器</span><br><span class="line"></span><br><span class="line">  + 如果 always 中不带有时钟信号即过程语句描述的是组合逻辑，则寄存器对应为硬件连线</span><br><span class="line"></span><br><span class="line">  + </span><br><span class="line"></span><br><span class="line">+ 线网数据类型：实际电路物理模型</span><br><span class="line"></span><br><span class="line">+ 参数数据类型：给编译器用的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 图像处理</span><br><span class="line"></span><br><span class="line">OV7725摄像头</span><br><span class="line"></span><br><span class="line">主控器控制OV7725时采用SCCB协议读写其寄存器，而它输出图像时则使用VGA或QVGA时序， 其中VGA在输出图像分辨率为480*640时采用，QVGA是Quarter VGA，其输出分辨率为240*320， 这些时序跟控制液晶屏输出图像数据时十分类似。</span><br><span class="line"></span><br><span class="line">OV7725传感器输出图像时，一帧帧地输出，在帧内的数据一般从左到右，从上到下， 一个像素一个像素地输出(也可通过寄存器修改方向)，见图 [摄像头数据输出](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#id20) 。</span><br><span class="line"></span><br><span class="line">![摄像头数据输出](记录/OV7725012.jpg)</span><br><span class="line"></span><br><span class="line">例如，见图 [像素同步时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#id21) 和图 [QVGA帧图像同步时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html#qvga) ， 若我们使用D2-D9数据线，图像格式设置为RGB565，&lt;img src=&quot;记录/image-20220326130518483.png&quot; alt=&quot;image-20220326130518483&quot; style=&quot;zoom:33%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">```verilog</span><br><span class="line">//RGB数据转换为YCBCR</span><br><span class="line">//因为FPGA处理除法是比较耗费资源的，所以我们团队采用左移右移以替代乘除法。处理整形数据可以将数据整体左移八位，再进行计算，最后在右移回去即可。</span><br><span class="line"></span><br><span class="line">Y’ = 0.257R’ + 0.504G’ + 0.098*B’ + 16</span><br><span class="line">Cb’ = -0.148R’ - 0.291G’ + 0.439*B’ + 128</span><br><span class="line">Cr’ = 0.439R’ - 0.368G’ - 0.071*B’ + 128</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<p>进行数据输出时，D2-D9数据线在PCLK在上升沿阶段维持稳定， 并且会在1个像素同步时钟PCLK的驱动下发送1字节的数据信号，所以2个PCLK时钟可发送1个RGB565格式的像素数据。 当HREF为高电平时，像素数据依次传输，每传输完一行数据时，行同步信号HREF会输出一个电平跳变信号间隔开当前行和下一行的数据； 一帧的图像由N行数据组成，当VSYNC为低电平时，各行的像素数据依次传输，每传输完一帧图像时，VSYNC会输出一个电平跳变信号。</p>
<p><img src="/2022/03/15/15-32-05/image-20220326132950059.png" alt="image-20220326132950059" style="zoom:50%;"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">rows=<span class="number">200</span></span><br><span class="line">cols=<span class="number">300</span></span><br><span class="line">num=<span class="number">2000</span> <span class="comment">#随机像素点的个数</span></span><br><span class="line">img=np.zeros((rows,cols,<span class="number">3</span>),np.uint8)</span><br><span class="line">pos1=np.random.randint(<span class="number">200</span>,size=(num,<span class="number">1</span>)) <span class="comment">#行位置随机数组</span></span><br><span class="line">pos2=np.random.randint(<span class="number">300</span>,size=(num,<span class="number">1</span>)) <span class="comment">#列</span></span><br><span class="line"><span class="comment">#随机位置处设置像素点值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">0</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">1</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">    img[pos1[i],pos2[i],[<span class="number">2</span>]]=np.random.randint(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line">如果在OpenCV中处理图像，是BGR的顺序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">I=numpy.zeros((<span class="number">3</span>,<span class="number">3</span>),dtype=numpy.uint8) </span><br><span class="line"><span class="comment">#图片I大小为3*3，灰度值全为0，也就是黑色图像</span></span><br><span class="line">I=cv2.cvtColor(I,cv2.COLOR_GRAY2BGR)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#此时图像I变成了三个通道的每个像素点的值都为0</span></span><br><span class="line"><span class="comment">#有27个像素值，HSV色彩空间也是同样的方式，只是只是通道数不同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">emptyImage = np.zeros(img.shape, np.uint8)</span><br><span class="line">cv2.imshow(<span class="string">&quot;EmptyImage&quot;</span>, emptyImage) </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\strawberry.jpg&#x27;</span>) </span><br><span class="line">cv2.imshow(<span class="string">&quot;Image&quot;</span>, img) </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">Strawberry=cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\strawberry.jpg&#x27;</span>) </span><br><span class="line"><span class="comment">#Strawberry=cv2.imread(&quot;strawberry.jpg&quot;)</span></span><br><span class="line">Lower = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>])</span><br><span class="line">Upper = np.array([<span class="number">40</span>, <span class="number">40</span>, <span class="number">255</span>])</span><br><span class="line">Binary = cv2.inRange(Strawberry, Lower, Upper)</span><br><span class="line">cv2.imshow(<span class="string">&quot;strawberry&quot;</span>, Binary)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fruit = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\fruits.jpg&#x27;</span>)</span><br><span class="line">fruit = cv2.cvtColor(fruit,cv2.COLOR_BGR2YUV)</span><br><span class="line">Y,U,V = cv2.split(fruit)</span><br><span class="line">Blueberry = cv2.inRange(U,<span class="number">130</span>,<span class="number">255</span>)</span><br><span class="line">Strawberry = cv2.inRange(V,<span class="number">170</span>,<span class="number">255</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;blueberry&quot;</span>,Blueberry)</span><br><span class="line">cv2.imshow(<span class="string">&quot;strawberry&quot;</span>,Strawberry)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\1.jpg&#x27;</span>, cv2.IMREAD_COLOR)</span><br><span class="line">ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)</span><br><span class="line">gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">(y, cr, cb) = cv2.split(ycrcb)</span><br><span class="line">cr1 = cv2.GaussianBlur(cr, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>) </span><br><span class="line">skin1 = cv2.threshold(cr1, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image CR&quot;</span>, cr1)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Skin Cr+OSTU&quot;</span>, skin1)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cr_otsu1</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;YCrCb颜色空间的Cr分量+Otsu阈值分割</span></span><br><span class="line"><span class="string">    :param image: 图片路径</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>, cv2.IMREAD_COLOR)</span><br><span class="line">ycrcb = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)</span><br><span class="line"></span><br><span class="line">(y, cr, cb) = cv2.split(ycrcb)</span><br><span class="line">cr1 = cv2.GaussianBlur(cr, (<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>)</span><br><span class="line">_, skin = cv2.threshold(cr1, <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;image raw&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image raw&quot;</span>, img)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;image CR&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image CR&quot;</span>, cr1)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;Skin Cr+OTSU&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Skin Cr+OTSU&quot;</span>, skin)</span><br><span class="line"></span><br><span class="line">dst = cv2.bitwise_and(img, img, mask=skin)</span><br><span class="line">cv2.namedWindow(<span class="string">&quot;seperate&quot;</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.imshow(<span class="string">&quot;seperate&quot;</span>, dst)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="灰度化">灰度化</h3>
<p>转换色彩空间：</p>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用Opencv进行色彩空间的转换</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\name_of_picture&#x27;</span>)</span><br><span class="line">img_ycbcr = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)</span><br><span class="line"><span class="comment">#img_YUV = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)</span></span><br><span class="line"><span class="comment">#img_hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, img_ycbcr)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>以RGB格式的彩图为例，通常灰度化采用的方法主要有：</p>
<p>方法1：<span class="math inline">\(Gray=(R+G+B)/3\)</span></p>
<p>方法2：<span class="math inline">\(Gray=max(R,G,B)\)</span></p>
<p>方法3：<span class="math inline">\(Gray=0.299R+0.587G+0.114B\)</span>（这种参数考虑到了人眼的生理特点）</p>
<p>所谓阈值处理，就是给定一个阈值，当像素值比指定阈值大或小时做相关的操作。==这个字念yu，不是fa==，方法签名为:<code>cv2.threshold(src,thresh,maxval,type,dst=None)</code>,需要将的是OpenCV中提供的几种type：</p>
<ul>
<li>cv2.THRESH_BINARY：若像素值大于阈值，则置为maxval；否则置0</li>
<li>cv2.THRESH_BINARY_INV：THRESH_BINARY的反转</li>
<li>cv2.THRESH_TRUNC：若像素值大于阈值，则置为阈值；否则不变</li>
<li>cv2.THRESH_TOZERO：小于阈值的部分置为0；其他不变</li>
<li>cv2.THRESH_TOZERO_INV：THRESH_TOZERO的反转</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, thresh1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">_, thresh2 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY_INV)</span><br><span class="line">_, thresh3 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TRUNC)</span><br><span class="line">_, thresh4 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TOZERO)</span><br><span class="line">_, thresh5 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_TOZERO_INV)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#固定阈值的二值化处理</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">threshold_value = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> threshold_value &lt; <span class="number">255</span>:</span><br><span class="line">    <span class="keyword">if</span> threshold_value &gt; <span class="number">255</span>:</span><br><span class="line">        threshold_value = <span class="number">255</span></span><br><span class="line">    _, thresh1 = cv2.threshold(img, threshold_value, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, thresh1)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    threshold_value = threshold_value + <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>选则合适的阈值筛选不同的色块，链接下文轮廓识别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用Opencv进行色彩空间的转换</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">threshold_value = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> threshold_value &lt; <span class="number">255</span>:</span><br><span class="line">    <span class="keyword">if</span> threshold_value &gt; <span class="number">255</span>:</span><br><span class="line">        threshold_value = <span class="number">255</span></span><br><span class="line">    _, thresh1 = cv2.threshold(img, threshold_value, <span class="number">255</span>, <span class="built_in">type</span>=cv2.THRESH_BINARY)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, thresh1)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    threshold_value = threshold_value + <span class="number">10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自适应阈值二值化处理</span></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"></span><br><span class="line">img = cv2.cvtColor(cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>), cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, th1 = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">th2 = cv2.adaptiveThreshold(img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="number">11</span>, <span class="number">2</span>)</span><br><span class="line">th3 = cv2.adaptiveThreshold(img, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="number">11</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th1)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th2)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, th3)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="腐蚀">腐蚀</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&quot;i.png&quot;</span>)</span><br><span class="line">img_noise = copy.deepcopy(img)</span><br><span class="line"><span class="comment"># add some noise to original image</span></span><br><span class="line">rows, cols = img_noise.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">	i = random.randint(<span class="number">0</span>, rows - <span class="number">1</span>)</span><br><span class="line">	j = random.randint(<span class="number">0</span>, cols - <span class="number">1</span>)</span><br><span class="line">	img_noise[i, j] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), dtype=np.uint8)</span><br><span class="line">erosion = cv2.erode(img_noise, kernel)</span><br><span class="line">dilation = cv2.dilate(erosion, kernel)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im = cv2.imread(<span class="string">&#x27;rectangle.jpg&#x27;</span>)</span><br><span class="line">imgray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(imgray, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;一共检测到%d个轮廓&quot;</span> % <span class="built_in">len</span>(contours))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第%d个轮廓:&quot;</span> % (i + <span class="number">1</span>))</span><br><span class="line">	<span class="built_in">print</span>(contours[i])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># -1 代表画出所有轮廓</span></span><br><span class="line">res = cv2.drawContours(im, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img_of_YCbCr&quot;</span>, res)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_contours_of_binary_image</span>():</span><br><span class="line">	im = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\2.jpg&#x27;</span>)</span><br><span class="line">	imgray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)</span><br><span class="line">	ret, thresh = cv2.threshold(imgray, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	image, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;一共检测到%d个轮廓&quot;</span> % <span class="built_in">len</span>(contours))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contours)):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;第%d个轮廓:&quot;</span> % (i + <span class="number">1</span>))</span><br><span class="line">		<span class="built_in">print</span>(contours[i])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># -1 代表画出所有轮廓</span></span><br><span class="line">	res = cv2.drawContours(im, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), thickness=<span class="number">3</span>)</span><br><span class="line">   	img_show(res)</span><br><span class="line">    </span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>轮廓检测能用代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">kernel = np.ones((<span class="number">1</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\1.jpg&#x27;</span>)  </span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  </span><br><span class="line">ret, binary = cv2.threshold(gray,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)  </span><br><span class="line">binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel, anchor=(<span class="number">2</span>, <span class="number">0</span>), iterations=<span class="number">5</span>)</span><br><span class="line">contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  </span><br><span class="line">cv2.drawContours(img,contours,-<span class="number">1</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)  </span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)  </span><br><span class="line">cv2.waitKey(<span class="number">0</span>)  </span><br></pre></td></tr></table></figure>
<p>能看懂的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#调节二值化的阈值可以描出不同的色块</span></span><br><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line">img = cv2.imread(<span class="string">r&#x27;C:\Users\qjy\Desktop\3.jpg&#x27;</span>)  </span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  </span><br><span class="line">ret, binary = cv2.threshold(gray,<span class="number">100</span>,<span class="number">255</span>,cv2.THRESH_BINARY)  </span><br><span class="line">contours, hierarchy = cv2.findContours(binary,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)  </span><br><span class="line">cv2.drawContours(img,contours,-<span class="number">1</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)  </span><br><span class="line">cv2.imshow(<span class="string">&quot;img&quot;</span>, img)  </span><br><span class="line">cv2.waitKey(<span class="number">0</span>)  </span><br></pre></td></tr></table></figure>
<h3 id="二值化">二值化</h3>
<p>二值图也就是黑白图。将灰度图转换成黑白图的过程，就是二值化。二值化的一般算法是：</p>
<p><span class="math inline">\(g={0,f≤t1,f&gt;t}\)</span></p>
<p>其中t被称为阀值。阀值的确定方法有下面几种。</p>
<h2 id="otsu法大津法或最大类间方差法">Otsu法（大津法或最大类间方差法）</h2>
<p>来自霓虹国的大津展之为这种波谷找到了一个合适的数学表达，并于 1979 年发表论文[2]。这个二值化方法称为<strong>大津算法（Otsu’s method）</strong>。</p>
<p>大津算法就是，<strong>从 1 到 255 一个个数字试，找到一个数字能够把两个波峰切开</strong>，让两个波峰内部的类内方差之和最小。类内方差之和就是，单独求这两个波峰各自的方差，乘上波峰的占比权重，然后加起来。</p>
<p>这个数字就能最好的把图像分开，<strong>对应的就是双峰直方图中的波谷</strong>。这个算法最多只需遍历两次直方图数组，速度飞快，至今仍被广泛应用。</p>
<p>图像比较复杂的时候，我们对大津算法稍加扩展也可以完成分割。对大津算法的多级推广成为<strong>多大津算法（multi Otsu method） [3]</strong>。</p>
<p>*这里提到的是局部阈值的基本方法，对于实际使用中常见的其他局部阈值方法，请参阅<strong>Chow-Kaneko 自适应阈值法 [4]</strong>。</p>
<p>局部阈值的应用非常广泛，特别是对白纸黑字的处理非常有效。光学字符识别（OCR）和二维码扫描的算法中，很多都用了局部阈值操作。比如下面这张受光不均的二维码。</p>
<p>该算法是一种动态阈值分割算法。它的主要思想是按照灰度特性将图像划分为背景和目标2部分（这里我们将f≤t的部分称为背景，其他部分称为目标。），选取门限值，使得背景和目标之间的方差最大。</p>
<blockquote>
<p>注：Nobuyuki Otsu（大津展之），东京大学博士，先后在筑波大学和东京大学担任教授。</p>
</blockquote>
<p>其步骤如下：</p>
<p>1.建立图像灰度直方图。</p>
<p>2.计算背景和目标的出现概率。</p>
<p><span class="math inline">\(pA=∑i=0tpi,pB=∑i=t+1L−1pi=1−pA\)</span></p>
<p>其中，A和B分别表示背景部分和目标部分。</p>
<p>3.计算A和B两个区域的类间方差。</p>
<p><span class="math inline">\(公式ωA=∑i=0tipipA,ωB=∑i=t+1L−1ipipB(公式1)\)</span></p>
<p>公式1分别计算A和B区域的平均灰度值；</p>
<p>公式<span class="math inline">\(ω0=pAωA+pBωB=∑i=0L−1ipi\)</span>(公式2)</p>
<p>公式2计算灰度图像全局的灰度平均值；</p>
<p>公式<span class="math inline">\(σ2=pA(ωA−ω0)2+pB(ωB−ω0)2\)</span>(公式3)</p>
<p>公式3计算A、B两个区域的类间方差。</p>
<p>4.针对每一个灰度值，计算类间方差。选择方差最大的灰度值，作为阀值t。</p>
<p>下面是几个在使用opencv作轮廓检测时需要注意的点：</p>
<ul>
<li>为了更精确地提取轮廓，请使用二值图。也就是说，在使用轮廓提取函数前，请将源图片运用阈值进行<code>二值化(cv2.threshold())</code>或者采用<code>Canny边缘检测</code>。</li>
<li>findContours 函数会修改源图片，如果希望在轮廓检测后继续使用源图片，务必提前保存在另一个变量中。</li>
<li>在OpenCV中，轮廓检测视作从黑色背景中提取白色的物体，所以，在结果中，白色表示物体，黑色表示背景。</li>
</ul>
<p><em>提取轮廓的步骤大概会是这样子：</em></p>
<ol type="1">
<li>读取源图片，并转化为灰度图</li>
<li>运用threshold将灰度图片二值化（也可以使用Canny边缘检测）</li>
<li>使用<code>findContours()函数</code>找到所有的轮廓</li>
<li>使用<code>drawContours()函数</code>将轮廓画出来</li>
</ol>
<p>https://gy23333.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</p>
<h2 id="图像处理">图像处理</h2>
<h3 id="形态学">形态学</h3>
<h4 id="膨胀">膨胀</h4>
<h5 id="简介">简介</h5>
<p>膨胀是数学形态学的两种基本运算之一，腐蚀是另一种基本运算。它通常应用于二值图像，但也有适用于灰度图像的版本。该算子对二值图像的基本作用是逐渐扩大前景像素(通常为白色像素)区域的边界。因此，前景像素的区域会增大，而这些区域内的孔会变小。</p>
<h5 id="它是如何运作的">它是如何运作的</h5>
<p>这个描述的有用背景在词汇表的数学形态学部分给出。</p>
<p>膨胀运算符接受两段数据作为输入。首先是要放大的图像。第二个是一组坐标点(通常很小)，称为结构元素(也称为内核)。正是这个构造元素决定了输入图像的精确膨胀效果。</p>
<p>二值图像膨胀的数学定义如下：</p>
<p>设X为输入二值图像对应的欧几里德坐标集，K为构造元素的坐标集。</p>
<p>Kx表示K的平移使其原点在x处。</p>
<p>那么X乘以K的膨胀就是所有点X的集合使得Kx与X的交点非空。</p>
<p>除了与输入图像相关联的一组坐标的导出方式之外，灰度膨胀的数学定义是相同的。此外，这些坐标是三维的，而不是二维的。</p>
<p>作为二元扩张的一个例子</p>
]]></content>
      <tags>
        <tag>电子设计</tag>
      </tags>
  </entry>
  <entry>
    <title>电子专业资料共享计划</title>
    <url>/2022/03/23/15-24-59/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>我也曾很努力地收集各种课程资料，但到最后，某些重要信息的得到却往往依然是纯属偶然。这种状态时常令我感到后怕与不安。我也曾在课程结束后终于有了些许方法与总结，但这些想法无处诉说，最终只能把花费时间与精力才换来的经验耗散在了漫漫的遗忘之中。</p>
<p>我为这一年一年，这么多人孤军奋战的重复劳动感到不平。</p>
<p>我希望能够将这些隐晦的、不确定的、口口相传的资料和经验，变为公开的、易于获取的和大家能够共同完善、积累的共享资料。</p>
<p>我希望只要是前人走过的弯路，后人就不必再走。这是我的信念，也是我建立这个项目的原因。</p>
</blockquote>
<p>注：如果您对本篇博客的目的存在疑问，请阅读<a href="https://qsctech.github.io/zju-icicles/">此文</a>。</p>
<h3 id="加入我们">加入我们：</h3>
<p><strong>如果您有意愿加入该计划，请注册wolai账号并在<a href="https://www.wolai.com/aPVPDQTgKUnVaE9JQzKudx">此处</a>进行编辑，请选择文章最后一部分的”推荐模板“，并复制在其上面，然后将副标题改做”来自xxx的推荐“，结束后在评论区评论以联系我去将内容发布在博客内。</strong></p>
<h4 id="资料链接">资料链接：</h4>
<p>链接：https://pan.baidu.com/s/1JEZYkR3-MfOQYS646UjtBg 提取码：2038</p>
<h1 id="河南大学迈阿密学院电子信息专业培养计划及其课本">河南大学迈阿密学院电子信息专业培养计划及其课本</h1>
<h3 id="大一上学期">大一上学期：</h3>
<table>
<colgroup>
<col style="width: 43%">
<col style="width: 56%">
</colgroup>
<thead>
<tr class="header">
<th>第一学期课程（Curriculum in First Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 读写教程 1 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td><em>3 Longman Academic Writing Series</em><br> （无中文版）</td>
</tr>
<tr class="even">
<td>口语</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 视听说教程 1 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>中国近现代史纲要</td>
<td>《中国近现代史纲要 （2018年版）》</td>
</tr>
<tr class="even">
<td>形式与政策</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>大学体育（一）College Physical Education I</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>工程微积分Ⅰ（Calculus Ⅰ for Engineers）</td>
<td><em>Calculus (2nd Edition)</em> <br>《微积分 中文版 上》<br>参考答案</td>
</tr>
<tr class="odd">
<td>线性代数导论（Introduction to Linear Algebra）</td>
<td><a href="https://kdocs.cn/l/cbVej03YO5yb?f=201"><em>Elementary Linear Algebra</em><br></a>（无中文版和答案）</td>
</tr>
<tr class="even">
<td>大学物理Ⅰ（University Physics Ⅰ）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 上》<br>参考答案</td>
</tr>
<tr class="odd">
<td>工程学导论Ⅰ（Introduction to Engineering Ⅰ）</td>
<td><em>Thinking Like an Engineer</em><br>（无中文版和答案）</td>
</tr>
<tr class="even">
<td>编程导论（Introduction to Programming）</td>
<td><em>C++ Pregramming program Design Including Data Structures</em><br>（无中文版和答案）</td>
</tr>
</tbody>
</table>
<h3 id="大一下学期">大一下学期：</h3>
<table>
<colgroup>
<col style="width: 46%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th>第二学期课程（Curriculum in Second Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 读写教程 2 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td>The Everyday Writer 6th Edition <br>（无中文版）</td>
</tr>
<tr class="even">
<td>口语</td>
<td>《流畅英语口语教程 第二册》</td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 视听说教程 2 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>思想道德修养与法律基础</td>
<td>《思想道德修养与法律基础 （2021年版）》</td>
</tr>
<tr class="even">
<td>毛泽东思想与中国特色社会主义理论体系概论</td>
<td>《毛泽东思想与中国特色社会主义理论体系概论（2021年版）》</td>
</tr>
<tr class="odd">
<td>大学体育（二）College Physical Education II</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>微积分Ⅱ和III（Calculus Ⅱ and III）</td>
<td><em>Calculus (2nd Edition)</em> <br>《微积分 中文版 下》<br>参考答案</td>
</tr>
<tr class="odd">
<td>大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 下》<br>参考答案</td>
</tr>
<tr class="even">
<td>大学物理实验</td>
<td>《大学物理实验》</td>
</tr>
<tr class="odd">
<td>工程学导论Ⅱ（Introduction to Engineering Ⅱ）</td>
<td><em>Engineering Circuit Analysis</em><br>《工程电路分析 中文版》<br></td>
</tr>
<tr class="even">
<td>电路原理及实验（Electrical Circuit Theory and Lab）</td>
<td><em>Electric Circuit Ninth Edition</em><br>《电路 中文版》<br>参考答案</td>
</tr>
<tr class="odd">
<td>电路实验</td>
<td>“教师讲义 + 教学课件”</td>
</tr>
</tbody>
</table>
<h3 id="大二上学期">大二上学期：</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>第三学期课程（Curriculum in Third Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共四门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 第三版 读写教程 3 智慧版》</td>
</tr>
<tr class="odd">
<td>写作</td>
<td><em>Technical Writing A Practical Guide for Engineers, Scientists, and Nontechnical Professionals by Phillip A. Laplante</em><br>无中文版</td>
</tr>
<tr class="even">
<td>口语</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 第三版 视听说教程 3 智慧版》</td>
</tr>
<tr class="even">
<td>思政课（Ideological and Political courses）</td>
<td>学期共两门课</td>
</tr>
<tr class="odd">
<td>马克思主义基本原理概论</td>
<td>《马克思主义基本原理概论 （2021年版）》</td>
</tr>
<tr class="even">
<td>毛泽东思想与中国特色社会主义理论体系概论</td>
<td>《毛泽东思想与中国特色社会主义理论体系概论（2021年版）》</td>
</tr>
<tr class="odd">
<td>大学体育（三）College Physical Education III</td>
<td><del>无课本</del></td>
</tr>
<tr class="even">
<td>常微分方程导论（Introduction to Ordinary Differential）</td>
<td><em>A Textbook on Ordinary Differential Equations</em><br>（无中文版和参考答案）<br>参考书：《常微分方程（第三版）简明本》</td>
</tr>
<tr class="odd">
<td>大学物理III及实验（University Physics III and Lab）</td>
<td><em>Physics for Scientists &amp; Engineers with Modern Physics</em><br>《大学物理 中文版 下》<br>参考答案</td>
</tr>
<tr class="even">
<td>大学物理实验</td>
<td>《大学物理实验》</td>
</tr>
<tr class="odd">
<td>数据结构（Data Structures）</td>
<td>《数据结构（C语言版）》<br><em>Data Structures Using C</em><br>参考资料：<a href="https://www.bilibili.com/video/BV1Fv4y1f7T1">视频课</a></td>
</tr>
<tr class="even">
<td>电子学Ⅰ及实验（Electronics Ⅰ and Lab）</td>
<td><em>Microelectronic Circuits</em><br><em>Microelectronics Circuit Analysis and Design</em><br>《微电子电路 中文版 上》<br>《微电子电路 中文版 下》<br>《电子电路分析与设计 中文版》<br>参考资料：《模拟电子技术 中文版》</td>
</tr>
<tr class="odd">
<td>电子学实验</td>
<td>“教师讲义”</td>
</tr>
</tbody>
</table>
<h3 id="大二下学期">大二下学期：</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>第四学期课程（Curriculum in Forth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>英语（English）</td>
<td>学期共两门课</td>
</tr>
<tr class="even">
<td>阅读</td>
<td>《新视野大学英语 第三版 读写教程 4 智慧版》</td>
</tr>
<tr class="odd">
<td>听力</td>
<td>《新视野大学英语 第三版 视听说教程 4 智慧版》</td>
</tr>
<tr class="even">
<td>大学体育（四）（College Physical Education IV）</td>
<td><del>无课本</del></td>
</tr>
<tr class="odd">
<td>工程概率基础（Introduction to Engineering Probability）</td>
<td><em>Probability, Statistics, and Random Processes For Electrical Engineerin</em><br>《机率与统计 第三版 中文版 台版》<br><a href>参考答案</a><br>参考资料：《概率论与数理统计 (第四版)》</td>
</tr>
<tr class="even">
<td>信号与系统（Circuits，Signals and System）</td>
<td>《信号与系统（郑君里）第三版 上》<br>参考书籍：<br>《信号与系统（郑君里）第三版 下》<br>《信号与系统（奥本海姆）第二版》</td>
</tr>
<tr class="odd">
<td>逻辑设计（Logic Design）</td>
<td><em>Fundamentals Of Logic Design Seven Edition</em><br>《逻辑设计基础 中文版》<br>参考答案</td>
</tr>
<tr class="even">
<td>数字设计实验（Digital Design Lab）</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>电子学Ⅱ和实验（Electronics Ⅱ and Lab）</td>
<td><em>Microelectronic Circuits</em><br><em>Microelectronics Circuit Analysis and Design</em><br>《微电子电路 中文版 上》<br>《微电子电路 中文版 下》<br>《电子电路分析与设计 中文版》<br>参考资料：《模拟电子技术 中文版》</td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td>“教师讲义”</td>
</tr>
<tr class="odd">
<td>微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</td>
<td>ARM：《微机原理与接口技术 第三版 基于ARM Cortex-M4 田辉》<br><em>Practical Microcontroller Engineering with ARMÂ­ Technology by Ying Bai<br></em>参考资料：x86：《微型计算机原理与接口技术》</td>
</tr>
<tr class="even">
<td><del>电子电路CAD （Electronic Circuit CAD）</del></td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="大三上学期">大三上学期：</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>第五学期课程（Curriculum in Fifth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>离散时间信号与系统（Discrete-Time Signals and Systems）</td>
<td><em>Signal &amp; System</em><br>《中文版 信号与系统 奥本海姆》</td>
</tr>
<tr class="even">
<td>电磁场原理（Electromagnetic Field Theory）</td>
<td><em>Field and Wave Electromagnetics by David K. Cheng</em><br>《电磁场与电磁波 中文版》<br>参考答案</td>
</tr>
<tr class="odd">
<td>固态电子学（Solid-State Electronics）</td>
<td><em>Semiconductor physics and devices basic principles by Donald A. Neamen</em><br>《半导体物理与器件 中文版》</td>
</tr>
<tr class="even">
<td>单片机原理（MCU Principle）</td>
<td><em>The 8051 Microcontroller A Systems Approach (Mazidi, Muhammad AliMcKinlay, Rolin DMazidi etc.)</em> <br>《8051单片机系统》<br>《单片机原理及接口技术 第5版》</td>
</tr>
<tr class="odd">
<td>结构化数字设计（含FPGA）Structured Digital Design</td>
<td><em>Verilog HDL - A Guide To Digital Design And Synth<br></em>《Verilog HDL 数字设计与综合》</td>
</tr>
<tr class="even">
<td>创新项目实践（一）Practice of Innovation Project I</td>
<td><del>无课本</del></td>
</tr>
</tbody>
</table>
<h3 id="大三下学期">大三下学期：</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>第六学期课程（Curriculum in Sixth Semester）</th>
<th>课本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>嵌入式微处理系统设计（Embedded Microprocessor System Design）</td>
<td><del>《嵌入式系统设计——基于STM32CubeMX与HAL库》</del></td>
</tr>
<tr class="even">
<td>通信系统（Communication Systems）</td>
<td><em>Communication Systems 4th Edition by Simon Haykin<br></em>《通信系统 中文版》<br>《通信原理 第七版》</td>
</tr>
<tr class="odd">
<td>线性控制系统（Linear Control Systems）</td>
<td><em>Communication Systems 4th Edition by Simon Haykin</em><br>参考答案</td>
</tr>
<tr class="even">
<td>电力电子（Power Electronics）</td>
<td>《电力电子技术》<br>参考答案</td>
</tr>
<tr class="odd">
<td>VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</td>
<td><em>Digital integrated circuits a design perspective</em><br>《数字集成电路——电路系统与设计 中文版》</td>
</tr>
<tr class="even">
<td>模拟集成电路（Analog Integrated Circuit）</td>
<td><em>Design of Analog CMOS Integrated Circuits by Behzad Razavi</em><br>《数字集成电路：电路、系统与设计第2版》<br></td>
</tr>
<tr class="odd">
<td>创新项目实践（二）Practice of Innovation Project II</td>
<td><del>无课本</del></td>
</tr>
</tbody>
</table>
<h1 id="电子专业课程书籍课程资源推荐">电子专业课程书籍课程资源推荐</h1>
<h2 id="来自邱金羽的推荐">——来自邱金羽的推荐</h2>
<h3 id="大一上学期-1">大一上学期：</h3>
<table>
<colgroup>
<col style="width: 43%">
<col style="width: 56%">
</colgroup>
<thead>
<tr class="header">
<th>第一学期课程（Curriculum in First Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程微积分Ⅰ（Calculus Ⅰ for Engineers）</td>
<td>课本讲的挺不错<br>入学前可以看一下 <span class="math inline">\(3Blue1Brown\)</span> 的数学频道，微积分对应为：《<a href="https://www.bilibili.com/video/BV1qW411N7FU">微积分的本质</a>》<br>国内常用教材为：《高等数学》<br>推荐一个写微积分比较好的知乎文章：《<a href="https://www.zhihu.com/column/c_1249046061567741952">Re:从零开始的数学世界生活</a>》，里面包括微积分、线性代数和概率论的知识</td>
</tr>
<tr class="even">
<td>线性代数导论（Introduction to Linear Algebra）</td>
<td><span class="math inline">\(3Blue1Brown\)</span> 的数学频道：《<a href="https://www.bilibili.com/video/BV1ys411472E">线性代数的本质</a>》</td>
</tr>
<tr class="odd">
<td>大学物理Ⅰ（University Physics Ⅰ）</td>
<td>无</td>
</tr>
<tr class="even">
<td>工程学导论Ⅰ（Introduction to Engineering Ⅰ）</td>
<td>工程学导论教学内容：Excal + Matlab + 编程基础 + CAD基础<br>Excal要求很低，会使用基本函数就行<br>Matlab很值得学习，主要包括基本的语法和绘图操作，建议跟着官网的教程学习：<a href="https://matlabacademy.mathworks.com/details/matlab-onramp/gettingstarted">Matlba Courses</a><br>Matlab学习中实现一些小项目可以帮助自己去理解，善用谷歌搜索和官网文档解决问题<br>对电子来说编程基础与编程导论课程内容重复<br>CAD基础，课时很少，简单了解</td>
</tr>
<tr class="odd">
<td>编程导论（Introduction to Programming）</td>
<td>推荐网课：《<a href="https://www.bilibili.com/video/BV1Ls411w7rx?spm_id_from=..search-card.all.click">C语言程序设计</a>》<br>推荐书籍：《C Primer Plus 中文版》（这本书适合作为工具书使用，其中代码写的比较规范，适合跟着敲练习）<br> 《C Primer Plus 中文版》</td>
</tr>
</tbody>
</table>
<h3 id="大一下学期-1">大一下学期：</h3>
<table>
<colgroup>
<col style="width: 46%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th>第二学期课程（Curriculum in Second Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>微积分Ⅱ和III（Calculus Ⅱ and III）</td>
<td>同上</td>
</tr>
<tr class="even">
<td>大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</td>
<td>大物二：声热光，相对没大物三的电磁重要</td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td>大物实验课比较水</td>
</tr>
<tr class="even">
<td>工程学导论Ⅱ（Introduction to Engineering Ⅱ）</td>
<td>Matlab绘图：如果大一学的好，现在应该不需要再学了<br>推荐一些博客：<br>《<a href="http://cighao.com/2016/04/11/draw-picture-with-matlab-001-line-style/">matlab 画图</a>》<br>《<a href="https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4220232.html">MATLAB学习笔记</a>》</td>
</tr>
<tr class="odd">
<td>电路原理及实验（Electrical Circuit Theory and Lab）</td>
<td>强烈推荐看完整个《电路》课本，里面很多知识很重要</td>
</tr>
<tr class="even">
<td>电路实验</td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="大二上学期-1">大二上学期：</h3>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 51%">
</colgroup>
<thead>
<tr class="header">
<th>第三学期课程（Curriculum in Third Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>常微分方程导论（Introduction to Ordinary Differential）</td>
<td>可以参考国内教材：《常微分方程（第三版）简明本》</td>
</tr>
<tr class="even">
<td>大学物理III及实验（University Physics III and Lab）</td>
<td>电磁部分比较难，需要认真学</td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td>比较水</td>
</tr>
<tr class="even">
<td>数据结构（Data Structures）</td>
<td>强烈推荐使用此视频入门数据结构：<a href="https://www.bilibili.com/video/BV1Fv4y1f7T1">深入浅出数据结构 - 顶尖程序员图文讲解</a><br>课程较难，需要认真学习</td>
</tr>
<tr class="odd">
<td>电子学Ⅰ及实验（Electronics Ⅰ and Lab）</td>
<td>可以使用此课程进行半导体器件的入门，比较生动：《<a href="https://www.bilibili.com/video/BV1qt411m7Vm">可汗学院-半导体器件</a>》<br>强烈推荐使用此课程进行学习《<a href="https://www.bilibili.com/video/BV1TJ411G7sk?p=1">【电子】模拟电子技术基础 上海交通大学 郑益慧主讲</a>》<br>书籍推荐：</td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td>与理论课不匹配</td>
</tr>
</tbody>
</table>
<h3 id="大二下学期-1">大二下学期：</h3>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>第四学期课程（Curriculum in Forth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程概率基础（Introduction to Engineering Probability）</td>
<td></td>
</tr>
<tr class="even">
<td>信号与系统（Circuits，Signals and System）</td>
<td>想考高分，做好作业<br>承前是电路原理，往后是控制系统（不止）<br>想学明白一点，考虑找<a href="https://www.bilibili.com/video/BV1CZ4y1j7hs?spm_id_from=..search-card.all.click">祖师爷</a>吧</td>
</tr>
<tr class="odd">
<td>逻辑设计（Logic Design）</td>
<td></td>
</tr>
<tr class="even">
<td>数字设计实验（Digital Design Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>电子学Ⅱ和实验（Electronics Ⅱ and Lab）</td>
<td>强烈推荐使用此课程进行学习《<a href="https://www.bilibili.com/video/BV1TJ411G7sk?p=1">【电子】模拟电子技术基础 上海交通大学 郑益慧主讲</a>》<br>书籍推荐：</td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td>有一点匹配</td>
</tr>
<tr class="odd">
<td>微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</td>
<td>学习微机原理这门课的第一件事就是扔掉学校配的课本，切忌在学懂这门课之前翻看课本<br>第二件事是买一本：《数字设计和计算机结构体系》，仔细阅读第一章和第六章，粗略阅读中间章节<br>然后找到课本，直接阅读第四章<br>然后去学习stm32课程，比较推荐这个，日后做竞赛也会用到：<a href="https://www.bilibili.com/video/BV1q4411d7RX?vd_source=848d96f76bd7922d39f70343e2f35a57">STM32系列视频(CubeMX+MDK5+HAL库+库函数一站式学习)</a>；除了看一些基本的操作外，还应该阅读一下这个<a href="https://gaoyichao.com/Xiaotu/?book=stm32&amp;title=index">STM32入门</a>中的内容。<br>可以看一下我博客上的微机原理章节，目前没有整理好，只是一份复习笔记。</td>
</tr>
</tbody>
</table>
<h3 id="大三上学期-1">大三上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第五学期课程（Curriculum in Fifth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>离散时间信号与系统（Discrete-Time Signals and Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电磁场原理（Electromagnetic Field Theory）</td>
<td></td>
</tr>
<tr class="odd">
<td>固态电子学（Solid-State Electronics）</td>
<td></td>
</tr>
<tr class="even">
<td>单片机原理（MCU Principle）</td>
<td></td>
</tr>
<tr class="odd">
<td>结构化数字设计（含FPGA）Structured Digital Design</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大三下学期-1">大三下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第六学期课程（Curriculum in Sixth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>嵌入式微处理系统设计（Embedded Microprocessor System Design）</td>
<td></td>
</tr>
<tr class="even">
<td>通信系统（Communication Systems）</td>
<td></td>
</tr>
<tr class="odd">
<td>线性控制系统（Linear Control Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电力电子（Power Electronics）</td>
<td></td>
</tr>
<tr class="odd">
<td>VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</td>
<td></td>
</tr>
<tr class="even">
<td>模拟集成电路（Analog Integrated Circuit）</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="电子专业课程书籍课程资源推荐-1">电子专业课程书籍课程资源推荐</h1>
<h2 id="推荐模板">——推荐模板</h2>
<h3 id="大一上学期-2">大一上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第一学期课程（Curriculum in First Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程微积分Ⅰ（Calculus Ⅰ for Engineers）</td>
<td></td>
</tr>
<tr class="even">
<td>线性代数导论（Introduction to Linear Algebra）</td>
<td></td>
</tr>
<tr class="odd">
<td>大学物理Ⅰ（University Physics Ⅰ）</td>
<td></td>
</tr>
<tr class="even">
<td>工程学导论Ⅰ（Introduction to Engineering Ⅰ）</td>
<td></td>
</tr>
<tr class="odd">
<td>编程导论（Introduction to Programming）</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大一下学期-2">大一下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第二学期课程（Curriculum in Second Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>微积分Ⅱ和III（Calculus Ⅱ and III）</td>
<td></td>
</tr>
<tr class="even">
<td>大学物理Ⅱ及实验（University Physics Ⅱ and Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td></td>
</tr>
<tr class="even">
<td>工程学导论Ⅱ（Introduction to Engineering Ⅱ）</td>
<td></td>
</tr>
<tr class="odd">
<td>电路原理及实验（Electrical Circuit Theory and Lab）</td>
<td></td>
</tr>
<tr class="even">
<td>电路实验</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大二上学期-2">大二上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第三学期课程（Curriculum in Third Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>常微分方程导论（Introduction to Ordinary Differential）</td>
<td></td>
</tr>
<tr class="even">
<td>大学物理III及实验（University Physics III and Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>大学物理实验</td>
<td></td>
</tr>
<tr class="even">
<td>数据结构（Data Structures）</td>
<td></td>
</tr>
<tr class="odd">
<td>电子学Ⅰ及实验（Electronics Ⅰ and Lab）</td>
<td></td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大二下学期-2">大二下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第四学期课程（Curriculum in Forth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>工程概率基础（Introduction to Engineering Probability）</td>
<td></td>
</tr>
<tr class="even">
<td>信号与系统（Circuits，Signals and System）</td>
<td></td>
</tr>
<tr class="odd">
<td>逻辑设计（Logic Design）</td>
<td></td>
</tr>
<tr class="even">
<td>数字设计实验（Digital Design Lab）</td>
<td></td>
</tr>
<tr class="odd">
<td>电子学Ⅱ和实验（Electronics Ⅱ and Lab）</td>
<td></td>
</tr>
<tr class="even">
<td>电子学实验</td>
<td></td>
</tr>
<tr class="odd">
<td>微机原理和接口技术（Processors：Hardware, Software，and Interfacing）</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大三上学期-2">大三上学期：</h3>
<table>
<thead>
<tr class="header">
<th>第五学期课程（Curriculum in Fifth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>离散时间信号与系统（Discrete-Time Signals and Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电磁场原理（Electromagnetic Field Theory）</td>
<td></td>
</tr>
<tr class="odd">
<td>固态电子学（Solid-State Electronics）</td>
<td></td>
</tr>
<tr class="even">
<td>单片机原理（MCU Principle）</td>
<td></td>
</tr>
<tr class="odd">
<td>结构化数字设计（含FPGA）Structured Digital Design</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="大三下学期-2">大三下学期：</h3>
<table>
<thead>
<tr class="header">
<th>第六学期课程（Curriculum in Sixth Semester）</th>
<th>学习建议及资料推荐</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>嵌入式微处理系统设计（Embedded Microprocessor System Design）</td>
<td></td>
</tr>
<tr class="even">
<td>通信系统（Communication Systems）</td>
<td></td>
</tr>
<tr class="odd">
<td>线性控制系统（Linear Control Systems）</td>
<td></td>
</tr>
<tr class="even">
<td>电力电子（Power Electronics）</td>
<td></td>
</tr>
<tr class="odd">
<td>VLSI 大规模集成电路系统（Large-scale Integrated Circuit System）</td>
<td></td>
</tr>
<tr class="even">
<td>模拟集成电路（Analog Integrated Circuit）</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <tags>
        <tag>资料分享</tag>
      </tags>
  </entry>
  <entry>
    <title>微机原理实验报告</title>
    <url>/2022/04/30/16-02-06/</url>
    <content><![CDATA[<h1 id="微机原理实验报告">微机原理实验报告</h1>
<h2 id="课程实验1">课程实验1</h2>
<h3 id="stm32仿真开发环境的构建与简单汇编程序的编写">——STM32仿真开发环境的构建与简单汇编程序的编写</h3>
<p>推荐阅读：https://blog.csdn.net/qq_46359697/article/details/115255840</p>
<h3 id="实验报告内容">实验报告内容</h3>
<ol type="1">
<li>实验目标与任务
<ol type="1">
<li>掌握MDK-ARM开发平台的使用，包括程序编写/调试/编译等。</li>
<li>掌握ARM的基本汇编指令，能够理解并编写简单的汇编程序实现某些功能。</li>
</ol></li>
<li>实验内容
<ol type="1">
<li>STM32F407启动代码实现与分析。</li>
<li>编写简单汇编程序：
<ol type="1">
<li>找到3个数字中最大的数字并将结果存储在R0中</li>
<li>将N，N-1，…… 2，1共N个数字相加，将结果存储在R1，当N = 0时，输出的结果为0.</li>
<li>调用子例程实现R3低4位中十六进制转换位对应的ASCII码，并将十六进制数和对应的结果存储在内存中，存储在从20000000开始的单元中</li>
</ol></li>
</ol></li>
<li>实验步骤</li>
</ol>
<h3 id="实验报告">实验报告</h3>
<h4 id="mdk-arm开发平台的使用">MDK-ARM开发平台的使用</h4>
<h5 id="安装软件">安装软件</h5>
<p>使用到的软件：</p>
<ul>
<li>MDK-ARM（微控制器开发工具）</li>
</ul>
<p>uVision是由keil公司开发的集成开发环境（IDE），可以进行代码编辑，文件管理，程序的编译调试等。</p>
<p>目前uVision的版本有uVision2、uVision3、uVision4、uVision5。</p>
<p>我们常说的keil4指的是uVision4，keil5指的是uVision5。</p>
<p>每一个uVision版本下都有4个独立的软件：C51、C251、C166、ARM。</p>
<p>uVision ARM就是MDK，或者可以称为MDK-ARM。这一款软件主要支持ARM7，ARM9，Cortex等ARM内核。</p>
<p>MDK-ARM中中包含PACK工具</p>
<p><img src="/2022/04/30/16-02-06/image-20220501135651588-16513846164571.png" alt="image-20220501135651588" style="zoom: 50%;"></p>
<p>PACK工具可以打开.pack文件，双击下载后文件夹中的 “Keil.STM32F4xx_DFP.2.14.0.pack” 文件，选择默认安装路径，即可完成导入。</p>
<h5 id="新建工程">新建工程</h5>
<p>打开 MDK-ARM，选择 Project -&gt; New uVision Project</p>
<p><img src="/2022/04/30/16-02-06/image-20220501140158387-16513849197395.png" alt="image-20220501140158387" style="zoom:50%;"></p>
<p>选择工程存储路径，并给工程起一个名字。</p>
<p><img src="/2022/04/30/16-02-06/image-20220501140436221-16513850782177.png" alt="image-20220501140436221" style="zoom:50%;"></p>
<p>在弹出的选项卡的搜索框中搜索 “STM32F407”，点击加号，选择具体型号 “STM32F407ZET”</p>
<p><img src="/2022/04/30/16-02-06/image-20220501140958609.png" alt="image-20220501140958609" style="zoom:50%;"></p>
<p>STM32 微控制器命名规则如下：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141117834-16513854807739.png" alt="image-20220501141115297" style="zoom: 33%;"></p>
<p>为了导入启动程序，在新弹出的选项卡中做如下操作：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141406536-165138564869011.png" alt="image-20220501141406536" style="zoom:50%;"></p>
<p>即可得到启动程序</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141447804-165138568967813.png" alt="image-20220501141447804" style="zoom:50%;"></p>
<h5 id="编译程序">编译程序</h5>
<p>直接编译程序，会报错，如下：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141621369-165138578336915.png" alt="image-20220501141621369" style="zoom:50%;"></p>
<p>错误为，没有找到 <code>main()</code> 函数</p>
<p>因此，需要创建一个.c文件来补充 <code>main()</code> 函数：</p>
<p>首先创建一个新文件</p>
<p><img src="/2022/04/30/16-02-06/image-20220501141803519-165138588563917.png" alt="image-20220501141803519" style="zoom:33%;"></p>
<p>保存文件为.c文件</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142026434.png" alt="image-20220501142026434" style="zoom:33%;"></p>
<p>将.c文件加入到工程文件：在 Source Group 1 文件夹上右键，选择 Add Existing Fiels to Group 'Source Group 1' ...</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142117084-165138607853919.png" alt="image-20220501142117084" style="zoom:33%;"></p>
<p>选项卡中选择文件并添加，然后点击 close 关闭</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142207067.png" alt="image-20220501142207067" style="zoom:33%;"></p>
<p>编译成功：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142435430-165138627702721.png" alt="image-20220501142435430" style="zoom:67%;"></p>
<h5 id="程序debug">程序Debug</h5>
<p>在没有器件的情况下无法直接对程序进行Debug，因此需要使用模拟器来仿真，需要进行一定的配置</p>
<p><img src="/2022/04/30/16-02-06/image-20220501142555008-165138635699523.png" alt="image-20220501142555008" style="zoom:50%;"></p>
<p>配置方式在课本P91页：</p>
<figure>
<img src="/2022/04/30/16-02-06/image-20220501142851518-165138653354225.png" alt="image-20220501142851518"><figcaption aria-hidden="true">image-20220501142851518</figcaption>
</figure>
<p>具体操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DARMSTM.DLL</span><br><span class="line">-pSTM32F407ZETx</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/30/16-02-06/image-20220501143156502.png" alt="image-20220501143156502" style="zoom:50%;"></p>
<p>再次点击Debug即可进入Debug模式：</p>
<p><img src="/2022/04/30/16-02-06/image-20220501143314055-165138679821227.png" alt="image-20220501143314055" style="zoom:50%;"></p>
<h4 id="stm32f407启动代码分析">STM32F407启动代码分析</h4>
<h5 id="整体分析">整体分析：</h5>
<p>对于STM32F407启动代码整体的一个描述在 startup_stm32fxxx_xx.s 文件的顶部注释中有着解释，内容如下：</p>
<blockquote>
<p>;* Description: STM32F407xx devices vector table for MDK-ARM toolchain. ;* This module performs: ;* - Set the initial SP ;* - Set the initial PC == Reset_Handler ;* - Set the vector table entries with the exceptions ISR address ;* - Branches to __main in the C library (which eventually calls main()). ;* After Reset the CortexM4 processor is in Thread mode, priority is Privileged, and the Stack is set to Main.</p>
</blockquote>
<p>含义为：</p>
<ul>
<li>设置堆栈指针 <code>SP = _initial_sp</code></li>
<li>设置程序寄存器 <code>PC = Reset_Handler</code></li>
<li>使用例外ISR设置向量表项</li>
<li>配置系统时钟</li>
<li>配置外部 SRAM 用亍程序变量等数据存储(可选)</li>
<li>调用C库中的 <code>__main()</code> 函数，最终调用 <code>main()</code> 函数</li>
</ul>
<h5 id="源代码解释">源代码解释：</h5>
<ol type="1">
<li><p>开辟栈 <em>(STACK)</em> 空间，用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部SRAM的大小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。 <span class="math display">\[
\sf{通知编译器链接\rightarrow分配一片栈空间\rightarrow记录栈顶地址}
\]</span></p>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 89%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">指令</th>
<th style="text-align: left;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>EQU</code></td>
<td style="text-align: left;"><code>EQU</code>是一个伪指令，起作用是定义一个符号，这类似于C语言中的 <code>#define</code> ；<code>EQU</code>可以使用“*”来替代。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>AREA</code></td>
<td style="text-align: left;">用于定义一个新的段（代码段或数据段），并说明段的相关属性。</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SPACE</code></td>
<td style="text-align: left;">用于分配一定数量的内存空间并初始化为0；<code>SPACE</code>跟在<code>AREA</code>后面，用于给新定义的段分配合适大小的内存；SPACE后要跟随数字，指明初始化内存空间的大小；可以使用“%”来替代。</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ALIGN</code></td>
<td style="text-align: left;">编译器指令，对指令或数据存放地址进行对齐（一般跟一个立即数，缺省为4字节）</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack_Size      EQU     0x00000400</span><br><span class="line">;定义一个符号，其中0x400为1KB；此处含义为设置栈空间大小为1KB</span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">;新定义一个段名为STACK的段，不进行初始化，属性为可读，2^3=8字节对齐</span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">;栈本体，这里指令是分配栈大小  </span><br><span class="line">__initial_sp</span><br><span class="line">;标号，表示该地址（这里是末尾，即栈顶地址）</span><br></pre></td></tr></table></figure></li>
<li><p>开辟堆（HEAP）空间，主要用于动态内存分配，也就是说用 <code>malloc()</code>, <code>calloc()</code>等函数分配的变量空间在堆上： <span class="math display">\[
\sf{通知编译器链接\rightarrow记录堆头地址\rightarrow分配一片堆空间\rightarrow记录堆尾地址}
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap_Size       EQU     0x00000200</span><br><span class="line"></span><br><span class="line">                AREA    HEAP, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem        SPACE   Heap_Size</span><br><span class="line">__heap_limit</span><br></pre></td></tr></table></figure></li>
<li><p>独立的过渡代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PRESERVE8 ;指定当前文件的栈按 8B 对齐</span><br><span class="line">THUMB ;表示后面的指令兼容 Thumb 指令集（ARM以前的16位指令集）</span><br></pre></td></tr></table></figure>
<p>这里有一篇<a href="http://www.cnblogs.com/reload/archive/2013/06/27/3159053.html">文章</a>，详细解释了为什么要设置 <code>PRESERVE8</code>。</p></li>
<li><p>向量表：内核在异常时会访问这个表地址，并根据异常类型查表，按表跳转到异常处理函数执行。</p>
<table>
<colgroup>
<col style="width: 11%">
<col style="width: 88%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">指令</th>
<th style="text-align: left;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>EXPORT</code></td>
<td style="text-align: left;">声明全局，可被外部文件使用，同义词 <code>GLOBAL</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>DCD</code></td>
<td style="text-align: left;">以字为单位分配内存，要求4字节对齐且初始化该内存<br><code>DCD</code> 的功能是申请（1个或多个）字地址，并赋初值。每行 <code>DCD</code> 都会生成一个4字节的二进制代码（中断服务代码入口地址）</td>
</tr>
</tbody>
</table>
<p>向量表的位置在代码段的最前面。具体物理地址由连接器的配置参数（IROM1 的地址决定, keil target 中可修改）。如果程序在 Flash 运行， 则中断向量表默认的起始地址是 <code>0x08000000</code>。</p>
<p><code>0x08000000</code> 是flash的首地址, 可以看到从 flash 的首地址开始，依次存储sp指针，Reset_Handler 中断地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">;新定义一个段名为RESRT的段，DATA说明本段用于定义数据段，属性为只读</span><br><span class="line"></span><br><span class="line">;下述语句将3个标号申明为可外部引用，主要提供给连接器用于链接库文件或其他文件。</span><br><span class="line"></span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">;定义一个标号 __Vectors 代表向量表的起始地址</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">;定义一个标号 __Vectors_End 代表向量表的结束地址</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line">;定义一个标号 __Vectors_Size 代表向量表的地址长度</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line"></span><br><span class="line">;!此处省略大量相似语法的代码。76-172行的代码被省略，省略代码为向量表的具体内容</span><br><span class="line">   </span><br><span class="line">                DCD     FPU_IRQHandler                    ; FPU</span><br><span class="line">                </span><br><span class="line">                                         </span><br><span class="line">__Vectors_End</span><br><span class="line"></span><br><span class="line">__Vectors_Size  EQU  __Vectors_End - __Vectors</span><br><span class="line">;向量表的地址长度 __Vectors_Size 可以由 __Vectors_End - __Vectors 得到</span><br></pre></td></tr></table></figure></li>
<li><p>各种中断处理程序 <code>xxx_Handler</code></p>
<table>
<colgroup>
<col style="width: 11%">
<col style="width: 88%">
</colgroup>
<thead>
<tr class="header">
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>PROC</code></td>
<td>定义子程序，与<code>ENDP</code>成对使用，表示子程序结束 同义词 <code>FUNCTION</code></td>
</tr>
<tr class="even">
<td><code>WEAK</code></td>
<td>编译器特性。弱定义，优先使用外部文件定义的标号。<br><code>WEAK</code> 声明其它的同名标号优先于该标号被引用，就是说如果外面声明了同样的标号，会优先调用在外部定义的</td>
</tr>
<tr class="odd">
<td><code>EXPORT</code></td>
<td>声明全局，可被外部文件使用，同义词 <code>GLOBAL</code></td>
</tr>
<tr class="even">
<td><code>IMPORT</code></td>
<td>声明标号来自外部文件，类似于C <code>extern</code></td>
</tr>
<tr class="odd">
<td><code>B</code></td>
<td>跳转到一个标号</td>
</tr>
</tbody>
</table>
<p>先指示编译器汇编一个新的代码段，名为 <code>|.text|</code>，只读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AREA    |.text|, CODE, READONLY</span><br></pre></td></tr></table></figure>
<p>除复位中断外的其它的函数默认跳转到中断后，在原地死循环。</p>
<p>复位程序，也就是默认上电复位后执行的程序</p>
<blockquote>
<p>B：后面跟一个标签，标签直接对应一个地址，B的作用是跳转的标签指示的地址 BX：后面跟一个寄存器，寄存器里面保存地址，BX的作用是跳转到寄存器里面存放的地址 BL：后面跟一个标签，BL跳转到标签指示的地址，并且保存下一条指令地址到R14（即链接寄存器P33） BLX：后面跟一个寄存器，寄存器里面保存地址，并且保存下一条指令地址到R14（即链接寄存器P33）</p>
<p><code>B &#123;条件&#125; 目标地址</code> 条件可选，立即跳转执行。（不返回程序），<code>B .</code> 是死循环while(1);的用法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;Reset handler</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">;利用PROC、ENDP这一对伪指令把程序分为若干个过程，使程序结构更加清晰</span><br><span class="line">                 EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">;WEAK这个声明很重要，它可以让我们在 C 文件中的任意地方，放置中断服务程序，只要保证 C 函数的名字和向量表中的名字一致即可</span><br><span class="line">        IMPORT  SystemInit</span><br><span class="line">        IMPORT  __main</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br></pre></td></tr></table></figure>
<p>其他异常处理程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Dummy Exception Handlers (infinite loops which can be modified)</span><br><span class="line">;_____________________________________________________________</span><br><span class="line">NMI_Handler     PROC</span><br><span class="line">                EXPORT  NMI_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">                </span><br><span class="line">;!此处省略大量相似语法的代码。200-232行的代码被省略，省略代码为向量表的具体内容</span><br><span class="line"></span><br><span class="line">SysTick_Handler PROC</span><br><span class="line">                EXPORT  SysTick_Handler            [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">;B &#123;条件&#125; 目标地址 条件可选，立即跳转执行。（不返回程序），B . 是死循环while(1);的用法</span><br><span class="line">                ENDP</span><br><span class="line">                </span><br><span class="line">Default_Handler PROC</span><br><span class="line">;_____________________________________________________________</span><br><span class="line">                EXPORT  WWDG_IRQHandler                   [WEAK]                                        </span><br><span class="line">                EXPORT  PVD_IRQHandler                    [WEAK]                      </span><br><span class="line">;!此处省略大量相似语法的代码。242-319行的代码被省略，省略代码为向量表的具体内容</span><br><span class="line">                EXPORT  FPU_IRQHandler                    [WEAK]</span><br><span class="line">;_____________________________________________________________</span><br><span class="line">WWDG_IRQHandler                                                       </span><br><span class="line">PVD_IRQHandler                                      </span><br><span class="line"></span><br><span class="line">;!此处省略大量相似语法的代码。324-401行的代码被省略，省略代码为向量表的具体内容</span><br><span class="line"></span><br><span class="line">FPU_IRQHandler  </span><br><span class="line">;_____________________________________________________________</span><br><span class="line">                B       .</span><br><span class="line"></span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">                ALIGN</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>用户堆栈和堆初始化</p>
<ul>
<li>if
<ul>
<li>如果使用了微库（MicroLib），就直接导出堆栈地址符号</li>
</ul></li>
<li>else
<ul>
<li>导入外部程序<code>__use_two_region_memory</code>并马上执行调用</li>
<li>并导出子程序符号<code>__user_initial_stackheap</code>给外部程序调用</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">;**********************************************************************</span><br><span class="line">; User Stack and Heap initialization</span><br><span class="line">;**********************************************************************</span><br><span class="line">; 如果定义了 MICROLIB （微库，keil target 中设置），那么程序执行else后的语句</span><br><span class="line">                 IF      :DEF:__MICROLIB</span><br><span class="line">                </span><br><span class="line">                 EXPORT  __initial_sp</span><br><span class="line">                 EXPORT  __heap_base</span><br><span class="line">                 EXPORT  __heap_limit</span><br><span class="line">                </span><br><span class="line">                 ELSE</span><br><span class="line">                </span><br><span class="line">                 IMPORT  __use_two_region_memory</span><br><span class="line">                 EXPORT  __user_initial_stackheap</span><br><span class="line">                 </span><br><span class="line">__user_initial_stackheap</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =  Heap_Mem</span><br><span class="line">                 LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">                 LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">                 LDR     R3, = Stack_Mem</span><br><span class="line">                 BX      LR</span><br><span class="line"></span><br><span class="line">                 ALIGN</span><br><span class="line"></span><br><span class="line">                 ENDIF</span><br><span class="line"></span><br><span class="line">                 END</span><br><span class="line">;***************END OF FIEL***************</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="启动流程总结">启动流程总结</h5>
<ol type="1">
<li>分配堆栈</li>
<li>向量表</li>
<li>中断/异常处理函数
<ol type="1">
<li>复位程序（上电复位默认执行的函数）
<ol type="1">
<li>SystemInit()</li>
<li>__main()</li>
</ol></li>
<li>其他异常处理程序</li>
</ol></li>
<li>导出堆栈信息等给外部使用</li>
</ol>
<h5 id="stm32-总体启动顺序">STM32 总体启动顺序</h5>
<p><code>.s启动文件</code> -&gt; <code>中断处理函数外部定义</code> -&gt; <code>SystemInit()</code> -&gt; <code>SetSysClock</code> -&gt; <code>__main</code> -&gt; <code>main()</code></p>
<h5 id="全部代码展示">全部代码展示</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;******************** (C) COPYRIGHT 2017 STMicroelectronics ********************</span><br><span class="line">;* File Name          : startup_stm32f407xx.s</span><br><span class="line">;* Author             : MCD Application Team</span><br><span class="line">;* Description        : STM32F407xx devices vector table for MDK-ARM toolchain. </span><br><span class="line">;*                      This module performs:</span><br><span class="line">;*                      - Set the initial SP</span><br><span class="line">;*                      - Set the initial PC == Reset_Handler</span><br><span class="line">;*                      - Set the vector table entries with the exceptions ISR address</span><br><span class="line">;*                      - Branches to __main in the C library (which eventually</span><br><span class="line">;*                        calls main()).</span><br><span class="line">;*                      After Reset the CortexM4 processor is in Thread mode,</span><br><span class="line">;*                      priority is Privileged, and the Stack is set to Main.</span><br><span class="line">;* &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt;   </span><br><span class="line">;*******************************************************************************</span><br><span class="line">; </span><br><span class="line">;* Redistribution and use in source and binary forms, with or without modification,</span><br><span class="line">;* are permitted provided that the following conditions are met:</span><br><span class="line">;*   1. Redistributions of source code must retain the above copyright notice,</span><br><span class="line">;*      this list of conditions and the following disclaimer.</span><br><span class="line">;*   2. Redistributions in binary form must reproduce the above copyright notice,</span><br><span class="line">;*      this list of conditions and the following disclaimer in the documentation</span><br><span class="line">;*      and/or other materials provided with the distribution.</span><br><span class="line">;*   3. Neither the name of STMicroelectronics nor the names of its contributors</span><br><span class="line">;*      may be used to endorse or promote products derived from this software</span><br><span class="line">;*      without specific prior written permission.</span><br><span class="line">;*</span><br><span class="line">;* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span><br><span class="line">;* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span><br><span class="line">;* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span><br><span class="line">;* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</span><br><span class="line">;* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span><br><span class="line">;* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span><br><span class="line">;* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span><br><span class="line">;* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span><br><span class="line">;* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span><br><span class="line">;* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><br><span class="line">; </span><br><span class="line">;*******************************************************************************</span><br><span class="line"></span><br><span class="line">; Amount of memory (in bytes) allocated for Stack</span><br><span class="line">; Tailor this value to your application needs</span><br><span class="line">; &lt;h&gt; Stack Configuration</span><br><span class="line">;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class="line">; &lt;/h&gt;·</span><br><span class="line"></span><br><span class="line">Stack_Size      EQU     0x00000400</span><br><span class="line"></span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; &lt;h&gt; Heap Configuration</span><br><span class="line">;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class="line">; &lt;/h&gt;</span><br><span class="line"></span><br><span class="line">Heap_Size       EQU     0x00000200</span><br><span class="line"></span><br><span class="line">                AREA    HEAP, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem        SPACE   Heap_Size</span><br><span class="line">__heap_limit</span><br><span class="line"></span><br><span class="line">                PRESERVE8</span><br><span class="line">                THUMB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     0                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br><span class="line"></span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler                   ; Window WatchDog                                        </span><br><span class="line">                DCD     PVD_IRQHandler                    ; PVD through EXTI Line detection                        </span><br><span class="line">                DCD     TAMP_STAMP_IRQHandler             ; Tamper and TimeStamps through the EXTI line            </span><br><span class="line">                DCD     RTC_WKUP_IRQHandler               ; RTC Wakeup through the EXTI line                       </span><br><span class="line">                DCD     FLASH_IRQHandler                  ; FLASH                                           </span><br><span class="line">                DCD     RCC_IRQHandler                    ; RCC                                             </span><br><span class="line">                DCD     EXTI0_IRQHandler                  ; EXTI Line0                                             </span><br><span class="line">                DCD     EXTI1_IRQHandler                  ; EXTI Line1                                             </span><br><span class="line">                DCD     EXTI2_IRQHandler                  ; EXTI Line2                                             </span><br><span class="line">                DCD     EXTI3_IRQHandler                  ; EXTI Line3                                             </span><br><span class="line">                DCD     EXTI4_IRQHandler                  ; EXTI Line4                                             </span><br><span class="line">                DCD     DMA1_Stream0_IRQHandler           ; DMA1 Stream 0                                   </span><br><span class="line">                DCD     DMA1_Stream1_IRQHandler           ; DMA1 Stream 1                                   </span><br><span class="line">                DCD     DMA1_Stream2_IRQHandler           ; DMA1 Stream 2                                   </span><br><span class="line">                DCD     DMA1_Stream3_IRQHandler           ; DMA1 Stream 3                                   </span><br><span class="line">                DCD     DMA1_Stream4_IRQHandler           ; DMA1 Stream 4                                   </span><br><span class="line">                DCD     DMA1_Stream5_IRQHandler           ; DMA1 Stream 5                                   </span><br><span class="line">                DCD     DMA1_Stream6_IRQHandler           ; DMA1 Stream 6                                   </span><br><span class="line">                DCD     ADC_IRQHandler                    ; ADC1, ADC2 and ADC3s                            </span><br><span class="line">                DCD     CAN1_TX_IRQHandler                ; CAN1 TX                                                </span><br><span class="line">                DCD     CAN1_RX0_IRQHandler               ; CAN1 RX0                                               </span><br><span class="line">                DCD     CAN1_RX1_IRQHandler               ; CAN1 RX1                                               </span><br><span class="line">                DCD     CAN1_SCE_IRQHandler               ; CAN1 SCE                                               </span><br><span class="line">                DCD     EXTI9_5_IRQHandler                ; External Line[9:5]s                                    </span><br><span class="line">                DCD     TIM1_BRK_TIM9_IRQHandler          ; TIM1 Break and TIM9                   </span><br><span class="line">                DCD     TIM1_UP_TIM10_IRQHandler          ; TIM1 Update and TIM10                 </span><br><span class="line">                DCD     TIM1_TRG_COM_TIM11_IRQHandler     ; TIM1 Trigger and Commutation and TIM11</span><br><span class="line">                DCD     TIM1_CC_IRQHandler                ; TIM1 Capture Compare                                   </span><br><span class="line">                DCD     TIM2_IRQHandler                   ; TIM2                                            </span><br><span class="line">                DCD     TIM3_IRQHandler                   ; TIM3                                            </span><br><span class="line">                DCD     TIM4_IRQHandler                   ; TIM4                                            </span><br><span class="line">                DCD     I2C1_EV_IRQHandler                ; I2C1 Event                                             </span><br><span class="line">                DCD     I2C1_ER_IRQHandler                ; I2C1 Error                                             </span><br><span class="line">                DCD     I2C2_EV_IRQHandler                ; I2C2 Event                                             </span><br><span class="line">                DCD     I2C2_ER_IRQHandler                ; I2C2 Error                                               </span><br><span class="line">                DCD     SPI1_IRQHandler                   ; SPI1                                            </span><br><span class="line">                DCD     SPI2_IRQHandler                   ; SPI2                                            </span><br><span class="line">                DCD     USART1_IRQHandler                 ; USART1                                          </span><br><span class="line">                DCD     USART2_IRQHandler                 ; USART2                                          </span><br><span class="line">                DCD     USART3_IRQHandler                 ; USART3                                          </span><br><span class="line">                DCD     EXTI15_10_IRQHandler              ; External Line[15:10]s                                  </span><br><span class="line">                DCD     RTC_Alarm_IRQHandler              ; RTC Alarm (A and B) through EXTI Line                  </span><br><span class="line">                DCD     OTG_FS_WKUP_IRQHandler            ; USB OTG FS Wakeup through EXTI line                        </span><br><span class="line">                DCD     TIM8_BRK_TIM12_IRQHandler         ; TIM8 Break and TIM12                  </span><br><span class="line">                DCD     TIM8_UP_TIM13_IRQHandler          ; TIM8 Update and TIM13                 </span><br><span class="line">                DCD     TIM8_TRG_COM_TIM14_IRQHandler     ; TIM8 Trigger and Commutation and TIM14</span><br><span class="line">                DCD     TIM8_CC_IRQHandler                ; TIM8 Capture Compare                                   </span><br><span class="line">                DCD     DMA1_Stream7_IRQHandler           ; DMA1 Stream7                                           </span><br><span class="line">                DCD     FMC_IRQHandler                    ; FMC                                             </span><br><span class="line">                DCD     SDIO_IRQHandler                   ; SDIO                                            </span><br><span class="line">                DCD     TIM5_IRQHandler                   ; TIM5                                            </span><br><span class="line">                DCD     SPI3_IRQHandler                   ; SPI3                                            </span><br><span class="line">                DCD     UART4_IRQHandler                  ; UART4                                           </span><br><span class="line">                DCD     UART5_IRQHandler                  ; UART5                                           </span><br><span class="line">                DCD     TIM6_DAC_IRQHandler               ; TIM6 and DAC1&amp;2 underrun errors                   </span><br><span class="line">                DCD     TIM7_IRQHandler                   ; TIM7                   </span><br><span class="line">                DCD     DMA2_Stream0_IRQHandler           ; DMA2 Stream 0                                   </span><br><span class="line">                DCD     DMA2_Stream1_IRQHandler           ; DMA2 Stream 1                                   </span><br><span class="line">                DCD     DMA2_Stream2_IRQHandler           ; DMA2 Stream 2                                   </span><br><span class="line">                DCD     DMA2_Stream3_IRQHandler           ; DMA2 Stream 3                                   </span><br><span class="line">                DCD     DMA2_Stream4_IRQHandler           ; DMA2 Stream 4                                   </span><br><span class="line">                DCD     ETH_IRQHandler                    ; Ethernet                                        </span><br><span class="line">                DCD     ETH_WKUP_IRQHandler               ; Ethernet Wakeup through EXTI line                      </span><br><span class="line">                DCD     CAN2_TX_IRQHandler                ; CAN2 TX                                                </span><br><span class="line">                DCD     CAN2_RX0_IRQHandler               ; CAN2 RX0                                               </span><br><span class="line">                DCD     CAN2_RX1_IRQHandler               ; CAN2 RX1                                               </span><br><span class="line">                DCD     CAN2_SCE_IRQHandler               ; CAN2 SCE                                               </span><br><span class="line">                DCD     OTG_FS_IRQHandler                 ; USB OTG FS                                      </span><br><span class="line">                DCD     DMA2_Stream5_IRQHandler           ; DMA2 Stream 5                                   </span><br><span class="line">                DCD     DMA2_Stream6_IRQHandler           ; DMA2 Stream 6                                   </span><br><span class="line">                DCD     DMA2_Stream7_IRQHandler           ; DMA2 Stream 7                                   </span><br><span class="line">                DCD     USART6_IRQHandler                 ; USART6                                           </span><br><span class="line">                DCD     I2C3_EV_IRQHandler                ; I2C3 event                                             </span><br><span class="line">                DCD     I2C3_ER_IRQHandler                ; I2C3 error                                             </span><br><span class="line">                DCD     OTG_HS_EP1_OUT_IRQHandler         ; USB OTG HS End Point 1 Out                      </span><br><span class="line">                DCD     OTG_HS_EP1_IN_IRQHandler          ; USB OTG HS End Point 1 In                       </span><br><span class="line">                DCD     OTG_HS_WKUP_IRQHandler            ; USB OTG HS Wakeup through EXTI                         </span><br><span class="line">                DCD     OTG_HS_IRQHandler                 ; USB OTG HS                                      </span><br><span class="line">                DCD     DCMI_IRQHandler                   ; DCMI  </span><br><span class="line">                DCD     0                                 ; Reserved				                              </span><br><span class="line">                DCD     HASH_RNG_IRQHandler               ; Hash and Rng</span><br><span class="line">                DCD     FPU_IRQHandler                    ; FPU</span><br><span class="line">                </span><br><span class="line">                                         </span><br><span class="line">__Vectors_End</span><br><span class="line"></span><br><span class="line">__Vectors_Size  EQU  __Vectors_End - __Vectors</span><br><span class="line"></span><br><span class="line">                AREA    |.text|, CODE, READONLY</span><br><span class="line"></span><br><span class="line">; Reset handler</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">        IMPORT  SystemInit</span><br><span class="line">        IMPORT  __main</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br><span class="line"></span><br><span class="line">; Dummy Exception Handlers (infinite loops which can be modified)</span><br><span class="line"></span><br><span class="line">NMI_Handler     PROC</span><br><span class="line">                EXPORT  NMI_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">HardFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  HardFault_Handler          [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">MemManage_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  MemManage_Handler          [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">BusFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  BusFault_Handler           [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">UsageFault_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  UsageFault_Handler         [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">SVC_Handler     PROC</span><br><span class="line">                EXPORT  SVC_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">DebugMon_Handler\</span><br><span class="line">                PROC</span><br><span class="line">                EXPORT  DebugMon_Handler           [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">PendSV_Handler  PROC</span><br><span class="line">                EXPORT  PendSV_Handler             [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">SysTick_Handler PROC</span><br><span class="line">                EXPORT  SysTick_Handler            [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">Default_Handler PROC</span><br><span class="line"></span><br><span class="line">                EXPORT  WWDG_IRQHandler                   [WEAK]                                        </span><br><span class="line">                EXPORT  PVD_IRQHandler                    [WEAK]                      </span><br><span class="line">                EXPORT  TAMP_STAMP_IRQHandler             [WEAK]         </span><br><span class="line">                EXPORT  RTC_WKUP_IRQHandler               [WEAK]                     </span><br><span class="line">                EXPORT  FLASH_IRQHandler                  [WEAK]                                         </span><br><span class="line">                EXPORT  RCC_IRQHandler                    [WEAK]                                            </span><br><span class="line">                EXPORT  EXTI0_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  EXTI1_IRQHandler                  [WEAK]                                             </span><br><span class="line">                EXPORT  EXTI2_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  EXTI3_IRQHandler                  [WEAK]                                           </span><br><span class="line">                EXPORT  EXTI4_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  DMA1_Stream0_IRQHandler           [WEAK]                                </span><br><span class="line">                EXPORT  DMA1_Stream1_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream2_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream3_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream4_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream5_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream6_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  ADC_IRQHandler                    [WEAK]                         </span><br><span class="line">                EXPORT  CAN1_TX_IRQHandler                [WEAK]                                                </span><br><span class="line">                EXPORT  CAN1_RX0_IRQHandler               [WEAK]                                               </span><br><span class="line">                EXPORT  CAN1_RX1_IRQHandler               [WEAK]                                                </span><br><span class="line">                EXPORT  CAN1_SCE_IRQHandler               [WEAK]                                                </span><br><span class="line">                EXPORT  EXTI9_5_IRQHandler                [WEAK]                                    </span><br><span class="line">                EXPORT  TIM1_BRK_TIM9_IRQHandler          [WEAK]                  </span><br><span class="line">                EXPORT  TIM1_UP_TIM10_IRQHandler          [WEAK]                </span><br><span class="line">                EXPORT  TIM1_TRG_COM_TIM11_IRQHandler     [WEAK] </span><br><span class="line">                EXPORT  TIM1_CC_IRQHandler                [WEAK]                                   </span><br><span class="line">                EXPORT  TIM2_IRQHandler                   [WEAK]                                            </span><br><span class="line">                EXPORT  TIM3_IRQHandler                   [WEAK]                                            </span><br><span class="line">                EXPORT  TIM4_IRQHandler                   [WEAK]                                            </span><br><span class="line">                EXPORT  I2C1_EV_IRQHandler                [WEAK]                                             </span><br><span class="line">                EXPORT  I2C1_ER_IRQHandler                [WEAK]                                             </span><br><span class="line">                EXPORT  I2C2_EV_IRQHandler                [WEAK]                                            </span><br><span class="line">                EXPORT  I2C2_ER_IRQHandler                [WEAK]                                               </span><br><span class="line">                EXPORT  SPI1_IRQHandler                   [WEAK]                                           </span><br><span class="line">                EXPORT  SPI2_IRQHandler                   [WEAK]                                            </span><br><span class="line">                EXPORT  USART1_IRQHandler                 [WEAK]                                          </span><br><span class="line">                EXPORT  USART2_IRQHandler                 [WEAK]                                          </span><br><span class="line">                EXPORT  USART3_IRQHandler                 [WEAK]                                         </span><br><span class="line">                EXPORT  EXTI15_10_IRQHandler              [WEAK]                                  </span><br><span class="line">                EXPORT  RTC_Alarm_IRQHandler              [WEAK]                  </span><br><span class="line">                EXPORT  OTG_FS_WKUP_IRQHandler            [WEAK]                        </span><br><span class="line">                EXPORT  TIM8_BRK_TIM12_IRQHandler         [WEAK]                 </span><br><span class="line">                EXPORT  TIM8_UP_TIM13_IRQHandler          [WEAK]                 </span><br><span class="line">                EXPORT  TIM8_TRG_COM_TIM14_IRQHandler     [WEAK] </span><br><span class="line">                EXPORT  TIM8_CC_IRQHandler                [WEAK]                                   </span><br><span class="line">                EXPORT  DMA1_Stream7_IRQHandler           [WEAK]                                          </span><br><span class="line">                EXPORT  FMC_IRQHandler                    [WEAK]                                             </span><br><span class="line">                EXPORT  SDIO_IRQHandler                   [WEAK]                                             </span><br><span class="line">                EXPORT  TIM5_IRQHandler                   [WEAK]                                             </span><br><span class="line">                EXPORT  SPI3_IRQHandler                   [WEAK]                                             </span><br><span class="line">                EXPORT  UART4_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  UART5_IRQHandler                  [WEAK]                                            </span><br><span class="line">                EXPORT  TIM6_DAC_IRQHandler               [WEAK]                   </span><br><span class="line">                EXPORT  TIM7_IRQHandler                   [WEAK]                    </span><br><span class="line">                EXPORT  DMA2_Stream0_IRQHandler           [WEAK]                                  </span><br><span class="line">                EXPORT  DMA2_Stream1_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA2_Stream2_IRQHandler           [WEAK]                                    </span><br><span class="line">                EXPORT  DMA2_Stream3_IRQHandler           [WEAK]                                    </span><br><span class="line">                EXPORT  DMA2_Stream4_IRQHandler           [WEAK]                                 </span><br><span class="line">                EXPORT  ETH_IRQHandler                    [WEAK]                                         </span><br><span class="line">                EXPORT  ETH_WKUP_IRQHandler               [WEAK]                     </span><br><span class="line">                EXPORT  CAN2_TX_IRQHandler                [WEAK]                                               </span><br><span class="line">                EXPORT  CAN2_RX0_IRQHandler               [WEAK]                                               </span><br><span class="line">                EXPORT  CAN2_RX1_IRQHandler               [WEAK]                                               </span><br><span class="line">                EXPORT  CAN2_SCE_IRQHandler               [WEAK]                                               </span><br><span class="line">                EXPORT  OTG_FS_IRQHandler                 [WEAK]                                       </span><br><span class="line">                EXPORT  DMA2_Stream5_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA2_Stream6_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  DMA2_Stream7_IRQHandler           [WEAK]                                   </span><br><span class="line">                EXPORT  USART6_IRQHandler                 [WEAK]                                           </span><br><span class="line">                EXPORT  I2C3_EV_IRQHandler                [WEAK]                                              </span><br><span class="line">                EXPORT  I2C3_ER_IRQHandler                [WEAK]                                              </span><br><span class="line">                EXPORT  OTG_HS_EP1_OUT_IRQHandler         [WEAK]                      </span><br><span class="line">                EXPORT  OTG_HS_EP1_IN_IRQHandler          [WEAK]                      </span><br><span class="line">                EXPORT  OTG_HS_WKUP_IRQHandler            [WEAK]                        </span><br><span class="line">                EXPORT  OTG_HS_IRQHandler                 [WEAK]                                      </span><br><span class="line">                EXPORT  DCMI_IRQHandler                   [WEAK]                                                                                 </span><br><span class="line">                EXPORT  HASH_RNG_IRQHandler               [WEAK]</span><br><span class="line">                EXPORT  FPU_IRQHandler                    [WEAK]</span><br><span class="line">                </span><br><span class="line">WWDG_IRQHandler                                                       </span><br><span class="line">PVD_IRQHandler                                      </span><br><span class="line">TAMP_STAMP_IRQHandler                  </span><br><span class="line">RTC_WKUP_IRQHandler                                </span><br><span class="line">FLASH_IRQHandler                                                       </span><br><span class="line">RCC_IRQHandler                                                            </span><br><span class="line">EXTI0_IRQHandler                                                          </span><br><span class="line">EXTI1_IRQHandler                                                           </span><br><span class="line">EXTI2_IRQHandler                                                          </span><br><span class="line">EXTI3_IRQHandler                                                         </span><br><span class="line">EXTI4_IRQHandler                                                          </span><br><span class="line">DMA1_Stream0_IRQHandler                                       </span><br><span class="line">DMA1_Stream1_IRQHandler                                          </span><br><span class="line">DMA1_Stream2_IRQHandler                                          </span><br><span class="line">DMA1_Stream3_IRQHandler                                          </span><br><span class="line">DMA1_Stream4_IRQHandler                                          </span><br><span class="line">DMA1_Stream5_IRQHandler                                          </span><br><span class="line">DMA1_Stream6_IRQHandler                                          </span><br><span class="line">ADC_IRQHandler                                         </span><br><span class="line">CAN1_TX_IRQHandler                                                            </span><br><span class="line">CAN1_RX0_IRQHandler                                                          </span><br><span class="line">CAN1_RX1_IRQHandler                                                           </span><br><span class="line">CAN1_SCE_IRQHandler                                                           </span><br><span class="line">EXTI9_5_IRQHandler                                                </span><br><span class="line">TIM1_BRK_TIM9_IRQHandler                        </span><br><span class="line">TIM1_UP_TIM10_IRQHandler                      </span><br><span class="line">TIM1_TRG_COM_TIM11_IRQHandler  </span><br><span class="line">TIM1_CC_IRQHandler                                               </span><br><span class="line">TIM2_IRQHandler                                                           </span><br><span class="line">TIM3_IRQHandler                                                           </span><br><span class="line">TIM4_IRQHandler                                                           </span><br><span class="line">I2C1_EV_IRQHandler                                                         </span><br><span class="line">I2C1_ER_IRQHandler                                                         </span><br><span class="line">I2C2_EV_IRQHandler                                                        </span><br><span class="line">I2C2_ER_IRQHandler                                                           </span><br><span class="line">SPI1_IRQHandler                                                          </span><br><span class="line">SPI2_IRQHandler                                                           </span><br><span class="line">USART1_IRQHandler                                                       </span><br><span class="line">USART2_IRQHandler                                                       </span><br><span class="line">USART3_IRQHandler                                                      </span><br><span class="line">EXTI15_10_IRQHandler                                            </span><br><span class="line">RTC_Alarm_IRQHandler                            </span><br><span class="line">OTG_FS_WKUP_IRQHandler                                </span><br><span class="line">TIM8_BRK_TIM12_IRQHandler                      </span><br><span class="line">TIM8_UP_TIM13_IRQHandler                       </span><br><span class="line">TIM8_TRG_COM_TIM14_IRQHandler  </span><br><span class="line">TIM8_CC_IRQHandler                                               </span><br><span class="line">DMA1_Stream7_IRQHandler                                                 </span><br><span class="line">FMC_IRQHandler                                                            </span><br><span class="line">SDIO_IRQHandler                                                            </span><br><span class="line">TIM5_IRQHandler                                                            </span><br><span class="line">SPI3_IRQHandler                                                            </span><br><span class="line">UART4_IRQHandler                                                          </span><br><span class="line">UART5_IRQHandler                                                          </span><br><span class="line">TIM6_DAC_IRQHandler                            </span><br><span class="line">TIM7_IRQHandler                              </span><br><span class="line">DMA2_Stream0_IRQHandler                                         </span><br><span class="line">DMA2_Stream1_IRQHandler                                          </span><br><span class="line">DMA2_Stream2_IRQHandler                                           </span><br><span class="line">DMA2_Stream3_IRQHandler                                           </span><br><span class="line">DMA2_Stream4_IRQHandler                                        </span><br><span class="line">ETH_IRQHandler                                                         </span><br><span class="line">ETH_WKUP_IRQHandler                                </span><br><span class="line">CAN2_TX_IRQHandler                                                           </span><br><span class="line">CAN2_RX0_IRQHandler                                                          </span><br><span class="line">CAN2_RX1_IRQHandler                                                          </span><br><span class="line">CAN2_SCE_IRQHandler                                                          </span><br><span class="line">OTG_FS_IRQHandler                                                    </span><br><span class="line">DMA2_Stream5_IRQHandler                                          </span><br><span class="line">DMA2_Stream6_IRQHandler                                          </span><br><span class="line">DMA2_Stream7_IRQHandler                                          </span><br><span class="line">USART6_IRQHandler                                                        </span><br><span class="line">I2C3_EV_IRQHandler                                                          </span><br><span class="line">I2C3_ER_IRQHandler                                                          </span><br><span class="line">OTG_HS_EP1_OUT_IRQHandler                           </span><br><span class="line">OTG_HS_EP1_IN_IRQHandler                            </span><br><span class="line">OTG_HS_WKUP_IRQHandler                                </span><br><span class="line">OTG_HS_IRQHandler                                                   </span><br><span class="line">DCMI_IRQHandler                                                                                                             </span><br><span class="line">HASH_RNG_IRQHandler</span><br><span class="line">FPU_IRQHandler  </span><br><span class="line">           </span><br><span class="line">                B       .</span><br><span class="line"></span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">                ALIGN</span><br><span class="line"></span><br><span class="line">;*******************************************************************************</span><br><span class="line">; User Stack and Heap initialization</span><br><span class="line">;*******************************************************************************</span><br><span class="line">                 IF      :DEF:__MICROLIB</span><br><span class="line">                </span><br><span class="line">                 EXPORT  __initial_sp</span><br><span class="line">                 EXPORT  __heap_base</span><br><span class="line">                 EXPORT  __heap_limit</span><br><span class="line">                </span><br><span class="line">                 ELSE</span><br><span class="line">                </span><br><span class="line">                 IMPORT  __use_two_region_memory</span><br><span class="line">                 EXPORT  __user_initial_stackheap</span><br><span class="line">                 </span><br><span class="line">__user_initial_stackheap</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =  Heap_Mem</span><br><span class="line">                 LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">                 LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">                 LDR     R3, = Stack_Mem</span><br><span class="line">                 BX      LR</span><br><span class="line"></span><br><span class="line">                 ALIGN</span><br><span class="line"></span><br><span class="line">                 ENDIF</span><br><span class="line"></span><br><span class="line">                 END</span><br><span class="line"></span><br><span class="line">;************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE*****</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="简单汇编程序实现">简单汇编程序实现</h3>
<h4 id="三数中寻找最大数">三数中寻找最大数</h4>
<h5 id="题目要求">题目要求：</h5>
<p>找到3个数字中最大的数字并将结果存储在R0中。</p>
<h5 id="代码展示">代码展示：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N1				EQU		456</span><br><span class="line">N2				EQU		1278</span><br><span class="line">N3				EQU		85</span><br><span class="line">Stack_Size		EQU		0x00000400</span><br><span class="line">				AREA	Mystack,	NOINIT,	READWRITE,	ALIGN=3</span><br><span class="line">Stack_Mem		SPACE	Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">				AREA	Reset,	DATA,	READONLY</span><br><span class="line">__Vectors		DCD		__initial_sp</span><br><span class="line">				DCD		Reset_Handler</span><br><span class="line">					</span><br><span class="line">				THUMB</span><br><span class="line">				PRESERVE8</span><br><span class="line">				AREA	Init,	CODE,	READONLY</span><br><span class="line">				ENTRY</span><br><span class="line">				</span><br><span class="line">Reset_Handler</span><br><span class="line">		LDR		R0,=N1</span><br><span class="line">		LDR		R1,=N2</span><br><span class="line">		LDR		R2,=N3</span><br><span class="line">		CMP		R0,R1</span><br><span class="line">		BHI		next</span><br><span class="line">		MOV		R0,R1</span><br><span class="line">next</span><br><span class="line">		CMP		R0,R2</span><br><span class="line">		BHI		deadloop</span><br><span class="line">		MOV		R0,R2</span><br><span class="line">deadloop</span><br><span class="line">		B	deadloop</span><br><span class="line">		NOP</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Rebuild started: Project: Project_1</span><br><span class="line">*** Using Compiler &#x27;V6.16&#x27;, folder: &#x27;D:\MDK\ARM\ARMCLANG\Bin&#x27;</span><br><span class="line">Rebuild target &#x27;Target 1&#x27;</span><br><span class="line">assembling startup_stm32f407xx.s...</span><br><span class="line">compiling system_stm32f4xx.c...</span><br><span class="line">linking...</span><br><span class="line">.\Objects\Project_1.axf: Error: L6320W: Ignoring --entry command. Cannot find argument &#x27;Reset_Handler&#x27;.</span><br><span class="line">.\Objects\Project_1.axf: Warning: L6320W: Ignoring --first command. Cannot find argument &#x27;__Vectors&#x27;.</span><br><span class="line">Not enough information to list image symbols.</span><br><span class="line">Not enough information to list load addresses in the image map.</span><br><span class="line">Finished: 2 information, 1 warning and 1 error messages.</span><br><span class="line">&quot;.\Objects\Project_1.axf&quot; - 1 Error(s), 1 Warning(s).</span><br><span class="line">Target not created.</span><br><span class="line">Build Time Elapsed:  00:00:00</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/30/16-02-06/image-20220506231919016-165185037825611.png" alt="image-20220506231919016" style="zoom:50%;"></p>
<p>课本代码会报错，因此修正代码课本代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N1				EQU		456</span><br><span class="line">N2				EQU		1278</span><br><span class="line">N3				EQU		85</span><br><span class="line">Stack_Size		EQU		0x00000400</span><br><span class="line">				AREA	Mystack,	NOINIT,	READWRITE,	ALIGN=3</span><br><span class="line">Stack_Mem		SPACE	Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">				AREA	Reset,	DATA,	READONLY</span><br><span class="line">				EXPORT  __Vectors</span><br><span class="line">					</span><br><span class="line">__Vectors		DCD		__initial_sp</span><br><span class="line">				DCD		Reset_Handler</span><br><span class="line">					</span><br><span class="line">				THUMB</span><br><span class="line">				PRESERVE8</span><br><span class="line">				AREA	Init,	CODE,	READONLY</span><br><span class="line">				ENTRY</span><br><span class="line">				</span><br><span class="line">Reset_Handler</span><br><span class="line">		EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">		LDR		R0,=N1</span><br><span class="line">		LDR		R1,=N2</span><br><span class="line">		LDR		R2,=N3</span><br><span class="line">		CMP		R0,R1</span><br><span class="line">		BHI		next</span><br><span class="line">		MOV		R0,R1</span><br><span class="line">next</span><br><span class="line">		CMP		R0,R2</span><br><span class="line">		BHI		deadloop</span><br><span class="line">		MOV		R0,R2</span><br><span class="line">deadloop</span><br><span class="line">		B	deadloop</span><br><span class="line">		NOP</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/30/16-02-06/image-20220506231830620-16518503124549.png" alt="image-20220506231830620" style="zoom:50%;"></p>
<h5 id="结果展示">结果展示：</h5>
<p><img src="/2022/04/30/16-02-06/image-20220506232317154-165185059873513.png" alt="image-20220506232317154" style="zoom:50%;"></p>
<h4 id="n个数相加">N个数相加</h4>
<h5 id="题目要求-1">题目要求：</h5>
<p>将N，N-1，…… 2，1共N个数字相加，将结果存储在R1，当N = 0时，输出的结果为0。</p>
<h5 id="代码展示-1">代码展示：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N				EQU		10</span><br><span class="line">Stack_Size		EQU		0x00000400</span><br><span class="line">				AREA	Mystack,	NOINIT,	READWRITE,	ALIGN=3</span><br><span class="line">Stack_Mem		SPACE	Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">				AREA	Reset,	DATA,	READONLY</span><br><span class="line">				EXPORT  __Vectors</span><br><span class="line">				</span><br><span class="line">__Vectors		DCD		__initial_sp</span><br><span class="line">				DCD		Reset_Handler</span><br><span class="line">					</span><br><span class="line">				THUMB</span><br><span class="line">				PRESERVE8</span><br><span class="line">				AREA	Init,	CODE,	READONLY</span><br><span class="line">				ENTRY</span><br><span class="line">				</span><br><span class="line">Reset_Handler</span><br><span class="line">		</span><br><span class="line">		EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">		</span><br><span class="line">		LDR		R0,	=N</span><br><span class="line">		MOV		R1,	#0</span><br><span class="line">loop</span><br><span class="line">		ADD		r1, r0</span><br><span class="line">		SUBS	r0,	#1</span><br><span class="line">		BNE		loop</span><br><span class="line">deadloop</span><br><span class="line">		B	deadloop</span><br><span class="line">		NOP</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>
<h5 id="结果展示-1">结果展示：</h5>
<p><img src="/2022/04/30/16-02-06/image-20220506213516914-16518441195105.png" alt="image-20220506213516914" style="zoom:50%;"></p>
<h4 id="十六进制转asic码">十六进制转ASIC码</h4>
<h5 id="题目要求-2">题目要求：</h5>
<p>调用子例程实现R3低4位中十六进制转换位对应的ASCII码，并将十六进制数和对应的结果存储在内存中，存储在从20000000开始的单元中</p>
<h5 id="代码实现">代码实现：</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack_Size		EQU		0x00000400</span><br><span class="line">				AREA	Mystack,	NOINIT,	READWRITE,	ALIGN=3</span><br><span class="line">Stack_Mem		SPACE	Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">				AREA	Reset,	DATA,	READONLY</span><br><span class="line">				EXPORT  __Vectors</span><br><span class="line">__Vectors		DCD		__initial_sp</span><br><span class="line">				DCD		Reset_Handler</span><br><span class="line">					</span><br><span class="line">				THUMB</span><br><span class="line">				PRESERVE8</span><br><span class="line">				AREA	Init,	CODE,	READONLY</span><br><span class="line">				ENTRY</span><br><span class="line">				</span><br><span class="line">Reset_Handler</span><br><span class="line">		EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">		MOV 	R3,0x0A</span><br><span class="line">		CMP		R3,#9</span><br><span class="line">		BLE		Next</span><br><span class="line">		ADD		R3,R3,#7</span><br><span class="line">Next</span><br><span class="line">		ADD		R3,R3,#7</span><br><span class="line">deadloop</span><br><span class="line">		B	deadloop</span><br><span class="line">		NOP</span><br><span class="line">		END</span><br></pre></td></tr></table></figure>
<h5 id="结果展示-2">结果展示：</h5>
<p><img src="/2022/04/30/16-02-06/image-20220506212809459.png" alt="image-20220506212809459" style="zoom:50%;"></p>
<p><img src="/2022/04/30/16-02-06/image-20220506213109858-16518438733371-16518438752213.png" alt="image-20220506213109858" style="zoom:50%;"></p>
<h2 id="课程实验2">课程实验2</h2>
<h3 id="使用stm32f401ve控制led">——使用STM32F401VE控制LED</h3>
<h3 id="实验报告内容-1">实验报告内容</h3>
<ol type="1">
<li><p>实验目标与任务</p>
<ol type="1">
<li>掌握STM32F40x的GPIO输入输出的使用。</li>
<li>主寄存器方法，库函数方法设置GPIO。</li>
<li>了解如何使用STM32CubeMX构建初始代码。</li>
</ol></li>
<li><p>实验内容</p>
<ol type="1">
<li><p>开关控制LED灯。当按下按钮时，对应的LED灯亮500ms，然后熄灭。</p>
<p><img src="/2022/04/30/16-02-06/image-20220507073550593-16518801528251.png" alt="image-20220507073550593" style="zoom:100%;"></p></li>
<li><p>要求:需要详细的步骤，包括proteus仿真电路和程序。</p></li>
</ol></li>
<li><p>实验步骤</p></li>
</ol>
<h3 id="实验报告-1">实验报告</h3>
<h4 id="软件使用">软件使用</h4>
<ul>
<li><p>STMCubeMX：</p>
<p>STMCubeMX是ST公司推出的一种自动创建单片机工程及初始化代码的工具</p></li>
<li><p>Proteus 8 Professional：</p>
<p>Proteus是一款EDA工具软件，它不仅具有其它EDA工具软件的仿真功能，还能较好的仿真单片机及外围器件。</p></li>
<li><p>MDK-ARM：</p>
<p>Keil公司开发的ARM开发工具MDK，是用来开发基于ARM核的系列微控制器的嵌入式应用程序</p></li>
</ul>
<h4 id="实验流程">实验流程</h4>
<p>使用 Proteus 搭建仿真电路 -&gt; 使用 CubeMX 生成初始化代码 -&gt; 使用 MDK-ARM 编写主函数，生成 .hex 文件 -&gt; 将 .hex 文件添加到仿真电路中</p>
<h4 id="工程建立">工程建立</h4>
<ol type="1">
<li><p>使用Proteus建立仿真文件：</p>
<ol type="1">
<li><p>打开Proteus，选择新建一个原理图文件</p>
<p><img src="/2022/04/30/16-02-06/image-20220509173625891.png" alt="image-20220509173625891" style="zoom:67%;"></p></li>
<li><p>使用快捷键“Ctrl+S”将文件保存到电脑中</p></li>
<li><p>添加元器件：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509174203888-16520893270293.png" alt="image-20220509174203888" style="zoom:67%;"></p></li>
<li><p>在工程中添加如下元器件：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509174431386-16520894731985.png" alt="image-20220509174431386" style="zoom:50%;"></p>
<p>添加电源端和地：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509174549453-16520895514167.png" alt="image-20220509174549453" style="zoom:50%;"></p>
<p>添加好后如下图所示：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509174748405-16520896698899.png" alt="image-20220509174748405" style="zoom:67%;"></p></li>
<li><p>按实验要求接线，如下图：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509174839001-165208972044111.png" alt="image-20220509174839001" style="zoom:67%;"></p></li>
<li><p>创建仿真文件完成</p></li>
</ol></li>
<li><p>使用STMCubeMX建立初始化代码：</p>
<ol type="1">
<li><p>建立工程：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509175001429.png" alt="image-20220509175001429" style="zoom:33%;"></p></li>
<li><p>初次使用等待联网下载器件库，下载完成后做如下操作：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509175144590-165208990612213.png" alt="image-20220509175144590" style="zoom:67%;"></p></li>
<li><p>进入如下界面，点击管理工程</p>
<p><img src="/2022/04/30/16-02-06/image-20220509175343646.png" alt="image-20220509175343646" style="zoom:67%;"></p></li>
<li><p>配置工程基本信息：</p>
<figure>
<img src="/2022/04/30/16-02-06/image-20220509175857840-165209034195317.png" alt="image-20220509175857840"><figcaption aria-hidden="true">image-20220509175857840</figcaption>
</figure></li>
<li><p>打开生成的文件夹，看到如下目录，进入MDK-ARM文件夹，打开其中的keil工程</p>
<p><img src="/2022/04/30/16-02-06/image-20220509180023158-165209042452819.png" alt="image-20220509180023158" style="zoom:50%;"></p>
<p><img src="/2022/04/30/16-02-06/image-20220509180057731-165209045950421.png" alt="image-20220509180057731" style="zoom:50%;"></p></li>
<li><p>打开工程中的main.c文件编写代码：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509180339476-165209062098523.png" alt="image-20220509180339476" style="zoom:50%;"></p></li>
</ol></li>
<li><p>使用MDK开发环境编写代码操控LED灯闪烁：</p>
<ol type="1">
<li><p>首先确认工程配置为输出.hex文件：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509180518790.png" alt="image-20220509180518790" style="zoom:33%;"></p></li>
<li><p>在main.c中添加如下代码：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509181336172-165209121805525.png" alt="image-20220509181336172" style="zoom:67%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_LED</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC-&gt;AHB1ENR |= <span class="number">1</span>&lt;&lt;<span class="number">2</span>;</span><br><span class="line">	</span><br><span class="line">	GPIOC-&gt;MODER |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">	GPIOC-&gt;OTYPER = <span class="number">0x0</span>;</span><br><span class="line">	GPIOC-&gt;OSPEEDR = <span class="number">0x0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line">	init_LED();</span><br><span class="line"><span class="comment">/* USER CODE END Init */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">		GPIOC-&gt;BSRR = (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">		HAL_Delay(<span class="number">500</span>);</span><br><span class="line">		GPIOC-&gt;BSRR = (<span class="number">1</span>&lt;&lt;<span class="number">16</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">17</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">18</span>);</span><br><span class="line">		HAL_Delay(<span class="number">500</span>);</span><br><span class="line"><span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编译程序：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509181515288-165209131696027.png" alt="image-20220509181515288" style="zoom:33%;"></p></li>
</ol></li>
<li><p>将 .hex 文件添加到仿真电路中</p>
<ol type="1">
<li><p>双击STM32F401VE，弹出编辑卡，点击程序文件：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509181755170-165209147690229.png" alt="image-20220509181755170" style="zoom:50%;"></p></li>
<li><p>在如下路径中找到.hex文件</p>
<p><img src="/2022/04/30/16-02-06/image-20220509182030753-165209163517931.png" alt="image-20220509182030753" style="zoom:50%;"></p></li>
<li><p>选中文件，即可将文件拷入到仿真器件中，然后运行仿真：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509182153882.png" alt="image-20220509182153882" style="zoom:33%;"></p></li>
<li><p>即可看到小灯闪烁。</p></li>
</ol></li>
</ol>
<h4 id="使用st库函数来编写代码">使用ST库函数来编写代码</h4>
<ol type="1">
<li><p>使用CubeMX生成代码：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509182403928.png" alt="image-20220509182403928" style="zoom:50%;"></p></li>
<li><p>返回keil，允许重加载代码：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509182454542.png" alt="image-20220509182454542" style="zoom:50%;"></p></li>
<li><p>新代码中增加了一个初始化函数</p>
<p><img src="/2022/04/30/16-02-06/image-20220509182524721.png" alt="image-20220509182524721" style="zoom:50%;"></p></li>
<li><p>使用库函数来实现与刚才相同的功能：</p>
<p><img src="/2022/04/30/16-02-06/image-20220509182719004.png" alt="image-20220509182719004" style="zoom:50%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_SET);</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>重新编译并将代码拷入仿真软件，可以得到相同的效果。</p></li>
</ol>
<h4 id="实现题目要求">实现题目要求：</h4>
<ol type="1">
<li><p>结果展示：</p>
<p><img src="/2022/04/30/16-02-06/GIF 2022-5-9 18-35-34.gif" alt="GIF 2022-5-9 18-35-34" style="zoom:50%;"></p></li>
<li><p>代码展示（简化后的代码，包含注释）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">MX_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义按键变量并初始化为1</span></span><br><span class="line">	<span class="type">char</span> button_0 = GPIO_PIN_SET;</span><br><span class="line">	<span class="type">char</span> button_1 = GPIO_PIN_SET;</span><br><span class="line">	<span class="type">char</span> button_2 = GPIO_PIN_SET;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化HAL、系统时钟和需要的GPIO口</span></span><br><span class="line">    HAL_Init();</span><br><span class="line">    SystemClock_Config();</span><br><span class="line">    MX_GPIO_Init();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//循环读取GPIO口的值</span></span><br><span class="line">        button_0 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_13);</span><br><span class="line">		button_1 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_14);</span><br><span class="line">		button_2 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_15);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果GPIO口的值被拉到0</span></span><br><span class="line">        <span class="keyword">if</span>(button_0 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">//延迟10ms消抖</span></span><br><span class="line">			HAL_Delay(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//如果GPIO口仍为0</span></span><br><span class="line">			<span class="keyword">if</span>(button_0 == GPIO_PIN_RESET)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">//GPIOC_0口输出高电平，点亮LED灯</span></span><br><span class="line">				HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0, GPIO_PIN_SET);</span><br><span class="line">                <span class="comment">//延时500ms</span></span><br><span class="line">				HAL_Delay(<span class="number">500</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(button_1 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_Delay(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">if</span>(button_1 == GPIO_PIN_RESET)</span><br><span class="line">			&#123;</span><br><span class="line">				HAL_GPIO_WritePin(GPIOC, GPIO_PIN_1, GPIO_PIN_SET);</span><br><span class="line">				HAL_Delay(<span class="number">500</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(button_2 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_Delay(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">if</span>(button_2 == GPIO_PIN_RESET)</span><br><span class="line">			&#123;</span><br><span class="line">				HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_SET);</span><br><span class="line">				HAL_Delay(<span class="number">500</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将所有GPIO口输出置为低电平</span></span><br><span class="line">		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CbueMX生成的系统时钟配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  RCC_OscInitTypeDef RCC_OscInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  RCC_ClkInitTypeDef RCC_ClkInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Configure the main internal regulator output voltage</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  __HAL_RCC_PWR_CLK_ENABLE();</span><br><span class="line">  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initializes the RCC Oscillators according to the specified parameters</span></span><br><span class="line"><span class="comment">  * in the RCC_OscInitTypeDef structure.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;</span><br><span class="line">  RCC_OscInitStruct.HSIState = RCC_HSI_ON;</span><br><span class="line">  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;</span><br><span class="line">  <span class="keyword">if</span> (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initializes the CPU, AHB and APB buses clocks</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK</span><br><span class="line">                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;</span><br><span class="line">  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;</span><br><span class="line">  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;</span><br><span class="line">  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line">  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CubeMX生成的GPIO初始化代码</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">MX_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* GPIO Ports Clock Enable */</span></span><br><span class="line">  __HAL_RCC_GPIOC_CLK_ENABLE();</span><br><span class="line">  __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Configure GPIO pin Output Level */</span></span><br><span class="line">  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Configure GPIO pins : PC0 PC1 PC2 */</span></span><br><span class="line">  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2;</span><br><span class="line">  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">  GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">  HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Configure GPIO pins : PA13 PA14 PA15 */</span></span><br><span class="line">  GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;</span><br><span class="line">  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">  GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">  HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对main.h中的函数声明进行实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Error_Handler</span><span class="params">(<span class="type">void</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>因为按键触发后即点亮灯长达500ms，因此可以不进行按键消抖，已经经过验证，故主函数中可做如下修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> button_0 = GPIO_PIN_RESET;</span><br><span class="line">	<span class="type">char</span> button_1 = GPIO_PIN_RESET;</span><br><span class="line">	<span class="type">char</span> button_2 = GPIO_PIN_RESET;</span><br><span class="line">    </span><br><span class="line">    HAL_Init();</span><br><span class="line">    SystemClock_Config();</span><br><span class="line">    MX_GPIO_Init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     	button_0 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_13);</span><br><span class="line">		button_1 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_14);</span><br><span class="line">		button_2 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_15);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(button_0 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0, GPIO_PIN_SET);</span><br><span class="line">            HAL_Delay(<span class="number">500</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(button_1 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_1, GPIO_PIN_SET);</span><br><span class="line">            HAL_Delay(<span class="number">500</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(button_2 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">            HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_SET);</span><br><span class="line">            HAL_Delay(<span class="number">500</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>附完整代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN Header */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file           : main.c</span></span><br><span class="line"><span class="comment">  * @brief          : Main program body</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  * @attention</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Copyright (c) 2022 STMicroelectronics.</span></span><br><span class="line"><span class="comment">  * All rights reserved.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * This software is licensed under terms that can be found in the LICENSE file</span></span><br><span class="line"><span class="comment">  * in the root directory of this software component.</span></span><br><span class="line"><span class="comment">  * If no LICENSE file comes with this software, it is provided AS-IS.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  ******************************************************************************</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">/* USER CODE END Header */</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private typedef -----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PTD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END PTD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private define ------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PD */</span></span><br><span class="line"><span class="comment">/* USER CODE END PD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private macro -------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PM */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END PM */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables ---------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes -----------------------------------------------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">MX_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/* USER CODE BEGIN PFP */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END PFP */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private user code ---------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  The application entry point.</span></span><br><span class="line"><span class="comment">  * @retval int</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 1 */</span></span><br><span class="line">	<span class="type">char</span> button_0 = GPIO_PIN_SET;</span><br><span class="line">	<span class="type">char</span> button_1 = GPIO_PIN_SET;</span><br><span class="line">	<span class="type">char</span> button_2 = GPIO_PIN_SET;</span><br><span class="line">  <span class="comment">/* USER CODE END 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* MCU Configuration--------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></span><br><span class="line">  HAL_Init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Init */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END Init */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the system clock */</span></span><br><span class="line">  SystemClock_Config();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN SysInit */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END SysInit */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">		</span><br><span class="line">		button_0 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_13);</span><br><span class="line">		button_1 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_14);</span><br><span class="line">		button_2 = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_15);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(button_0 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_Delay(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">if</span>(button_0 == GPIO_PIN_RESET)</span><br><span class="line">			&#123;</span><br><span class="line">				HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0, GPIO_PIN_SET);</span><br><span class="line">				HAL_Delay(<span class="number">500</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(button_1 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_Delay(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">if</span>(button_1 == GPIO_PIN_RESET)</span><br><span class="line">			&#123;</span><br><span class="line">				HAL_GPIO_WritePin(GPIOC, GPIO_PIN_1, GPIO_PIN_SET);</span><br><span class="line">				HAL_Delay(<span class="number">500</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(button_2 == GPIO_PIN_RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			HAL_Delay(<span class="number">10</span>);</span><br><span class="line">			<span class="keyword">if</span>(button_2 == GPIO_PIN_RESET)</span><br><span class="line">			&#123;</span><br><span class="line">				HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2, GPIO_PIN_SET);</span><br><span class="line">				HAL_Delay(<span class="number">500</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);</span><br><span class="line">		</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">		</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief System Clock Configuration</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  RCC_OscInitTypeDef RCC_OscInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  RCC_ClkInitTypeDef RCC_ClkInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Configure the main internal regulator output voltage</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  __HAL_RCC_PWR_CLK_ENABLE();</span><br><span class="line">  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initializes the RCC Oscillators according to the specified parameters</span></span><br><span class="line"><span class="comment">  * in the RCC_OscInitTypeDef structure.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;</span><br><span class="line">  RCC_OscInitStruct.HSIState = RCC_HSI_ON;</span><br><span class="line">  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;</span><br><span class="line">  <span class="keyword">if</span> (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initializes the CPU, AHB and APB buses clocks</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK</span><br><span class="line">                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;</span><br><span class="line">  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;</span><br><span class="line">  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;</span><br><span class="line">  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line">  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief GPIO Initialization Function</span></span><br><span class="line"><span class="comment">  * @param None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">MX_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* GPIO Ports Clock Enable */</span></span><br><span class="line">  __HAL_RCC_GPIOC_CLK_ENABLE();</span><br><span class="line">  __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Configure GPIO pin Output Level */</span></span><br><span class="line">  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Configure GPIO pins : PC0 PC1 PC2 */</span></span><br><span class="line">  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2;</span><br><span class="line">  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">  GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">  HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Configure GPIO pins : PA13 PA14 PA15 */</span></span><br><span class="line">  GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;</span><br><span class="line">  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">  GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">  HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 4 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE END 4 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  This function is executed in case of error occurrence.</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Error_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Error_Handler_Debug */</span></span><br><span class="line">  <span class="comment">/* User can add his own implementation to report the HAL error return state */</span></span><br><span class="line">  __disable_irq();</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Error_Handler_Debug */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  USE_FULL_ASSERT</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Reports the name of the source file and the source line number</span></span><br><span class="line"><span class="comment">  *         where the assert_param error has occurred.</span></span><br><span class="line"><span class="comment">  * @param  file: pointer to the source file name</span></span><br><span class="line"><span class="comment">  * @param  line: assert_param error line source number</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">assert_failed</span><span class="params">(<span class="type">uint8_t</span> *file, <span class="type">uint32_t</span> line)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 6 */</span></span><br><span class="line">  <span class="comment">/* User can add his own implementation to report the file name and line number,</span></span><br><span class="line"><span class="comment">     ex: printf(&quot;Wrong parameters value: file %s on line %d\r\n&quot;, file, line) */</span></span><br><span class="line">  <span class="comment">/* USER CODE END 6 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USE_FULL_ASSERT */</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>Homework</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/06/06/21-00-26/</url>
    <content><![CDATA[<figure>
<img src="/2022/06/06/21-00-26/image-20220606210048954-16545204512881.png" alt="image-20220606210048954"><figcaption aria-hidden="true">image-20220606210048954</figcaption>
</figure>
<figure>
<img src="/2022/06/06/21-00-26/image-20220701175231248.png" alt="image-20220701175231248"><figcaption aria-hidden="true">image-20220701175231248</figcaption>
</figure>
<figure>
<img src="/2022/06/06/21-00-26/image-20220701181041908.png" alt="image-20220701181041908"><figcaption aria-hidden="true">image-20220701181041908</figcaption>
</figure>
]]></content>
  </entry>
  <entry>
    <title>STM32G431-Nucleo-64开发板使用小记</title>
    <url>/2022/06/24/15-48-41/</url>
    <content><![CDATA[<h1 id="stm32g431-nucleo-64开发板使用小记">STM32G431-Nucleo-64开发板使用小记</h1>
<h2 id="stm32g431-nucleo-64开发板">STM32G431-Nucleo-64开发板</h2>
<h3 id="基本介绍">基本介绍</h3>
<p>实物图片：<img src="/2022/06/24/15-48-41/en.nucleo-g431rb.jpg" alt="en.nucleo-g431rb"></p>
<p>引脚示意图：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220625140101348.png" alt="image-20220625140101348"><figcaption aria-hidden="true">image-20220625140101348</figcaption>
</figure>
<p>特别提醒：如果要设置频率为170MHz（最大频率），需要修改输入为24MHz</p>
<p><img src="/2022/06/24/15-48-41/image-20220702201055670.png" alt="image-20220702201055670" style="zoom:50%;"></p>
<h3 id="点亮led灯">点亮LED灯</h3>
<h4 id="软件选择">软件选择</h4>
<p>使用CubeMX与MAD-ARM</p>
<ul>
<li><p>STMCubeMX：</p>
<p>STMCubeMX是ST公司推出的一种自动创建单片机工程及初始化代码的工具。</p></li>
<li><p>MDK-ARM：</p>
<p>Keil公司开发的ARM开发工具MDK，是用来开发基于ARM核的系列微控制器的嵌入式应用程序。</p></li>
</ul>
<h4 id="实验流程">实验流程</h4>
<p>使用 CubeMX 生成初始化代码 -&gt; 使用 MDK-ARM 编写主函数并编译 -&gt; 使用开发板自带的ST-LINK将编译好的程序烧录到开发板 -&gt; 搭建实物电路 -&gt; 开发板上电，观察现象。</p>
<h4 id="具体操作">具体操作</h4>
<p>打开CubeMX，可以看到如下界面。点击红色方框内的ACCESS TO MCU SELECTRO选择芯片型号。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624155754981.png" alt="image-20220624155754981"><figcaption aria-hidden="true">image-20220624155754981</figcaption>
</figure>
<p>输入芯片型号查找对应芯片，选择“STM32G431RBT6”芯片。具体操作如图所示，操作执行后点击Start Progect进入配置页面。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624161212803.png" alt="image-20220624161212803"><figcaption aria-hidden="true">image-20220624161212803</figcaption>
</figure>
<p>芯片配置页面如下：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624161504627.png" alt="image-20220624161504627"><figcaption aria-hidden="true">image-20220624161504627</figcaption>
</figure>
<p>配置包括 “Pinout &amp; Configuration”、“Clock Configuration”、“Project Manager” 和 “Tools”。</p>
<p>首先配置 “Project Manager”，方式如下：其中 “Code Generator” 和 “Advanced Setings” 暂时用不到。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624162039334.png" alt="image-20220624162039334"><figcaption aria-hidden="true">image-20220624162039334</figcaption>
</figure>
<p>想要点亮LED灯，我们需要对GPIO引脚进行控制，因此返回 “Pinout &amp; Configuration” 配置选项卡，进行输入输出引脚配置。我们选择引脚 PC3 ，将其初始化为高电平，并将输出电平再高低之间进行切换，使用HEL函数延时，每隔1000ms进行一次变换。具体操作如图所示：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624162854160.png" alt="image-20220624162854160"><figcaption aria-hidden="true">image-20220624162854160</figcaption>
</figure>
<p>最后点击生成代码。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624163308481.png" alt="image-20220624163308481"><figcaption aria-hidden="true">image-20220624163308481</figcaption>
</figure>
<p>使用MDK-ARM打开工程，查看CubeMX生成的代码：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624164703328.png" alt="image-20220624164703328"><figcaption aria-hidden="true">image-20220624164703328</figcaption>
</figure>
<p>在主函数中插入我们要编写的LED闪烁代码：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624172922991.png" alt="image-20220624172922991"><figcaption aria-hidden="true">image-20220624172922991</figcaption>
</figure>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_SET);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">HAL_GPIO_WritePin(GPIOC, GPIO_PIN_3, GPIO_PIN_RESET);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624173238440.png" alt="image-20220624173238440"><figcaption aria-hidden="true">image-20220624173238440</figcaption>
</figure>
<p>连接电路图，结果展示：</p>
<p><img src="/2022/06/24/15-48-41/image-20220624174456175.png" alt="image-20220624174456175" style="zoom:33%;"></p>
<h3 id="开发板配置">开发板配置</h3>
<p>开发板中的用户按键是高电平有效，默认状态下接PC13。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220702140416463.png" alt="image-20220702140416463"><figcaption aria-hidden="true">image-20220702140416463</figcaption>
</figure>
<p>ST Board 的默认配置中使用外部中断配置按键。</p>
<p>如果使用GPIO口输入模式来实现按键行为，则需要配置为 Pull-down 模式</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624174830465.png" alt="image-20220624174830465"><figcaption aria-hidden="true">image-20220624174830465</figcaption>
</figure>
<p>基本工程配置：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624175021820.png" alt="image-20220624175021820"><figcaption aria-hidden="true">image-20220624175021820</figcaption>
</figure>
<p>直接生成工程：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624175042732.png" alt="image-20220624175042732"><figcaption aria-hidden="true">image-20220624175042732</figcaption>
</figure>
<p>可以看到，针对于这个开发板，默认芯片时钟配置如下：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624180243123.png" alt="image-20220624180243123"><figcaption aria-hidden="true">image-20220624180243123</figcaption>
</figure>
<h3 id="学习使用cubemx中的example">学习使用CubeMX中的Example</h3>
<p>首先打开CubeMX进入工程选项界面，选择 “Example Selector” 。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624192415831.png" alt="image-20220624192415831"><figcaption aria-hidden="true">image-20220624192415831</figcaption>
</figure>
<p>续：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624192555608.png" alt="image-20220624192555608"><figcaption aria-hidden="true">image-20220624192555608</figcaption>
</figure>
<p>在生成选项中，选择生成目录，然后直接使用MDK-ARM打开即可：</p>
<p><img src="/2022/06/24/15-48-41/image-20220624192653458.png" alt="image-20220624192653458" style="zoom:30%;"></p>
<p>打开文档中的readme.txt文件，阅读该例程的使用方法：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220624193003158.png" alt="image-20220624193003158"><figcaption aria-hidden="true">image-20220624193003158</figcaption>
</figure>
<p>阅读文档可知，PA08-PA11分别输出四种不同占空比的PWM波形。</p>
<p>编译文件并烧录到开发板中，使用示波器测试PWM波形，得如下结果：</p>
<p>如果对Example中的代码进行了修改并重新编译，可能烧录会出现报错，报错如下：</p>
<p><img src="/2022/06/24/15-48-41/image-20220625170231754.png" alt="image-20220625170231754" style="zoom: 25%;"></p>
<p>该报错可阅读<a href="https://blog.csdn.net/weixin_42108484/article/details/81272006">此文章</a>寻求解决方案。</p>
<h3 id="按键控制led灯">按键控制LED灯</h3>
<p>首先打开之前 Nucleo-G431RB 的 CubeMX 工程文档，打开其中的 “Nucleo-G431RB_TEST.ioc” 文件：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220625162251778.png" alt="image-20220625162251778"><figcaption aria-hidden="true">image-20220625162251778</figcaption>
</figure>
<p>将其中的 PC2 GPIO口配置为输入 IO 口，具体配置为输入模式、上拉输入。</p>
<p>注意：选择 GPIO 口的输入配置要依据实际电路的连接方式。在我的电路连接中，我将按键的一端与开发板的 GND 相连，另一端与 PC2 相连。则此时应该选择上拉输入——IO 口没有外部信号输入时，STM32 检测到是高电平，有信号时（按键按下时），跟随信号电平（接地，变为低电平）。</p>
<p>将 PC3 GPIO口配置为输出，默认输出为高电平（执行初始化函数 <code>MX_GPIO_Init()</code> 时会输出高电平）。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220625162220949.png" alt="image-20220625162220949"><figcaption aria-hidden="true">image-20220625162220949</figcaption>
</figure>
<p>生成代码，使用MDK-ARM打开生成好的工程文件，在工程文件中的 main.c 文件做如下修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Private define ------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PD */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUTTON HAL_GPIO_ReadPin(Button_In_GPIO_Port, Button_In_Pin)</span></span><br><span class="line"><span class="comment">/* USER CODE END PD */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//省略……</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略……</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">    HAL_GPIO_WritePin(User_White_LED_GPIO_Port, User_White_LED_Pin, GPIO_PIN_RESET);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">      <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">        <span class="keyword">if</span>(BUTTON == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          HAL_Delay(<span class="number">10</span>);</span><br><span class="line">          <span class="keyword">if</span>(BUTTON == <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">while</span>(BUTTON == <span class="number">0</span>);</span><br><span class="line">            HAL_GPIO_TogglePin(User_White_LED_GPIO_Port, User_White_LED_Pin);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END 3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改完成后，即可连接电路，检验效果。上述代码执行效果为：</p>
<p>按下按键时可以检测到按键被按下，松手后执行任务（改变LED灯亮灭）。</p>
<p>效果如图：</p>
<h3 id="串口通信">串口通信</h3>
<p>STM32中串口通信有三种方式：</p>
<ul>
<li><p>轮询</p>
<ul>
<li>轮询式串口通信：在主函数的 <code>while(1)</code> 中不停地调用串口通信函数进行通信。</li>
<li>优点：实现逻辑简单</li>
<li>缺点：查询方式下CPU的负担较重，浪费了处理器的能力，不能够很好的处理其他的事件</li>
</ul></li>
<li><p>中断</p>
<ul>
<li><p>中断式串口通信：在接收到信息或需要发送数据时产生中断，在中断服务程序中完成数据的接收与发送。</p></li>
<li><p>优点：相比于轮询式，中断式对CPU利用率要高。</p></li>
<li><blockquote>
<p>缺点：</p>
<p>复杂的系统中，比如移动机器人，处理器需要处理串行口通信，多个传感器数据的采集以及处理，实时轨迹的生成，运动轨迹插补以及位置闭环控制等等任务，牵扯到多个中断的优先级分配问题。为了保证数据发送与接收的可靠性，需要把UART的中断优先级设计较高，但是系统可能还有其他的需要更高优先级的中断，必须保证其定时的准确，这样就有可能造成串行通讯的中断不能及时响应，从而造成数据丢失。</p>
</blockquote></li>
</ul></li>
<li><p>DMA</p>
<ul>
<li>DMA：Direct Memory Access （直接内存访问）。使用DMA进行串口通信时，CPU只需要数据传输开始和结束时做一点处理外，在传输过程中可以进行其他的工作。</li>
<li>如果传输的数据量较大，或者传输速度超过115200时，建议选择DMA方式实现串口通信。</li>
</ul></li>
</ul>
<p>串口通信函数：推荐使用C标准库中的 <code>printf()</code> 函数进行串口通信。想要在单片机使用 <code>printf()</code> 需要：</p>
<ol type="1">
<li>包含头文件 <code>#include &lt;stdio.h&gt;</code></li>
<li>在 Options for Target... 选项卡的 Target 选项栏中的 Code Generation 区域勾选 Use MicroLIB</li>
<li>进行串口重定向——即重新实现 <code>fputc()</code></li>
</ol>
<h4 id="查询模式-printf函数重定向">查询模式 &amp; printf()函数重定向</h4>
<p>配置串口：注意在Nucleo-G431RB开发板上只能使用 PA2 和 PA3 引脚来实现开发板接usb线与电脑进行串口通信。其中 PA2 和 PA3 引脚可以选择 LPUART1 和 USART2 两种。这里我们选择 LPUART1 进行测试。串口调试的配置与串口测试软件保持一致即可。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220627201123958.png" alt="image-20220627201123958"><figcaption aria-hidden="true">image-20220627201123958</figcaption>
</figure>
<p>生成代码，打开工程，进行工程设置：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627201706218.png" alt="image-20220627201706218" style="zoom: 40%;"></p>
<p>如果不设置使用 Use MicroLIB，也可以添加如下代码实现串口重定向：</p>
<p><img src="/2022/06/24/15-48-41/image-20220703135818223.png" alt="image-20220703135818223" style="zoom:50%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> import(__use_no_semihosting)</span></span><br><span class="line"><span class="comment">//标准库需要的支持函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE __stdout;</span><br><span class="line"><span class="comment">//定义_sys_exit()以避免使用半主机模式</span></span><br><span class="line"><span class="type">void</span> _sys_exit(<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)<span class="comment">//如果使用GCC编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)<span class="comment">//keil中适用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">	HAL_UART_Transmit(&amp;hlpuart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//hlpuart1需要根据你的配置修改</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure>
<p>添加代码：</p>
<ol type="1">
<li><p>添加头文件：user_log.h文件见目录： “HAL库小记 -&gt; 串口调试策率 -&gt; 日志打印文件”</p>
<p><img src="/2022/06/24/15-48-41/image-20220627202133564.png" alt="image-20220627202133564" style="zoom: 33%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_log.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br></pre></td></tr></table></figure></li>
<li><p>重写 <code>fputc()</code> 函数：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627201930878.png" alt="image-20220627201930878" style="zoom: 33%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">	HAL_UART_Transmit(&amp;hlpuart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//hlpuart1需要根据你的配置修改</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记录另一种写法，或许会更加规范（适用范围广）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)<span class="comment">//如果使用GCC编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)<span class="comment">//keil中适用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">	HAL_UART_Transmit(&amp;huart2, (<span class="type">uint8_t</span>*) &amp;ch, <span class="number">1</span>, <span class="number">0xffff</span>);</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//网上说现在还需要加上这个函数，但是我没使用过gcc编译所以没有验证过这部分代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//_write函數在syscalls.c中， 使用__weak定義， 所以可以直接在其他文件中定義_write函數</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">__attribute__((weak)) <span class="type">int</span> _write(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> DataIdx;</span><br><span class="line">	<span class="keyword">for</span> (DataIdx = <span class="number">0</span>; DataIdx &lt; len; DataIdx++)</span><br><span class="line">	&#123;</span><br><span class="line">		__io_putchar(*ptr++);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>添加测试代码：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627202102623.png" alt="image-20220627202102623" style="zoom: 33%;"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">user_main_info(<span class="string">&quot;init HAL&quot;</span>);</span><br><span class="line">user_main_info(<span class="string">&quot;Config System Clock&quot;</span>);</span><br><span class="line">user_main_info(<span class="string">&quot;GPIO init finished&quot;</span>);</span><br><span class="line">user_main_info(<span class="string">&quot;UART init finished&quot;</span>);</span><br><span class="line"> <span class="comment">/* USER CODE END 2 */</span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* Infinite loop */</span></span><br><span class="line"> <span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line">user_printf(<span class="string">&quot;___  ___        _                   &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;|  \\/  |       | |                  &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| .  . | _   _ | |      ___    __ _ &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| |\\/| || | | || |     / _ \\  / _` |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| |  | || |_| || |____| (_) || (_| |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;\\_|  |_/ \\__, |\\_____/ \\___/  \\__, |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;          __/ |                __/ |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;         |___/                |___/ &quot;</span>);</span><br><span class="line"></span><br><span class="line">user_main_info(<span class="string">&quot;Enter while(1)&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>测试结果：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627202356953.png" alt="image-20220627202356953" style="zoom:50%;"></p>
<h4 id="中断方式">中断方式</h4>
<p>使用CubeMX配置串口，打开相应串口中断</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220703175857659.png" alt="image-20220703175857659"><figcaption aria-hidden="true">image-20220703175857659</figcaption>
</figure>
<p>打开工程，修改 uart.c 实现串口重定向：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> import(__use_no_semihosting)</span></span><br><span class="line"><span class="comment">//标准库需要的支持函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE __stdout;</span><br><span class="line"><span class="comment">//定义_sys_exit()以避免使用半主机模式</span></span><br><span class="line"><span class="type">void</span> _sys_exit(<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)<span class="comment">//如果使用GCC编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)<span class="comment">//keil中适用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">	HAL_UART_Transmit(&amp;hlpuart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//hlpuart1需要根据你的配置修改</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure>
<p>打开 main.c，配置中断服务函数</p>
<h4 id="dma">DMA</h4>
<p><strong>DMA传输方式</strong></p>
<p><strong>方法1</strong>：DMA_Mode_Normal，正常模式，</p>
<p>当一次DMA数据传输完后，停止DMA传送 ，也就是只传输一次　</p>
<p><strong>方法2</strong>：DMA_Mode_Circular ，循环传输模式</p>
<p>当传输结束时，硬件自动会将传输数据量寄存器进行重装，进行下一轮的数据传输。也就是多次传输模式</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MDg4OTMwMw==&amp;mid=2247496701&amp;idx=3&amp;sn=f5876279a224d3f4fb3eca76c7027e00&amp;chksm=e9f9e6c5de8e6fd3609e133873cf85c922fd9243579cf11cf14a658b248484579659288a0518&amp;scene=21#wechat_redirect">DMA原理</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/92379957">Map回调函数</a></p>
<p>https://www.its203.com/article/qq_26575553/89374803#:~:text=%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8F1%E7%9A%84MCU%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%AFF2...F4%EF%BC%8C%E7%94%9A%E8%87%B3</p>
<h3 id="寸-tft-lcd显示">1.8寸 TFT LCD显示</h3>
<p>使用CubeMX配置引脚，其中 PA5 引脚连接VCC供电。</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220627183433259.png" alt="image-20220627183433259"><figcaption aria-hidden="true">image-20220627183433259</figcaption>
</figure>
<p>生成代码，然后对代码进行修改：</p>
<ol type="1">
<li><p>解压LCD_Driver.zip到CubeMX生成的MDK-ARM文件加中：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627200134162.png" alt="image-20220627200134162" style="zoom:50%;"></p></li>
<li><p>打开工程，将解压的文件添加的你的工程中：</p>
<p><img src="/2022/06/24/15-48-41/image-20220627200249439.png" alt="image-20220627200249439" style="zoom:50%;"></p></li>
<li><p>将头文件包含到main.c文件中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd_init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pic.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br></pre></td></tr></table></figure></li>
<li><p>打开lcd_init.h文件，修改其中的 “LCD端口定义” ，将端口定义与连线相匹配。</p></li>
<li><p>注释掉主函数中的 <code>MX_GPIO_Init();</code> 并将复制下述代码进行测试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LCD_Init();<span class="comment">//LCD初始化</span></span><br><span class="line">LCD_Fill(<span class="number">0</span>,<span class="number">0</span>,LCD_W,LCD_H,WHITE);</span><br><span class="line">LCD_ShowString(<span class="number">24</span>,<span class="number">30</span>,<span class="string">&quot;Hello,World!&quot;</span>,RED,WHITE,<span class="number">16</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/06/24/15-48-41/image-20220627200731016.png" alt="image-20220627200731016"><figcaption aria-hidden="true">image-20220627200731016</figcaption>
</figure></li>
</ol>
<h3 id="定时器">定时器</h3>
<p>使用STM32的定时器首先要理解STM32的时钟树，STM32中的时钟源是可配置的。有三种时钟源供选择：</p>
<p><img src="/2022/06/24/15-48-41/image-20220628140231418.png" alt="image-20220628140231418" style="zoom: 25%;"></p>
<p>由一个三路选择器组成的系统时钟选择器，可以选择下面三种时钟源的一种作为系统时钟源：</p>
<ul>
<li>高速外部时钟HSE
<ul>
<li>优点：外部时钟产生的时钟频率较为精确</li>
</ul></li>
<li>高速内部时钟HSI
<ul>
<li>优点：功耗低，不需要额外的器件，起震快</li>
<li>缺点：但是精度不能保证</li>
</ul></li>
<li>锁相环时钟PLLCLK
<ul>
<li>锁相环可以用来倍频，开发板上外接8M晶振，但是STM32主频却能跑72M，这离不开锁相环（PLL）的作用。</li>
</ul></li>
</ul>
<p>定时器要实现计数必须有个时钟源，<strong>基本定时器时钟只能来自内部时钟，高级控制定时器和通用定时器还可以选择外部时钟源或者直接来自其他定时器等待模式</strong>。</p>
<blockquote>
<p>F407有三种时钟源可以用作系统时钟：内部高速时钟、外部高速时钟、PLL时钟。 一般我们希望芯片工作在最高频率168MHz，而无论是内部还是外部时钟都是达不到的，所以通常都是用PLL时钟作为系统时钟。 外部时钟通常都比内部时钟要稳定精确，所以一般还会用外部时钟作为PLL的输入。 F407还有一个低速时钟用来驱动RTC，以及满足低电压模式下的功能需求。</p>
<p>通常系统总线AHB的频率设置为168MHz，高速外设总线APB2频率设置为84MHz，低速外设总线APB1频率设置为42MHz。 这些总线频率可以通过配置RCC_CFGR和RCC_PLLCFGR实现。</p>
</blockquote>
<h3 id="gps模块">GPS模块</h3>
<p>GPS模块硬件可以将卫星传来的信号进行收集，然后我们可以通过串口通信的方式从GPS模块中读取卫星报文。读取后的报文我们可以将其缓存下来，然后进行译码。</p>
<p>了解了 NMEA 格式有之后，我们就可以编写相应的解码程序了，而程序员 Tim(<a href="mailto:xtimor@gmail.com">xtimor@gmail.com</a>)提供了一个非常完善的 NMEA 解码库，在以下网址可以下载到：http://nmea.sourceforge.net/ ，直接使用该解码库，可以避免重复发明轮子的工作。</p>
<h3 id="移植-multibutton">移植 <a href="https://github.com/0x1abin/MultiButton">MultiButton</a></h3>
<h4 id="multibutton简介">MultiButton简介</h4>
<p>Github里面的嵌入式开源项目，一个小巧简单易用的事件驱动型按键驱动模块，可无限量扩展按键，能够实现下述按键事件：</p>
<table>
<thead>
<tr class="header">
<th>事件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PRESS_DOWN</td>
<td>按键按下，每次按下都触发</td>
</tr>
<tr class="even">
<td>PRESS_UP</td>
<td>按键弹起，每次松开都触发</td>
</tr>
<tr class="odd">
<td>PRESS_REPEAT</td>
<td>重复按下触发，变量repeat计数连击次数</td>
</tr>
<tr class="even">
<td>SINGLE_CLICK</td>
<td>单击按键事件</td>
</tr>
<tr class="odd">
<td>DOUBLE_CLICK</td>
<td>双击按键事件</td>
</tr>
<tr class="even">
<td>LONG_PRESS_START</td>
<td>达到长按时间阈值时触发一次</td>
</tr>
<tr class="odd">
<td>LONG_PRESS_HOLD</td>
<td>长按期间一直触发</td>
</tr>
</tbody>
</table>
<h4 id="在stm32g431-nucleo-64开发板中使用">在STM32G431-Nucleo-64开发板中使用</h4>
<p>首先使用CubeMX建立一个工程，初始化串口、测试LED和测试按键的GPIO口：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702160405595.png" alt="image-20220702160405595" style="zoom:67%;"></p>
<p>生成代码，打开工程文件夹：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702160514425.png" alt="image-20220702160514425" style="zoom:50%;"></p>
<p>然后在<a href="https://github.com/0x1abin/MultiButton">此处</a>下载项目文件到本地：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702160023733.png" alt="image-20220702160023733" style="zoom:50%;"></p>
<p>将红框内的源文件放入到工程文件夹的MDK-ARM文件夹中，这里我给源文件了一个单独的文件夹</p>
<p><img src="/2022/06/24/15-48-41/image-20220702160647623.png" alt="image-20220702160647623" style="zoom:50%;"></p>
<p>同时我也移植了我们之前使用的 “user_log.h” 文件。</p>
<p>打开工程，从工程外部添加文件：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702161216790.png" alt="image-20220702161216790" style="zoom: 50%;"></p>
<p><img src="/2022/06/24/15-48-41/image-20220702161310298.png" alt="image-20220702161310298" style="zoom:50%;"></p>
<p>源文件中的头文件，可以添加进来，也可以不添加，只要添加头文件的查找地址，然后在写代码时包含头文件即可：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220702161547708.png" alt="image-20220702161547708"><figcaption aria-hidden="true">image-20220702161547708</figcaption>
</figure>
<h4 id="编写测试代码">编写测试代码</h4>
<ol type="1">
<li><p>打开 uart.c 文件，添加串口重定向代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)<span class="comment">//如果使用GCC编译</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)<span class="comment">//keil中适用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">	HAL_UART_Transmit(&amp;hlpuart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//hlpuart1需要根据你的配置修改</span></span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure></li>
<li><p>打开 main.c 文件</p>
<ol type="1">
<li><p>添加新的包含</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Private includes ----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Includes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;multi_button.h&quot;</span></span></span><br><span class="line"><span class="comment">/* USER CODE END Includes */</span></span><br></pre></td></tr></table></figure></li>
<li><p>添加新的变量声明——按键结构体声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Private variables ---------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* USER CODE BEGIN PV */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Button</span> <span class="title">button1</span>;</span></span><br><span class="line"><span class="comment">/* USER CODE END PV */</span></span><br></pre></td></tr></table></figure></li>
<li><p>回调函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Private user code ---------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">read_button1_GPIO</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">button_callback</span><span class="params">(<span class="type">void</span> *button)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> btn_event_val; </span><br><span class="line">    btn_event_val = get_button_event((<span class="keyword">struct</span> Button *)button); </span><br><span class="line">    <span class="keyword">switch</span>(btn_event_val)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">case</span> PRESS_DOWN:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;---&gt; key1 press down! &lt;---\r\n&quot;</span>); </span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> PRESS_UP: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;***&gt; key1 press up! &lt;***\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> PRESS_REPEAT: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;---&gt; key1 press repeat! &lt;---\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> SINGLE_CLICK: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;---&gt; key1 single click! &lt;---\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> DOUBLE_CLICK: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;***&gt; key1 double click! &lt;***\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> LONG_PRESS_START: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;---&gt; key1 long press start! &lt;---\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">     <span class="keyword">case</span> LONG_PRESS_HOLD: </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;***&gt; key1 long press hold! &lt;***\r\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进入 <code>main()</code> 函数，<code>while(1)</code> 之前：初始化对象 -&gt; 注册函数 -&gt; 启动函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize all configured peripherals */</span></span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  MX_LPUART1_UART_Init();</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN 2 */</span></span><br><span class="line">	HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MultiButton Test...\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化按键对象</span></span><br><span class="line">	button_init(&amp;button1, read_button1_GPIO, <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册函数</span></span><br><span class="line">	button_attach(&amp;button1, PRESS_DOWN,       button_callback);</span><br><span class="line">	button_attach(&amp;button1, PRESS_UP,         button_callback);</span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, PRESS_REPEAT,     button_callback);</span></span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, SINGLE_CLICK,     button_callback);</span></span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, DOUBLE_CLICK,     button_callback);</span></span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, LONG_PRESS_START, button_callback);</span></span><br><span class="line"><span class="comment">//	button_attach(&amp;button1, LONG_PRESS_HOLD,  button_callback);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//启动按键</span></span><br><span class="line">	button_start(&amp;button1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END 2 */</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置一个5ms间隔的定时器循环调用后台处理函数，可以在while(1)中使用滴答定时器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN WHILE */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每隔5ms调用一次后台处理函数</span></span><br><span class="line">button_ticks();</span><br><span class="line">HAL_Delay(<span class="number">5</span>);</span><br><span class="line">  <span class="comment">/* USER CODE END WHILE */</span></span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>勾选使用 MicroLIB</p>
<p><img src="/2022/06/24/15-48-41/image-20220702162518916.png" alt="image-20220702162518916" style="zoom: 33%;"></p></li>
<li><p>编译，烧录，打开串口助手，测试：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702162754097.png" alt="image-20220702162754097" style="zoom: 33%;"></p></li>
</ol>
<h3 id="移植-guilite">移植 <a href="https://gitee.com/idea4good/GuiLite">GuiLite</a></h3>
<h4 id="简介">简介</h4>
<p>GuiLite是一个轻量的，可以运行在MPU平台的开源图形库。</p>
<p>只要能点亮你的显示屏上一个像素点，就可以使用这个图形库绘制出复杂的图形。</p>
<p>GuiLite还支持多个平台：</p>
<ul>
<li><p>支持的操作系统：iOS/macOS/WatchOS，Android，Linux（ARM/x86-64），Windows（包含VR），RTOS... 甚至<strong>无操作系统的单片机</strong></p></li>
<li><p>支持的开发语言： C/C++, Swift, Java, Javascript, C#, Golang...</p></li>
<li><p>支持的第3方库：Qt, MFC, Winforms, CoCoa...</p></li>
</ul>
<p>⚙️️最低硬件要求:</p>
<table>
<thead>
<tr class="header">
<th>Processor</th>
<th>Disk/ROM space</th>
<th>Memory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>24 MHZ</td>
<td>29 KB</td>
<td>9 KB</td>
</tr>
</tbody>
</table>
<h4 id="在stm32g431-nucleo-64开发板中使用-1">在STM32G431-Nucleo-64开发板中使用</h4>
<p>在TFT屏示例的基础上进行GUI测试：</p>
<p>此处注意，可能会需要扩大默认的堆空间长度，具体操作如下：</p>
<ol type="1">
<li><p>CubeMX中修改堆的大小：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702213417565.png" alt="image-20220702213417565" style="zoom: 25%;"></p></li>
<li><p>打开stm32的启动代码（汇编代码）即可看到修改成功：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702213543120.png" alt="image-20220702213543120" style="zoom: 25%;"></p></li>
</ol>
<p>移植过程：</p>
<ol type="1">
<li><p>点击<a href="https://gitee.com/idea4good/GuiLite">此处</a>下载源代码，在<a href="https://gitee.com/idea4good/GuiLiteSamples">此处</a>下载Example；我们需要Example进行测试。</p></li>
<li><p>将Example中的实例代码放到自己的工程中，以Hello3DWave为例：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702214620179.png" alt="image-20220702214620179" style="zoom: 50%;"></p>
<p>将这两个文件复制到自己的工程中，可以新建一个名为UIcode的文件夹存放。</p></li>
<li><p>在自己的keil工程中的Target中新建一个Group：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702214000568.png" alt="image-20220702214000568" style="zoom:33%;"></p></li>
<li><p>将例程代码添加到Group中：</p>
<p><img src="/2022/06/24/15-48-41/image-20220702214312012.png" alt="image-20220702214312012" style="zoom:50%;"></p></li>
<li><p>添加完成后即可编写代码，注意：检查自己的工程中是否勾选了Use MicroLIB，如果勾选了就要取消勾选，因为我们需要编译器去解析.cpp文件，不能使用C库</p>
<p><img src="/2022/06/24/15-48-41/image-20220702214859697.png" alt="image-20220702214859697" style="zoom:50%;"></p>
<h4 id="编写测试代码-1">编写测试代码</h4>
<ol type="1">
<li><p>在 main.c 中重新实现延时和绘制像素点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* USER CODE BEGIN 0 */</span></span><br><span class="line"><span class="comment">//延时1ms函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">int</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">	HAL_Delay(ms);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RGB888转RGB565</span></span><br><span class="line"><span class="comment">//Transfer GuiLite 32 bits color to your LCD color</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GL_RGB_32_to_16(rgb) (((((unsigned int)(rgb)) &amp; 0xFF) &gt;&gt; 3) | ((((unsigned int)(rgb)) &amp; 0xFC00) &gt;&gt; 5) | ((((unsigned int)(rgb)) &amp; 0xF80000) &gt;&gt; 8))</span></span><br><span class="line"><span class="comment">//Encapsulate your LCD driver:</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gfx_draw_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> rgb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//LCD_Fast_DrawPoint(x, y, GL_RGB_32_to_16(rgb));</span></span><br><span class="line">  <span class="comment">//添加带颜色的画点函数</span></span><br><span class="line">  LCD_DrawPoint(x, y, GL_RGB_32_to_16(rgb));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//UI entry</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DISPLAY_DRIVER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">void</span> (*draw_pixel)(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> rgb);</span><br><span class="line">	<span class="type">void</span> (*fill_rect)(<span class="type">int</span> x0, <span class="type">int</span> y0, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">unsigned</span> <span class="type">int</span> rgb);</span><br><span class="line">&#125; my_driver;</span><br><span class="line"></span><br><span class="line"><span class="comment">//extern function</span></span><br><span class="line"><span class="comment">/* USER CODE END 0 */</span></span><br></pre></td></tr></table></figure></li>
<li><p>上面代码中的倒数第二行 <code>//extern function</code> 中的函数声明要去 UIcode.cpp 的最后去找</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220704151857006.png" alt="image-20220704151857006"><figcaption aria-hidden="true">image-20220704151857006</figcaption>
</figure></li>
<li><p>将此函数声明复制到 <code>//extern function</code> 处，然后在 <code>while(1)</code> 前添加如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_driver.draw_pixel = gfx_draw_pixel;</span><br><span class="line">my_driver.fill_rect = <span class="literal">NULL</span>;<span class="comment">//gfx_fill_rect;</span></span><br><span class="line"><span class="comment">//function like: startHelloStar(NULL,128,160,2,&amp;my_driver);</span></span><br></pre></td></tr></table></figure></li>
<li><p>编译然后烧录，不需要管警告信息。</p></li>
</ol></li>
</ol>
<h2 id="hal库小记">HAL库小记</h2>
<blockquote>
<p><strong>硬件抽象层</strong>（HAL，Hardware Abstraction Layer）驱动程序提供了一组功能丰富，易于与应用上层交互的 API，它们涵盖了常见的外围设备，可以非常方便的向其它型号 STM32 微控制器移植。同时还实现了用户回调函数机制，允许并发调用 <code>USART1</code> 以及 <code>USART2</code> 等外设，并且支持<strong>轮询</strong>、<strong>中断</strong>、<strong>DMA</strong> 三种 API 编程模式。</p>
<p><a href="https://uinika.github.io/Embedded/STM32F401/?highlight=hal#arm-cortex-m4-%E6%A6%82%E8%A6%81">对于HAL库的介绍</a></p>
</blockquote>
<h4 id="gpio口">GPIO口</h4>
<h5 id="初始化及重置函数">初始化及重置函数</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化引脚 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_Init</span><span class="params">(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init)</span>; </span><br><span class="line"><span class="comment">//重置引脚 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_DeInit</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint32_t</span> GPIO_Pin)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="gpio-口操作相关函数">GPIO 口操作相关函数</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取电平状态 </span></span><br><span class="line">GPIO_PinState <span class="title function_">HAL_GPIO_ReadPin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>; </span><br><span class="line"><span class="comment">//设置引脚状态 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_WritePin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin, GPIO_PinState PinState)</span>; </span><br><span class="line"><span class="comment">//转换引脚状态 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_TogglePin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>; </span><br><span class="line"><span class="comment">//锁定引脚状态 </span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_GPIO_LockPin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>; </span><br></pre></td></tr></table></figure>
<h5 id="gpio口枚举常量">GPIO口枚举常量</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GPIO_PIN_RESET = <span class="number">0U</span>,</span><br><span class="line">  GPIO_PIN_SET</span><br><span class="line">&#125; GPIO_PinState;</span><br></pre></td></tr></table></figure>
<h5 id="gpio口名称">GPIO口名称</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* IO口默认定义 -----------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN_0                 ((uint16_t)0x0001)  <span class="comment">/* Pin 0 selected    */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private defines -----------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> User_Label_Pin GPIO_PIN_3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> User_Label_GPIO_Port GPIOA</span></span><br></pre></td></tr></table></figure>
<p>GPIO的API</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">函数名称</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>HAL_GPIO_ReadPin()</code></td>
<td style="text-align: left;">读取指定输入端口的引脚状态；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>HAL_GPIO_WritePin()</code></td>
<td style="text-align: left;">设置或者清除指定的数据端口位；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>HAL_GPIO_TogglePin()</code></td>
<td style="text-align: left;">切换指定的 GPIO 引脚状态；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>HAL_GPIO_LockPin()</code></td>
<td style="text-align: left;">锁定 GPIO 引脚配置寄存器；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>HAL_GPIO_EXTI_IRQHandler()</code></td>
<td style="text-align: left;">该函数用于处理 EXTI 中断请求；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>HAL_GPIO_EXTI_Callback()</code></td>
<td style="text-align: left;">EXTI 线检测回调函数；</td>
</tr>
</tbody>
</table>
<h4 id="串口通信-1">串口通信</h4>
<h5 id="收发函数">收发函数</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span>;</span><br><span class="line"><span class="comment">//发送中断</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit_IT</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *</span></span><br><span class="line"><span class="params">pData, <span class="type">uint16_t</span> Size)</span>;</span><br><span class="line"><span class="comment">//接收中断</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive_IT</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData</span></span><br><span class="line"><span class="params">, <span class="type">uint16_t</span> Size)</span>;</span><br><span class="line"><span class="comment">//使用DMA发送</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit_DMA</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *</span></span><br><span class="line"><span class="params">pData, <span class="type">uint16_t</span> Size)</span>;</span><br><span class="line"><span class="comment">//使用DMA接收</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Receive_DMA</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *</span></span><br><span class="line"><span class="params">pData, <span class="type">uint16_t</span> Size)</span>;</span><br><span class="line"><span class="comment">//DMA暂停</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_DMAPause</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br><span class="line"><span class="comment">//DMA恢复</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_DMAResume</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br><span class="line"><span class="comment">//DMA停止</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_DMAStop</span><span class="params">(UART_HandleTypeDef *huart)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="printf-重定向"><code>printf()</code> 重定向</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在 USER CODE BEGIN 0 区域内添加：</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span>&#123;</span><br><span class="line">  <span class="type">uint8_t</span> temp[<span class="number">1</span>] = &#123;ch&#125;;</span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, temp, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//huart1需要根据你的配置修改</span></span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="串口调试策略">串口调试策略</h4>
<h5 id="日志打印文件">日志打印文件</h5>
<p>keil编译器要求文件的结尾必须要有一个空行，如果没有将给出一个警告</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  **************************************************************************************</span></span><br><span class="line"><span class="comment">  *  @file           : user_log.h</span></span><br><span class="line"><span class="comment">  *  @brief          : Print your Log information</span></span><br><span class="line"><span class="comment">  **************************************************************************************</span></span><br><span class="line"><span class="comment">  *  @useage</span></span><br><span class="line"><span class="comment">  * Include this header file in the program file that you want to print logs.</span></span><br><span class="line"><span class="comment">	* Using the function: </span></span><br><span class="line"><span class="comment">	* `user_printf()`</span></span><br><span class="line"><span class="comment">	* `user_main_info()`</span></span><br><span class="line"><span class="comment">	* `user_main_debug()`</span></span><br><span class="line"><span class="comment">	* `user_main_error()`  to print the log.</span></span><br><span class="line"><span class="comment">  * Define &quot;PRINT_USER_LOG&quot; if you want to print logs and annotations it if you don&#x27;t.</span></span><br><span class="line"><span class="comment">  **************************************************************************************</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USER_LOG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USER_LOG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_USER_LOG	<span class="comment">//define for print log</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PRINT_USER_LOG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_printf(format, ...) printf( format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_info(format, ...) printf(<span class="string">&quot; [info] main.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_debug(format, ...) printf(<span class="string">&quot; [debug] main.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_error(format, ...) printf(<span class="string">&quot; [error] main.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>,##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_info(format, ...) printf(<span class="string">&quot; [info] file.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_debug(format, ...) printf(<span class="string">&quot; [debug] file.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_error(format, ...) printf(<span class="string">&quot; [error] file.c :&quot;</span> format <span class="string">&quot;\r\n&quot;</span>,##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_printf(format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_info(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_debug(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_main_error(format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_info(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_debug(format, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_file_error(format, ...)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* PRINT_USER_LOG */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* __USER_LOG_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>添加文件时若出现报错，则需要手动增加头文件搜索路径：</p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220627212005510.png" alt="image-20220627212005510"><figcaption aria-hidden="true">image-20220627212005510</figcaption>
</figure>
<h5 id="日志打印个性化文字">日志打印个性化文字</h5>
<p><a href="http://patorjk.com/software/taag/#p=display&amp;f=Graffiti&amp;t=Type%20Something%20">Text to ASCII Art Generator (TAAG)</a></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">___  ___        _                   </span><br><span class="line">|  \/  |       | |                  </span><br><span class="line">| .  . | _   _ | |      ___    __ _ </span><br><span class="line">| |\/| || | | || |     / _ \  / _` |</span><br><span class="line">| |  | || |_| || |____| (_) || (_| |</span><br><span class="line">\_|  |_/ \__, |\_____/ \___/  \__, |</span><br><span class="line">          __/ |                __/ |</span><br><span class="line">         |___/                |___/ </span><br></pre></td></tr></table></figure>
<p>代码：要在报错的符号前面加上一个反斜杠，因此代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">user_printf(<span class="string">&quot;___  ___        _                   &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;|  \\/  |       | |                  &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| .  . | _   _ | |      ___    __ _ &quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| |\\/| || | | || |     / _ \\  / _` |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;| |  | || |_| || |____| (_) || (_| |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;\\_|  |_/ \\__, |\\_____/ \\___/  \\__, |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;          __/ |                __/ |&quot;</span>);</span><br><span class="line">user_printf(<span class="string">&quot;         |___/                |___/ &quot;</span>);</span><br></pre></td></tr></table></figure>
<hr>
<p>分割线内内容摘自<a href="https://uinika.github.io/Embedded/STM32F401/?highlight=hal#arm-cortex-m4-%E6%A6%82%E8%A6%81">Uinlo</a>的个人博客：</p>
<h3 id="hal-通用命名规则">HAL 通用命名规则</h3>
<p>对于共有的系统外设，无需使用指针或者实例对象，这个规则适用于 <strong>GPIO</strong>、<strong>SYSTICK</strong>、<strong>NVIC</strong>、<strong>RCC</strong>、<strong>FLASH</strong> 外设，例如函数 <code>HAL_GPIO_Init()</code> 只需要 GPIO 的地址及其配置参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HAL_StatusTypeDef HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *Init) &#123;</span><br><span class="line">  /* GPIO 初始化体 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个外设驱动程序当中都定义有处理中断和特定时钟配置的<strong>宏</strong>，这些宏会被导出到外设驱动的<strong>头文件</strong>，以便于<strong>扩展文件</strong>使用，这些用于处理中断和特定时钟配置的宏如下所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">宏定义</th>
<th style="text-align: left;">功能描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_ENABLE_IT(__HANDLE__, __INTERRUPT__)</code></td>
<td style="text-align: left;"><strong>使能</strong>一个特定的外设中断；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_DISABLE_IT(__HANDLE__, __INTERRUPT__)</code></td>
<td style="text-align: left;"><strong>失能</strong>一个特定的外设中断；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_GET_IT (__HANDLE__, __ INTERRUPT __)</code></td>
<td style="text-align: left;"><strong>获取</strong>一个指定外设的中断状态；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_CLEAR_IT (__HANDLE__, __ INTERRUPT __)</code></td>
<td style="text-align: left;"><strong>清除</strong>一个指定外设的中断状态；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_GET_FLAG (__HANDLE__, __FLAG__)</code></td>
<td style="text-align: left;"><strong>获取</strong>一个指定外设的标志位状态；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_CLEAR_FLAG (__HANDLE__, __FLAG__)</code></td>
<td style="text-align: left;"><strong>清除</strong>一个指定外设的标志位状态；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_ENABLE(__HANDLE__)</code></td>
<td style="text-align: left;"><strong>使能</strong>一个外设；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_DISABLE(__HANDLE__)</code></td>
<td style="text-align: left;"><strong>失能</strong>一个外设；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>__HAL_PPP_XXXX (__HANDLE__, __PARAM__)</code></td>
<td style="text-align: left;">指定 PPP 外设驱动的<strong>宏</strong>；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>__HAL_PPP_GET_ IT_SOURCE (__HANDLE__, __INTERRUPT__)</code></td>
<td style="text-align: left;">检查指定的<strong>中断源</strong>；</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：<strong>NVIC</strong> 和 <strong>SYSTICK</strong> 是 ARM Cortex-M4 提供的两个核心功能，与之相关的 API 都位于 <code>stm32f4xx_hal_cortex.c</code> 源文件。</p>
</blockquote>
<p>当从寄存器读取<strong>状态标志位</strong>时，其结果由移位值组成，具体取决于读取值的数量与大小。这种情况下，返回的状态宽度为 <strong>32</strong> 位，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STATUS = XX | (YY &lt;&lt; 16)</span><br><span class="line">/* 或者 */</span><br><span class="line">STATUS = XX | (YY &lt;&lt; 8) | (YY &lt;&lt; 16) | (YY &lt;&lt; 24)</span><br></pre></td></tr></table></figure>
<p>外设 PPP 的指针在调用 <code>HAL_PPP_Init()</code> 之前有效，初始化函数会在修改指针字段之前进行检查：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HAL_PPP_Init(PPP_HandleTypeDef)</span><br><span class="line">if (hppp == NULL) &#123;</span><br><span class="line">  return HAL_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用<strong>条件式宏定义</strong>或者<strong>伪代码宏定义</strong>：</p>
<ul>
<li><p>条件式宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define ABS(x) (((x) &gt; 0) ? (x) : -(x))</span><br></pre></td></tr></table></figure></li>
<li><p>伪代码宏定义（多指令宏）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD_, __DMA_HANDLE_) \</span><br><span class="line">  do &#123;                                                             \</span><br><span class="line">    (__HANDLE__)-&gt;__PPP_DMA_FIELD_ = &amp;(__DMA_HANDLE_);             \</span><br><span class="line">    (__DMA_HANDLE_).Parent = (__HANDLE__);                         \</span><br><span class="line">  &#125; while (0)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="中断处理程序与回调函数">中断处理程序与回调函数</h4>
<p>除了各种 API 函数之外，HAL 固件库外设驱动程序当中还包含有：</p>
<ul>
<li>用户回调函数；</li>
<li>由 <code>stm32f4xx_it.c</code> 调用的 <code>HAL_PPP_IRQHandler()</code> 外设中断处理程序；</li>
</ul>
<p>回调函数被定义为带有 <code>weak</code> 属性的空函数，使用时必须在用户代码当中进行定义，HAL 固件库当中存在三种类型的用户回调函数：</p>
<ul>
<li>外围系统级初始化与反向初始化回调函数 <code>HAL_PPP_MspInit()</code> 和 <code>HAL_PPP_MspDeInit</code>；</li>
<li>外理完成回调函数 <code>HAL_PPP_ProcessCpltCallback</code>；</li>
<li>错误的回调函数 <code>HAL_PPP_ErrorCallback</code>；</li>
</ul>
<table>
<colgroup>
<col style="width: 40%">
<col style="width: 59%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">回调函数</th>
<th style="text-align: left;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>HAL_PPP_MspInit()</code> <code>HAL_PPP_MspDeInit()</code></td>
<td style="text-align: left;">例如 <code>HAL_USART_MspInit()</code>，由 API 函数 <code>HAL_PPP_Init()</code> 进行调用，用于进行外设的系统级初始化（GPIO、时钟、DMA、中断）；</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>HAL_PPP_ProcessCpltCallback</code></td>
<td style="text-align: left;">例如 <code>HAL_USART_TxCpltCallback</code>，当处理执行完成时，由外设或者 DMA 中断处理程序进行调用；</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>HAL_PPP_ErrorCallback</code></td>
<td style="text-align: left;">例如 <code>HAL_USART_ErrorCallback</code>，当发生错误时，由外设或者 DMA 中断处理程序进行调用；</td>
</tr>
</tbody>
</table>
<h4 id="hal-全局初始化">HAL 全局初始化</h4>
<p><code>stm32f4xx_hal.c</code> 提供了一组 API 来初始化 HAL 核心实现：</p>
<ul>
<li><code>HAL_Init()</code>：该函数必须在应用程序启动时调用，用于初始化数据和指令，缓存预获取队列，设置 SysTick 定时器（基于 HSI 时钟）每间隔 <code>1ms</code> 产生一个最低优先级中断，将优先级分组设置为 <code>4</code> 位，调用 <code>HAL_MspInit()</code> 用户回调函数来执行系统级初始化（时钟、GPIO、DMA、中断）；</li>
<li><code>HAL_DeInit()</code>：重置所有外设，调用用户回调函数 <code>HAL_MspDeInit()</code> 执行系统级反向初始化；</li>
<li><code>HAL_GetTick()</code>：获取当前 <strong>SysTick</strong> 定时器的计数值（在 SysTick 中断内递增），用于外设驱动程序处理<strong>超时</strong>；</li>
<li><code>HAL_Delay()</code>：通过 <strong>SysTick</strong> 定时器实现一个以毫秒为单位的延迟；</li>
</ul>
<h4 id="io-操作">IO 操作</h4>
<p>带有内部数据处理（发送、接收、读/写）的 HAL 函数，通常具备<code>轮询（Polling）</code>、<code>中断（Interrupt）</code>、<code>DMA</code> 三种处理方式：</p>
<hr>
<h2 id="底层探究">底层探究</h2>
<h3 id="新建工程">新建工程</h3>
<p>使用windows系统的PowerShell生成Blank template文件的目录树：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">PS C:\Users\qjy\Desktop\Blank template&gt; <span class="built_in">tree</span> /F</span><br><span class="line">卷 Windows-SSD 的文件夹 <span class="built_in">PATH</span> 列表</span><br><span class="line">卷序列号为 F01E-<span class="number">6275</span></span><br><span class="line"><span class="function">C:.</span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvoptx</span></span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvprojx</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">├─<span class="title">DebugConfig</span></span></span><br><span class="line"><span class="function">│      <span class="title">Target_1_STM32G431RBTx.dbgconf</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">├─<span class="title">Listings</span></span></span><br><span class="line"><span class="function">└─<span class="title">Objects</span></span></span><br></pre></td></tr></table></figure>
<p>添加 “startup_stm32g431xx.s” <del>和 “system_stm32g4xx.c” 两个文件</del>到 Blank template 文件夹目录下：</p>
<p>新建两个文件，编写系统初始化函数和主函数，如图。然后编译。</p>
<p><img src="/2022/06/24/15-48-41/image-20220628171400275.png" alt="image-20220628171400275" style="zoom:50%;"></p>
<p>编译成功，包含一个警告，内容为：<code>void SystemInit(void)</code> 函数没有函数原型，此处可以忽略该警告。</p>
<p>编译后的工程目录树如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">PS C:\Users\qjy\Desktop\Blank template&gt; <span class="built_in">tree</span> /F</span><br><span class="line">卷 Windows-SSD 的文件夹 <span class="built_in">PATH</span> 列表</span><br><span class="line">卷序列号为 F01E-<span class="number">6275</span></span><br><span class="line"><span class="function">C:.</span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvguix.qjy</span></span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvoptx</span></span></span><br><span class="line"><span class="function">│  <span class="title">Blank_Template.uvprojx</span></span></span><br><span class="line"><span class="function">│  <span class="title">main.c</span></span></span><br><span class="line"><span class="function">│  <span class="title">startup_stm32g431xx.s</span></span></span><br><span class="line"><span class="function">│  <span class="title">system_stm32g4xx.c</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">├─<span class="title">DebugConfig</span></span></span><br><span class="line"><span class="function">│      <span class="title">Target_1_STM32G431RBTx.dbgconf</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">├─<span class="title">Listings</span></span></span><br><span class="line"><span class="function">│      <span class="title">Blank_Template.map</span></span></span><br><span class="line"><span class="function">│</span></span><br><span class="line"><span class="function">└─<span class="title">Objects</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template.axf</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template.build_log.htm</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template.htm</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template.lnp</span></span></span><br><span class="line"><span class="function">        <span class="title">Blank_Template_Target</span> 1.<span class="title">dep</span></span></span><br><span class="line"><span class="function">        <span class="title">main.d</span></span></span><br><span class="line"><span class="function">        <span class="title">main.o</span></span></span><br><span class="line"><span class="function">        <span class="title">startup_stm32g431xx.o</span></span></span><br><span class="line"><span class="function">        <span class="title">system_stm32g4xx.d</span></span></span><br><span class="line"><span class="function">        <span class="title">system_stm32g4xx.o</span></span></span><br></pre></td></tr></table></figure>
<p>其中keil中的project目录树为：</p>
<p><img src="/2022/06/24/15-48-41/image-20220628171454899.png" alt="image-20220628171454899" style="zoom: 50%;"></p>
<figure>
<img src="/2022/06/24/15-48-41/image-20220628181017627.png" alt="image-20220628181017627"><figcaption aria-hidden="true">image-20220628181017627</figcaption>
</figure>
<figure>
<img src="/2022/06/24/15-48-41/image-20220628181229406.png" alt="image-20220628181229406"><figcaption aria-hidden="true">image-20220628181229406</figcaption>
</figure>
<p>我们知道系统的时钟是通过系统复位和时钟控制(RCC)寄存器配置的。 在第6.3节中列举了25个RCC寄存器的位定义和偏移地址。参考CubeMX中生成的stm32g431xx.h文件，定义如下的结构体用于访问RCC的每个寄存器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief Reset and Clock Control</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CR;          <span class="comment">/*!&lt; RCC clock control register,                                              Address offset: 0x00 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> ICSCR;       <span class="comment">/*!&lt; RCC internal clock sources calibration register,                         Address offset: 0x04 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CFGR;        <span class="comment">/*!&lt; RCC clock configuration register,                                        Address offset: 0x08 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> PLLCFGR;     <span class="comment">/*!&lt; RCC system PLL configuration register,                                   Address offset: 0x0C */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED0;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x10 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED1;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x14 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CIER;        <span class="comment">/*!&lt; RCC clock interrupt enable register,                                     Address offset: 0x18 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CIFR;        <span class="comment">/*!&lt; RCC clock interrupt flag register,                                       Address offset: 0x1C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CICR;        <span class="comment">/*!&lt; RCC clock interrupt clear register,                                      Address offset: 0x20 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED2;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x24 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB1RSTR;    <span class="comment">/*!&lt; RCC AHB1 peripheral reset register,                                      Address offset: 0x28 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB2RSTR;    <span class="comment">/*!&lt; RCC AHB2 peripheral reset register,                                      Address offset: 0x2C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB3RSTR;    <span class="comment">/*!&lt; RCC AHB3 peripheral reset register,                                      Address offset: 0x30 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED3;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x34 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1RSTR1;   <span class="comment">/*!&lt; RCC APB1 peripheral reset register 1,                                    Address offset: 0x38 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1RSTR2;   <span class="comment">/*!&lt; RCC APB1 peripheral reset register 2,                                    Address offset: 0x3C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB2RSTR;    <span class="comment">/*!&lt; RCC APB2 peripheral reset register,                                      Address offset: 0x40 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED4;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x44 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB1ENR;     <span class="comment">/*!&lt; RCC AHB1 peripheral clocks enable register,                              Address offset: 0x48 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB2ENR;     <span class="comment">/*!&lt; RCC AHB2 peripheral clocks enable register,                              Address offset: 0x4C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB3ENR;     <span class="comment">/*!&lt; RCC AHB3 peripheral clocks enable register,                              Address offset: 0x50 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED5;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x54 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1ENR1;    <span class="comment">/*!&lt; RCC APB1 peripheral clocks enable register 1,                            Address offset: 0x58 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1ENR2;    <span class="comment">/*!&lt; RCC APB1 peripheral clocks enable register 2,                            Address offset: 0x5C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB2ENR;     <span class="comment">/*!&lt; RCC APB2 peripheral clocks enable register,                              Address offset: 0x60 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED6;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x64 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB1SMENR;   <span class="comment">/*!&lt; RCC AHB1 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x68 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB2SMENR;   <span class="comment">/*!&lt; RCC AHB2 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x6C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> AHB3SMENR;   <span class="comment">/*!&lt; RCC AHB3 peripheral clocks enable in sleep and stop modes register,      Address offset: 0x70 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED7;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x74 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1SMENR1;  <span class="comment">/*!&lt; RCC APB1 peripheral clocks enable in sleep mode and stop modes register 1, Address offset: 0x78 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB1SMENR2;  <span class="comment">/*!&lt; RCC APB1 peripheral clocks enable in sleep mode and stop modes register 2, Address offset: 0x7C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> APB2SMENR;   <span class="comment">/*!&lt; RCC APB2 peripheral clocks enable in sleep mode and stop modes register, Address offset: 0x80 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED8;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x84 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CCIPR;       <span class="comment">/*!&lt; RCC peripherals independent clock configuration register,                Address offset: 0x88 */</span></span><br><span class="line">  <span class="type">uint32_t</span>      RESERVED9;   <span class="comment">/*!&lt; Reserved,                                                                Address offset: 0x8C */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> BDCR;        <span class="comment">/*!&lt; RCC backup domain control register,                                      Address offset: 0x90 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CSR;         <span class="comment">/*!&lt; RCC clock control &amp; status register,                                     Address offset: 0x94 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CRRCR;       <span class="comment">/*!&lt; RCC clock recovery RC register,                                          Address offset: 0x98 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> CCIPR2;      <span class="comment">/*!&lt; RCC peripherals independent clock configuration register 2,              Address offset: 0x9C */</span></span><br><span class="line">&#125; RCC_TypeDef;</span><br></pre></td></tr></table></figure>
<p>RCC基地址宏定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH_BASE           (0x40000000UL) <span class="comment">/*!&lt; Peripheral base address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_BASE              (AHB1PERIPH_BASE + 0x1000UL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC ((rcc_regs_t *)RCC_BASE)</span></span><br></pre></td></tr></table></figure>
<p>那么我们就可以通过如下的形式来访问RCC的寄存器了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC-&gt;CR</span><br><span class="line">RCC-&gt;CFGR</span><br></pre></td></tr></table></figure>
<h2 id="cubemx小记">CubeMX小记</h2>
<figure>
<img src="/2022/06/24/15-48-41/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM0NDQxMg==,size_16,color_FFFFFF,t_70-16566001142753.png" alt="SYS配置介绍"><figcaption aria-hidden="true">SYS配置介绍</figcaption>
</figure>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/439705800">引用</a>：调试接口配置。讲道理SWD应该是首选，如图5所示。如果不设置的话，编译下载后，你就会发现下载不了程序了，有复位键还好，没<a href="https://www.zhihu.com/search?q=复位键&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22439705800%22%7D">复位键</a>就有得愁了。</p>
</blockquote>
<p>选择Serial Wire是与下图中的SW相匹配</p>
<p><img src="/2022/06/24/15-48-41/image-20220630224454477.png" alt="image-20220630224454477" style="zoom: 50%;"></p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_41344412/article/details/114153416">引用</a>：如果在STM32CubeMX中选择SW协议，MDK 也必须 选择SW协议。JTAG协议配置也同理。否则会造成下载和调试失败。在实际项目中SW协议使用使用的比较多，SW与JTAG相比，速度更快，占用的引脚更少，推荐大家配置成SW协议。</p>
</blockquote>
]]></content>
      <tags>
        <tag>电子设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Spieed Maix Duino开发板使用小记</title>
    <url>/2022/07/30/15-15-44/</url>
    <content><![CDATA[<h1 id="sipeed-maixduino使用小记">SIPEED MaixDuino使用小记</h1>
<h2 id="开箱跑例程">开箱跑例程</h2>
<p>开箱后将摄像头、TF卡、显示屏都装到开发板上，上电后如下图所示。</p>
<figure>
<img src="/2022/07/30/15-15-44/88b4b368daca77a34d4d3d51c32b1ff.jpg" alt="88b4b368daca77a34d4d3d51c32b1ff"><figcaption aria-hidden="true">88b4b368daca77a34d4d3d51c32b1ff</figcaption>
</figure>
<p>在<a href="https://dl.sipeed.com/shareURL/MAIX/tools/ftdi_vcp_driver">此处</a>安装驱动：选择第二个</p>
<p><img src="/2022/07/30/15-15-44/image-20220730150511809.png" alt="image-20220730150511809"></p>
<p>解压下载好的文件，然后安装INF文件；两个INF文件都要安装：</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730150747127.png" alt="image-20220730150747127"><figcaption aria-hidden="true">image-20220730150747127</figcaption>
</figure>
<p>下载<a href="https://dl.sipeed.com/shareURL/MAIX/MaixPy/ide/v0.2.5">官方IDE</a>：下载.exe文件进行安装</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730151011092.png" alt="image-20220730151011092"><figcaption aria-hidden="true">image-20220730151011092</figcaption>
</figure>
<p>验证摄像头：第一步点击连接后需要选择串口，MaixDuino会在电脑上产生两个串口，其中一个可以使用，自行测试。</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730151246776.png" alt="image-20220730151246776"><figcaption aria-hidden="true">image-20220730151246776</figcaption>
</figure>
<p>进行终端测试：</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730152150910-16591657134626.png" alt="image-20220730152150910"><figcaption aria-hidden="true">image-20220730152150910</figcaption>
</figure>
<p>使用串口连接：直接点确定，一路确定，采用默认模式即可</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730152231846.png" alt="image-20220730152231846"><figcaption aria-hidden="true">image-20220730152231846</figcaption>
</figure>
<p>然后就进入了串口中断模式：</p>
<figure>
<img src="/2022/07/30/15-15-44/image-20220730152322518.png" alt="image-20220730152322518"><figcaption aria-hidden="true">image-20220730152322518</figcaption>
</figure>
<p>在官方文档的<a href="https://wiki.sipeed.com/soft/maixpy/zh/get_started/get_started_power_on.html">此处</a>浏览例程，使用串口终端模式进行测试：</p>
]]></content>
      <tags>
        <tag>Electrical Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title>verilog 开源工具链配置笔记</title>
    <url>/2022/09/02/09-01-15/</url>
    <content><![CDATA[<h3 id="效果展示">效果展示</h3>
<p>本文配置的最终效果展示如下：</p>
<p>Win11+VScode+oss-cad</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902092406126.png" alt="image-20220902092406126"><figcaption aria-hidden="true">image-20220902092406126</figcaption>
</figure>
<h3 id="工具介绍及安装">工具介绍及安装</h3>
<p>首先介绍一下 VScode。VSCode（全称：Visual Studio Code）是一款由微软开发且跨平台的免费源代码编辑器。该软件支持语法高亮、代码自动补全等功能。VScode 的强大之处在于用户可以通过内置的扩展程序商店安装扩展以拓展软件功能。你可以在 <a href="https://code.visualstudio.com/">VScode 官网</a> 下载并安装 VScode，安装方法非常简单，这里不再进行说明。</p>
<p>在 verilog 开发中，我们可以通过添加 "<a href="https://marketplace.visualstudio.com/items?itemName=mshr-h.VerilogHDL">Verilog-HDL/SystemVerilog/Bluespec SystemVerilog support for VS Code</a>" 插件实现 verilog 代码高亮和代码自动补全等功能。你可以直接在 VScode 的扩展中搜索并一键安装这个插件：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902093933026.png" alt="image-20220902093933026"><figcaption aria-hidden="true">image-20220902093933026</figcaption>
</figure>
<p>通过类似的方式，搜索并安装下面两个插件：</p>
<p>左边的插件可以帮助你查看综合出的 .dot 格式的电路图文件，右边的插件可以帮你根据 .vcd 文件生成波形图：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902094417294.png" alt="image-20220902094417294"><figcaption aria-hidden="true">image-20220902094417294</figcaption>
</figure>
<p>上面展示的 verilog 代码的编译和综合过程主要使用到了两个工具：iVerilog 和 Yosys。这两个工具，包括也是非常常用的波形查看工具 GTKwave 都被集成在了一个开源工具组件 OSS CAD Suite 中。OSS CAD 套件中还有很多用于数字逻辑设计的开源软件的二进制软件发行版。你可以在这个 <a href="https://github.com/YosysHQ/oss-cad-suite-build">GitHub 页面</a> 中进行查看。</p>
<p>如果想要安装和使用 OSS CAD Suite ，我们可以直接在 <a href="https://github.com/YosysHQ/oss-cad-suite-build/releases/tag/2022-09-01">这个界面</a> 下载 .exe 文件：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902095721658.png" alt="image-20220902095721658"><figcaption aria-hidden="true">image-20220902095721658</figcaption>
</figure>
<p>下载完成后直接运行这个 .exe 文件，即可获得这样一个文件夹：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902095934878.png" alt="image-20220902095934878"><figcaption aria-hidden="true">image-20220902095934878</figcaption>
</figure>
<p>我将这个 OSS CAD Suite 放在了我自己在 D盘 创建的 Program_Files 文件夹。在这个目录下，我们要重点关注第一个 bin 文件夹和最后标红的两个 .bat 文件。第一个 bin 文件夹里面是 OSS CAD Suite 介绍中所说的，用于数字逻辑设计的开源软件的二进制软件发行版。你可以从这个文件夹中找到包括 iVerilog、GTKwave 和 Yosys。</p>
<p>那么如何使用这些组件呢？ OSS CAD Suite 提供了两种方法，一种是直接点击 start.bat 文件，然后使用命令的方式进行操作：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902100630814.png" alt="image-20220902100630814"><figcaption aria-hidden="true">image-20220902100630814</figcaption>
</figure>
<p>第二种方案是通过命令行工具，在 cmd 中调用 environment.bat 来使用该工具：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902101420630.png" alt="image-20220902101420630"><figcaption aria-hidden="true">image-20220902101420630</figcaption>
</figure>
<p>但是，之前我们的操作都是在 VScode 上进行的，所以我们希望也把 OSS CAD Suite 的使用放在 VScode 内进行，有没有办法呢？我的解决方案是使用第二种方法调用 OSS CAD Suite ，只要使用 VScode 内置的 cmd （终端）来实现调用 environment.bat 即可。操作如下：</p>
<p>首先如下图提示的，我们使用快捷键调出终端</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902101612341.png" alt="image-20220902101612341"><figcaption aria-hidden="true">image-20220902101612341</figcaption>
</figure>
<p>我们可以将终端移动到编辑器区域：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902101716445.png" alt="image-20220902101716445"><figcaption aria-hidden="true">image-20220902101716445</figcaption>
</figure>
<p>然后我们注意到这个终端不是 cmd，而是 powershell，两者的区别读者可以自己去查一下，这里我们还是使用 cmd 来演示：注意在 cmd 中可以使用 tab 键进行补全。</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902102107905.png" alt="image-20220902102107905"><figcaption aria-hidden="true">image-20220902102107905</figcaption>
</figure>
<p>到此为止我们已经进行了全部内容的安装。下面我们使用一个 4 选 1 多路选择器代码进行演示：</p>
<h3 id="使用方法">使用方法</h3>
<p>首先新建一个文件夹，然后选择使用 VScode 打开：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902102705459.png" alt="image-20220902102705459"><figcaption aria-hidden="true">image-20220902102705459</figcaption>
</figure>
<p>然后建立如下目录结构：红框内的第一个图标是新建文件，第二个是新建文件夹</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902103003482.png" alt="image-20220902103003482"><figcaption aria-hidden="true">image-20220902103003482</figcaption>
</figure>
<p>输入代码：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902103049078.png" alt="image-20220902103049078"><figcaption aria-hidden="true">image-20220902103049078</figcaption>
</figure>
<p>附上代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Verilog HDL 数字设计与综合（第二版）（本科教学版）例6.2</span></span><br><span class="line"><span class="comment">//用逻辑方程描述四选一多路选择器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mux4_to_1 (out, i0, i1, i2, i3, s1, s0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接取自输入输出图的端口声明语句</span></span><br><span class="line">    <span class="keyword">output</span> out;</span><br><span class="line">    <span class="keyword">input</span> i0, i1, i2, i3, s1, s0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生输出 out 的逻辑方程</span></span><br><span class="line">    <span class="keyword">assign</span> out = ( ~s1 &amp; ~s0 &amp; i0)|</span><br><span class="line">                 ( ~s1 &amp;  s0 &amp; i1)|</span><br><span class="line">                 (  s1 &amp; ~s0 &amp; i2)|</span><br><span class="line">                 (  s1 &amp;  s0 &amp; i3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编写无端口激励模块</span></span><br><span class="line"><span class="comment">//为了使用yosys来进行综合，我们将电路描述模块和激励模块分离，然后对mux4_to_1.v进行单独的综合</span></span><br><span class="line"><span class="keyword">module</span> stimulus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明连接到输入端口的变量</span></span><br><span class="line">    <span class="keyword">reg</span> IN0,IN1,IN2,IN3;</span><br><span class="line">    <span class="keyword">reg</span> S1,S0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明输出连线</span></span><br><span class="line">    <span class="keyword">wire</span> OUTPUT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用（实例引用）多路选择器</span></span><br><span class="line">    mux4_to_1 my_mux(OUTPUT,IN0,IN1,IN2,IN3,S1,S0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生输入激励信号</span></span><br><span class="line">    <span class="comment">//Define the stimulus module (no ports)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//设置输入线信号</span></span><br><span class="line">        IN0 = <span class="number">1</span>;</span><br><span class="line">        IN1 = <span class="number">0</span>;</span><br><span class="line">        IN2 = <span class="number">1</span>;</span><br><span class="line">        IN3 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;IN0 = %b, IN1 = %b, IN2 = %b, IN3 = %b&quot;</span>,IN0,IN1,IN2,IN3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择IN0；</span></span><br><span class="line">        S1 = <span class="number">0</span>;</span><br><span class="line">        S0 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;S1 = %b, S0 = %b, OUTPUT = %b&quot;</span>,S1, S0, OUTPUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择IN0；</span></span><br><span class="line">        S1 = <span class="number">0</span>;</span><br><span class="line">        S0 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;S1 = %b, S0 = %b, OUTPUT = %b&quot;</span>,S1, S0, OUTPUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择IN0；</span></span><br><span class="line">        S1 = <span class="number">1</span>;</span><br><span class="line">        S0 = <span class="number">0</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;S1 = %b, S0 = %b, OUTPUT = %b&quot;</span>,S1, S0, OUTPUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择IN0；</span></span><br><span class="line">        S1 = <span class="number">1</span>;</span><br><span class="line">        S0 = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">1</span> <span class="built_in">$display</span>(<span class="string">&quot;S1 = %b, S0 = %b, OUTPUT = %b&quot;</span>,S1, S0, OUTPUT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产 VCD 文件需要的代码（非例题代码）</span></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">        <span class="built_in">$dumpfile</span>(<span class="string">&quot;wave.vcd&quot;</span>); <span class="comment">//生成波形文件vcd的名称 </span></span><br><span class="line">        <span class="built_in">$dumpvars</span>(<span class="number">0</span>, stimulus); <span class="comment">//tb模块名称</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后保存文件，打开终端，先进入 oss-cad-suite 文件夹打开 environment.bat 然后再回到 verilog 文件目录下对目标文件进行操作</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902103520387.png" alt="image-20220902103520387"><figcaption aria-hidden="true">image-20220902103520387</figcaption>
</figure>
<p>然后进行编译等一系列操作：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">iverilog -o mux4_to_1<span class="variable">.vvp</span> -y ./ mux4_to_1_tb<span class="variable">.v</span> mux4_to_1<span class="variable">.v</span></span><br><span class="line">vvp mux4_to_1<span class="variable">.vvp</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902104216297.png" alt="image-20220902104216297"><figcaption aria-hidden="true">image-20220902104216297</figcaption>
</figure>
<p>然后在终端可以看到 <code>$display()</code> 的内容，然后我们查看 .vcd 文件：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902104553493.png" alt="image-20220902104553493"><figcaption aria-hidden="true">image-20220902104553493</figcaption>
</figure>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902104654196.png" alt="image-20220902104654196"><figcaption aria-hidden="true">image-20220902104654196</figcaption>
</figure>
<p>接下来我们进行综合：</p>
<p>首先进入 yosys，然后读入文件，处理文件，最后导出 .dot 格式</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902105334206.png" alt="image-20220902105334206"><figcaption aria-hidden="true">image-20220902105334206</figcaption>
</figure>
<p>过程如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read_verilog mux4_to_1.v</span><br><span class="line">hierarchy -check</span><br><span class="line">proc; opt; opt; fsm; memory; opt</span><br><span class="line">show -format dot -prefix ./mux4_to_1</span><br></pre></td></tr></table></figure>
<p>得到结果：</p>
<p>最终结果展示：其中 <code>.dot</code> 文件打开后可以使用快捷键 <code>Ctrl+Shift+v</code> 得到可视化电路图。</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220902105858211.png" alt="image-20220902105858211"><figcaption aria-hidden="true">image-20220902105858211</figcaption>
</figure>
<p>注：默认不读入工艺库的话，Yosys 使用自带的工艺库。</p>
<h3 id="isseus-and-solution">Isseus and Solution</h3>
<p>这一小节记录一下我初用这个工具链遇到的问题：</p>
<ol type="1">
<li><p><strong>Isseus：</strong>进行编译和波形测试时，发现VScode上的WaveTrace插件不能正常进行查看，但是使用GTKwave开源查看，我的编译仿真指令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iverilog -o wave -y ./  alu_tb.v  alu.v </span><br><span class="line">vvp -n wave -lxt2</span><br></pre></td></tr></table></figure>
<p><strong>Solution：</strong>使用下面的指令来生成 .vcd 图像：即不要携带 <code>-lxt2</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vvp wave</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Isseus：</strong>Yosys 出现如下报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR: System task `$display&#x27; called with invalid/unsupported format specifier.</span><br></pre></td></tr></table></figure>
<p><strong>Solution：</strong>如果出现这个报错，考虑将测试的module放在一个单独的文件中，使yosys操作的对象不包括测试使用的module</p></li>
<li><p><strong>Isseus：</strong>==待解决==在 Yosys 命令行中使用 help 指令可以看到 Yosys 中提供指令可以导出有限状态机的图：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220904194326503.png" alt="image-20220904194326503"><figcaption aria-hidden="true">image-20220904194326503</figcaption>
</figure>
<p>即指令 <code>fsm_export</code>，但是在实际操作中使用该指令后打印如下日志：</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220904194520104.png" alt="image-20220904194520104"><figcaption aria-hidden="true">image-20220904194520104</figcaption>
</figure>
<p>但是没有 KISS2 文件在操作目录下生成。</p>
<p><strong>Solution：</strong>这个问题目前没有被解决，但是这里有两个网页可以提供重要参考</p>
<ol type="1">
<li><a href="https://github.com/YosysHQ/yosys/issues/2402">Command "fsm_export" does not generate a .kiss2 file to represent correspondings FSM · Issue #2402 · YosysHQ/yosys</a></li>
<li><a href="https://stackoverflow.com/questions/32645965/fsm-export-using-yosys">verilog - FSM export using Yosys - Stack Overflow</a></li>
</ol></li>
</ol>
<h3 id="在-yosys-中使用工艺库">在 Yosys 中使用工艺库</h3>
<p>在上面的过程中，我们使用 Yosys 读入 <code>.v</code> 文件，将高层次的描述转化为寄存器传输级描述（RTL）进而得到门级描述，然后在转化中我们都进行了化简和优化。得到的门级描述使用 Yosys 自带的单元（cells）进行的描述。我们可以在 Yosys中使用指令 <code>help -cells</code> 来查看 Yosys 默认使用的单元列表：如下图。</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905081644337.png" alt="image-20220905081644337"><figcaption aria-hidden="true">image-20220905081644337</figcaption>
</figure>
<p>我们可以看到 Yosys 中包含有 <code>$_AND_</code> 或者 <code>$_ANDNOT_</code> 这种单元。首先我们先用默认的单元来综合我们的电路，然后导入新的单元来构建满足新工艺库的电路。</p>
<p>用来演示的 Verilog 文件来自 <code>..\yosys-master\yosys-master\examples\cmos</code>，你可以在<a href="https://github.com/YosysHQ/yosys/tree/master/examples/cmos">这里</a>查看。</p>
<p>首先我在 <code>..\yosys-master\yosys-master\examples</code> 目录下创建了一个新的文件夹 <code>my_cmos</code>，然后将 <code>cmos</code> 中的 <code>counter.v</code> 文件移动到 <code>my_cmos</code> 中，然后复制<a href="https://vlsiarch.ecen.okstate.edu/flows/MOSIS_SCMOS/latest/cadence/lib/tsmc025/signalstorm/osu025_stdcells.lib">这里</a>的代码到 <code>my_cmos</code> 文件夹中并命名为 <code>osu025_stdcells.lib</code>。最后使用 oss-cad 组件打开 <code>my_cmos</code> 这个文件夹进行后续操作。</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905093413337.png" alt="image-20220905093413337"><figcaption aria-hidden="true">image-20220905093413337</figcaption>
</figure>
<p>然后进入 Yosys，使用下述指令读入文件到 Yosys：这是我们导入自己的单元库的方法。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read_verilog counter.v</span><br><span class="line">read_liberty osu025_stdcells.lib</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905094143056.png" alt="image-20220905094143056"><figcaption aria-hidden="true">image-20220905094143056</figcaption>
</figure>
<p>现在我们使用快捷键 <code>Ctrl+D</code> 退出 Yosys。然后我们来生成电路图展示一下 yosys 对于电路图的处理。同时我们引入 yosys 指令批量处理的方法：</p>
<p>首先将下述指令复制到一个新建文件夹 <code>my_cells.ys</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">读入 counter.v</span></span><br><span class="line">read_verilog counter.v</span><br><span class="line"><span class="meta"># </span><span class="language-bash">读入后不做任何处理直接显示 counter.v 电路图，生成的文件起名为 a.dot</span></span><br><span class="line">show -prefix ./a</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">synth 指令由一些列综合和化简指令构成，这个命令组最后的效果是得到由 yosys 自带的 cells 构建的电路图</span></span><br><span class="line">synth</span><br><span class="line"><span class="meta"># </span><span class="language-bash">将化简后的结果显示成电路图b</span></span><br><span class="line">show -prefix ./b</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">导入 osu025_stdcells.lib，用库中的 FF(flip-flop) 去替换 yosys 自带的 FF</span></span><br><span class="line">dfflibmap -liberty osu025_stdcells.lib</span><br><span class="line"><span class="meta"># </span><span class="language-bash">将替换触发器后的电路图导出为c</span></span><br><span class="line">show -prefix ./c</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">替换自带的组合逻辑器件</span></span><br><span class="line">abc -liberty osu025_stdcells.lib</span><br><span class="line"><span class="meta"># </span><span class="language-bash">化简</span></span><br><span class="line">opt</span><br><span class="line"><span class="meta"># </span><span class="language-bash">将替换组合逻辑器件后的电路图导出为d</span></span><br><span class="line">show -prefix ./d</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">读入 osu025_stdcells.lib，yosys可以将其中的cells转化为modules</span></span><br><span class="line">read_liberty osu025_stdcells.lib</span><br><span class="line"><span class="meta"># </span><span class="language-bash">最终结果e,只展示 couter module，不展示 osu025_stdcells.lib 中的modules</span></span><br><span class="line">show -prefix ./e counter</span><br></pre></td></tr></table></figure>
<p>然后在 oss-cad 组件中使用 <code>yosys -s my_cells.ys</code> 来批量执行指令</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905105049582.png" alt="image-20220905105049582"><figcaption aria-hidden="true">image-20220905105049582</figcaption>
</figure>
<p>然后打开 <code>.dot</code> 文件观察结果</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905105508223.png" alt="image-20220905105508223"><figcaption aria-hidden="true">image-20220905105508223</figcaption>
</figure>
<p>这两张图重复了使用方法一节中展现的化简过程</p>
<p>然后我们观察后面几张图</p>
<figure>
<img src="/2022/09/02/09-01-15/image-20220905110336491.png" alt="image-20220905110336491"><figcaption aria-hidden="true">image-20220905110336491</figcaption>
</figure>
<p>上图为了进行对比，可能图片不是非常清晰，大家可以自己动手做一下然后进行观察。</p>
<p>到此我们就实现了自己的cells库的导入，你可以进一步通过 <code>write_verilog</code> 指令导出综合后的电路图。</p>
<h3 id="进一步的参考">进一步的参考</h3>
<p>如果想要进一步了解 Yosys 的使用，推荐使用 <a href="https://yosyshq.net/yosys/files/yosys_appnote_011_design_investigation.pdf">Yosys AppNote 011</a>、<a href="https://github.com/YosysHQ/yosys-manual-build/releases/download/manual/manual.pdf">Yosys manual</a> 两篇文章进行学习</p>
<p>如果想要配置 STA 工具，可以参考此工具 <a href="https://github.com/YosysHQ/yosys-manual-build/releases/download/manual/manual.pdf">OpenTimer</a></p>
]]></content>
      <tags>
        <tag>备忘笔记</tag>
      </tags>
  </entry>
</search>
